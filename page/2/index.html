
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hello @You</title>
        <meta name="author" content="Jan6055">
        <meta name="description" content="">
        <meta name="keywords" content="C++,Rust,Jan6055">
        <link rel="icon" href="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hello @you</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hello @you</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(http://p6.qhimg.com/bdr/__85/t015c7bbab0a42e2cf9.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Hello @you</h1>
                <h3>enjoy coding</h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/10/02/Rust指针/">
        <h2 class="post-title">Rust Raw-Ptr</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>提到指针，就一定避免不了谈到引用。因为引用时指针的封装。引用总能指向一个有效的对象，并在指向一个动态对象的时候有着大小的保证。引用的好处有如下几点</p>
<ul>
<li>总能保证引用有效数据</li>
<li>引用与usize大小的倍数对其</li>
<li>引用可以为动态类型大小提供上述保障</li>
</ul>
<p>我们可以使用{:p}的格式来表示要打印指针</p>
<pre><code class="rust">    let a = 10;
    println!(&quot;&#123;:p&#125;&quot;,&amp;a);
</code></pre>
<p>可以看见&amp;a这里被当作了一个指针。</p>
<p>同样的，还能取得数组的首地址。</p>
<pre><code class="rust">    let nums = [10; 5];
    println!(&quot;&#123;:p&#125;&quot;,&amp;nums);
</code></pre>
<p>本应是引用，却有了取地址的意思。一定程度上，把引用和指针一视同仁，把引用看作封装后的指针。</p>
<p>现在再来看解引用操作。</p>
<pre><code class="rust">    let a = 10;
    let ra = &amp;10;
    println!(&quot;&#123;&#125;&quot;,*ra);
</code></pre>
<p>恍然大悟了！虽然ra可以自动解引用，也可以手动解引用。这不就是C吗？取地址和解引用。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>rust更倾向于把指针封装起来，毕竟为了安全嘛。原始指针我们叫做<code>raw-ptr</code>。</p>
<p>什么时<code>raw-ptr</code>呢？就是一个引用呗。那肯定也支持指针算数操作。比如加法运算。</p>
<pre><code class="rust">    let a = 10;
    let ra = &amp;10;
    let b = ra + 1;
    println!(&quot;&#123;b&#125;&quot;);
</code></pre>
<p>很不幸，b是11。因为标准库为我们实现了&amp;i32 i32的Add trait。这样操作就相当于两个i32相加。</p>
<h2 id="raw指针类型"><a href="#raw指针类型" class="headerlink" title="raw指针类型"></a>raw指针类型</h2><p>众所周知C&#x2F;C++中有<code>T*</code>类型，例如<code>int *; double *</code>等。Rust同样的也提供了这样的类型。写法和C&#x2F;C++颇有不同。</p>
<pre><code class="rust">    let a = 10;
    let pa: * const i32 = &amp;a;
    println!(&quot;&#123;:p&#125;&quot;,pa);
    let pa = &amp;a as * const i32;
    println!(&quot;&#123;:p&#125;&quot;,pa);
</code></pre>
<p>Rust中的raw-ptr分为<code>const</code>, <code>mut</code>两种性质。意思为指向的对象不可变，指向的对象可变。</p>
<p>对raw-ptr执行解引用操作需要在unsafe中进行。</p>
<pre><code class="rust">    let a = 10;
    let pa: * const i32 = &amp;a;
    unsafe &#123;
        // *pa = 20; //error
    &#125;
    println!(&quot;&#123;:p&#125;&quot;,pa);
    let pa = &amp;a as * const i32 as * mut i32;
    unsafe &#123;
        *pa = 20;
    &#125;
    assert_eq!(20, a);
    println!(&quot;&#123;:p&#125;&quot;,pa);
</code></pre>
<p>从一个&amp;T来到*mut T需要额外的转换，要先转换为<code>*const</code>,再转换为<code>*mut</code>。但是可以从&amp;mut T直接转换为一个<code>*mut</code>指针。</p>
<pre><code class="rust">    let mut a = 10;
    let pa = &amp;mut a as *mut i32;
</code></pre>
<h2 id="raw指针会破坏rust的借用和所有权规则"><a href="#raw指针会破坏rust的借用和所有权规则" class="headerlink" title="raw指针会破坏rust的借用和所有权规则"></a>raw指针会破坏rust的借用和所有权规则</h2><p>你可能看见了a是一个非mut的变量，却经过*mut指针之手改变为20，使用的时候要注意。rust的不可变性，也不是那么的不可变啊。</p>
<p>这样太容易带来歧义了。按照rust的说法，非mut的，就是不可变，维度指针打破了这种规则。如果指针操作的一个变量可能改变，请生命为mut避免带来歧义。</p>
<h2 id="mut隐式的转换为-const"><a href="#mut隐式的转换为-const" class="headerlink" title="*mut隐式的转换为*const"></a>*mut隐式的转换为*const</h2><pre><code class="rust">   let p: *mut i32 = ptr::null_mut();
   let q: *const i32 = p; //隐式转换
</code></pre>
<h1 id="空指针null"><a href="#空指针null" class="headerlink" title="空指针null"></a>空指针null</h1><p>大多数的C&#x2F;C++错误，空指针是罪魁祸首。rust在safe中没有提供空指针。而是使用Option的None枚举来代表空语义。</p>
<p>现在设计到的raw-ptr,讨论空指针是不可避免的。</p>
<h2 id="ptr-null"><a href="#ptr-null" class="headerlink" title="ptr::null()"></a>ptr::null()</h2><p>但是null这个关键字并没有被rust引入。如果你想获得一个空指针，可以用<code>ptr::null()</code></p>
<pre><code class="rust">let p: * const i32 = ptr::null();
</code></pre>
<p>单纯的对空指针解引用则是一个未定义的行为。在windows上可能会得到一个error,在linux上可能会段错误。</p>
<pre><code class="rust">    unsafe &#123;
        println!(&quot;&#123;&#125;&quot;,*p);
    &#125;
</code></pre>
<p>用<code>ptr_null()</code>获得的指针是不可变的(指向的对象)。</p>
<pre><code class="rust">    let mut p: * const i32 = ptr::null();
    let a = 10;
    p = &amp;a as *const i32;
    unsafe &#123;
        *p = 20; //error
    &#125;
</code></pre>
<h2 id="ptr-mut-null"><a href="#ptr-mut-null" class="headerlink" title="ptr::mut_null()"></a>ptr::mut_null()</h2><p>同样是获得指针，但是是可变的(指向的对象)</p>
<pre><code class="rust">    let mut p: * mut i32 = ptr::null_mut();
    let mut a = 10;
    p = &amp;a as *const i32 as *mut i32;
    unsafe &#123;
        *p = 20; //ok
    &#125;
</code></pre>
<h2 id="is-null"><a href="#is-null" class="headerlink" title="is_null()"></a>is_null()</h2><p>你可以使用is_null来判断一个指针是否为空。</p>
<pre><code class="rust">    let p: * const i32 = ptr::null();
    assert!(p.is_null());
</code></pre>
<h1 id="使用raw-ptr迭代容器"><a href="#使用raw-ptr迭代容器" class="headerlink" title="使用raw-ptr迭代容器"></a>使用raw-ptr迭代容器</h1><p>rust肯定不推荐使用raw-ptr来迭代容器。毕竟标准库已经为我们提供了那么多用于迭代的方法。rust也内置了<code>for in</code>来进行迭代。如果不是为学习&#x2F;系统编程。没人会这样做。对raw-ptr的操作要放在unsafe里，这是不安全的。但最主要的是——不要有现成的工具不用而跑去当猴子。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>例如用raw-ptr迭代一个C风格个字符串。</p>
<pre><code class="rust">static c_string: [u8; 8] = [97,98,99,100,101,102,103,b&#39;\0&#39;];
fn main() &#123;
    let mut curr = &amp;c_string as *const u8;
    unsafe &#123;
        while *curr != b&#39;\0&#39; &#123;
            print!(&quot;&#123;&#125; &quot;,*curr as char);
            curr = curr.add(1);
        &#125;
    &#125;
&#125;
</code></pre>
<p>rust对于裸指针的+操作，并没有直接用加号。而是提供了一个add()方法。类似的，还提供了一个名为sub()方法，代替-。</p>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><p>给定一个String，判断这个String是否是回文。假定String中的字符全为英文字母。</p>
<pre><code class="rust">fn main() &#123;
    let s = String::from(&quot;helloolleh&quot;);
    println!(&quot;&#123;&#125;&quot;,is_palindrome(&amp;s));
&#125;

//判断一个s: &amp;str是否是回文
fn is_palindrome(s: &amp;str) -&gt; bool &#123;
    let mut first = s.as_ptr();
    unsafe &#123;
        let mut last = s.as_ptr().add(s.len()-1);
        while first &lt; last &#123;
            if *first != *last &#123;
                return false;
            &#125;
            first = first.add(1);
            last = last.sub(1);
        &#125;
    &#125;
    true
&#125;
</code></pre>
<h1 id="unsafe链表"><a href="#unsafe链表" class="headerlink" title="unsafe链表"></a>unsafe链表</h1>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #00bcd4">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Unsafe-Rust/" style="color: #00bcd4">
                Unsafe Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Effective-Rust/" style="color: #00a596">
                Effective Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/02/Rust指针/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/01/区别-mut-mut-mut-mut/">
        <h2 class="post-title">区别&amp; Mut; Mut &amp;; Mut &amp; Mut</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/1
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>这里讨论的问题就像C++中的<code>const *</code>,<code>* const</code>,<code>const * const</code>一样，你完全可以类比。</p>
<pre><code class="rust">#[allow(unused)]
fn work_2() &#123;
    let mut a = 10;
    &#123;
        let b = 20;
        let ref_a = &amp;a; // -&gt; &amp;i32
        ref_a = &amp;b;            //将引用指向b不可以
        let mut mut_ref_a = &amp;a; //mut &amp;i32
        *mut_ref_a = 20;       //更改变量本身，不可以
        mut_ref_a = &amp;b;        //将引用指向b，可以
    &#125;
    let ref_mut_a = &amp;mut a; // -&gt; &amp;mut i32
    *ref_mut_a = 20;  //更改变量本身的值，可以
&#125;
</code></pre>
<ul>
<li>&amp; mut代表着对一个变量的可变引用，引用的变量是可变的，但是引用本身是不可变的，也就是说当我确定引用一个变量的时候，就不能再引用其他变量了。</li>
<li>mut &amp;代表着引用本身是可变的，即这个引用既可以引用a，又可以引用b，但是引用的变量是不可变的。</li>
<li>&amp; mut &amp; 即代表着上述两者的结合，引用本身是可变的，并且引用的变量也是可变的。</li>
</ul>
<pre><code class="error">jan@jan:~/code/rust/option_$ cargo run
   Compiling option_ v0.1.0 (/home/jan/code/rust/option_)
error[E0384]: cannot assign twice to immutable variable `ref_a`
  --&gt; src/main.rs:24:9
   |
23 |         let ref_a = &amp;a; // -&gt; &amp;i32
   |             -----
   |             |
   |             first assignment to `ref_a`
   |             help: consider making this binding mutable: `mut ref_a`
24 |         ref_a = &amp;b;            //将引用指向b不可以
   |         ^^^^^^^^^^ cannot assign twice to immutable variable
 
error[E0594]: cannot assign to `*mut_ref_a`, which is behind a `&amp;` reference
  --&gt; src/main.rs:26:9
   |
25 |         let mut mut_ref_a = &amp;a; //mut &amp;i32
   |                             -- help: consider changing this to be a mutable reference: `&amp;mut a`
26 |         *mut_ref_a = 20;       //更改变量本身，不可以
   |         ^^^^^^^^^^^^^^^ `mut_ref_a` is a `&amp;` reference, so the data it refers to cannot be written
 
Some errors have detailed explanations: E0384, E0594.
For more information about an error, try `rustc --explain E0384`.
error: could not compile `option_` due to 2 previous errors
</code></pre>
<p>mut &amp;可以用来充当指针的位置，例如输出一个Box+Option的链表。</p>
<p>为了简便，不实现Display Trait,而是用一个方法</p>
<pre><code class="rust">impl &lt;T:Display&gt; LinkedList&lt;T&gt; &#123;
    pub fn display(&amp;self) &#123;
        let mut curr = &amp;self.head; //curr: mut &amp;Link
        while let Some(node) = curr &#123;
            println!(&quot;&#123;&#125;&quot;,node.data);
            curr = &amp;node.next;
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #ff7d73">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Effective-Rust/" style="color: #03a9f4">
                Effective Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/01/区别-mut-mut-mut-mut/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/01/Rust通过Box方式实现LinkedList/">
        <h2 class="post-title">Rust通过Box方式实现LinkedList</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/1
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="链表在rust中"><a href="#链表在rust中" class="headerlink" title="链表在rust中"></a>链表在rust中</h1><p>别的语言，学习的差不多了。写个链表试试？</p>
<p>Rust，学习的差不多的，写个链表，逝世！</p>
<p>虽然rust是系统及编程语言，但那和safe代码没有什么关系，在safe代码中，你依旧不能灵活的操纵内存。</p>
<p>代替的可以使用Box来当作指针，但是由于所有权和借用的规则，使得Option+Box这种形式写出的LinkedList既复杂，又低效。但是对于学习来说还是很有帮助的。所以，本篇文章将编码一个支持基础操作的LinkedList，并解释说明那些烦人的细节。</p>
<p>希望本篇文章能对你对Rust的理解有帮助。本文章基于《通过链表学rust》。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们要写一个泛型的链表。使用<code>Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;</code>这样的形式，来组织一个最基本的链式结构。</p>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>使用类型别名是由必要的。Link是如下的别名</p>
<pre><code class="rust">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</code></pre>
<p>这样可以避免冗长且不易阅读的代码。然后请你记住一个重要的，Link不是一个指针类型，你很可能基于C风格语言的习惯将Link看作一个指针——在我们这个例子中不是这样的。但可以做到这样，那是unsafe的事情了。在我们例子中，<strong>Link是一个Option。</strong>使用<code>Option&lt;Box&lt;&gt;&gt;</code>可以模拟出类似指针的东西。但是你在处理LinkedList的时候大可将其当作一个指针来看待。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>我们需要一个T类型的数据，和一个next来“指向”下一个Node。</p>
<pre><code class="C++">struct Node&lt;T&gt; &#123;
    data: T,
    next: Link&lt;T&gt;,
&#125;
</code></pre>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>只需要一个头指针，就可以找到整个LinkedList。这个head类似于C++中的<code>Node*</code>,在构造的时候<code>head = nullptr</code>,就是说，头指针不默认指向一个节点。</p>
<pre><code class="C++">pub struct LinkedList&lt;T&gt; &#123;
    head: Link&lt;T&gt;,
&#125;
</code></pre>
<p>为什么没有提供size？</p>
<p>对于单向链表的size相关操作，需要额外的维护成本。如果使用单项链表，不要求size操作。否则使用双向链表。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new关联方法，返回一个初始化的LinkedList，只需要将head初始化为None即可。</p>
<pre><code class="rust">    pub fn new() -&gt; Self &#123;
        LinkedList &#123;
            head: None,
        &#125;
    &#125;
</code></pre>
<h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><p>头插入一个节点。</p>
<p>在编码之前，我们需要想想如何进行节点的额移动。</p>
<ul>
<li><p>首先，这个操作会改变链表，所以需要&amp;mut self做参数。</p>
</li>
<li><p>在方法体中，新建一个节点，并赋予初值。</p>
</li>
<li><p>让新建节点的next指向头</p>
</li>
<li><p>头指向新建节点</p>
</li>
</ul>
<p>这些操作，你在数据结构中已经看见过了，而且身经百战的你，在经历各种语言的摧残之后，心想：这还不简单？但是rust却给了你当头一棒。你试尽了你能想到的所有办法，却只写出一段自己都不愿意阅读的，撇脚的代码。这就是作者的真实经历。</p>
<p>“独学而无友，则孤陋而寡闻”。是时候看一看别人是怎样写的了。</p>
<pre><code class="rust">    pub fn push_front(&amp;mut self, val: T) &#123;
        let new_node = Box::new(Node &#123;
            data: val,
            next: self.head.take(),
        &#125;);
        self.head = Some(new_node)
    &#125;
</code></pre>
<p>我们来一点点分析</p>
<p>创建一个新的节点</p>
<pre><code class="rust">        let new_node = Box::new(Node &#123;
            data: val,
            next: self.head.take(),
        &#125;);
</code></pre>
<p>其中take方法会将Option设置为None，并返回原先的值。</p>
<p>这几行代码新建了一个节点，还有将head滞空(赋值为None)。</p>
<p>将head指向新建节点，这步只需要将被some新建节点赋值给head即可。</p>
<pre><code class="rust">self.head = Some(new_node)
</code></pre>
<p>因为self是&amp;mut, 所以这里直接使用&#x3D;就可以完成。</p>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>peek方法返回<code>Option&lt;&amp;T&gt;</code>。</p>
<ul>
<li>如果head是一个None，返回None</li>
<li>否则返回Some&lt;&amp;T&gt;</li>
</ul>
<p>你可能会想到match匹配。可以这样做。</p>
<pre><code class="rust">    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; &#123;
        match &amp;self.head &#123;
            None =&gt; None,
            Some(node) =&gt; Some(&amp;node.data)
        &#125;
    &#125;
</code></pre>
<p>&amp;具有最低的优先级,即<code>&amp;(self.head)</code></p>
<p><code>&amp;self.head</code>是必要的。match不会消费对象，但是结构Some<code>Some(node)</code>会转移所有权。就会得到一个编译错误。那是因为我们移动一个已经被借用的值<code>Box obj</code>。这个值已经被self借用了，你却要把它移动给node。</p>
<h3 id="peek-mut"><a href="#peek-mut" class="headerlink" title="peek_mut"></a>peek_mut</h3><p>与peek相同，但是返回可变引用</p>
<pre><code class="rust">    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; &#123;
        match &amp;mut self.head &#123;
            None =&gt; None,
            Some(node) =&gt; Some(&amp; mut node.data)
        &#125;
    &#125;
</code></pre>
<p>同理的，<code>match</code>应当匹配<code>&amp;mut self.head</code>。</p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop究竟该如何操作，我想你在学数据结构的时候都已经快听的耳朵起茧子了额。但是在这里，还是要复述一遍。</p>
<ul>
<li>如果head为空，什么也不做，返回一个具有空语义的对象</li>
<li>获取头的next名为node</li>
<li>头指向node</li>
<li>返回node中的值&#x2F;进行其他的操作</li>
</ul>
<p>用Rust语言来描述，可以用match来匹配head是否为None,如果是返回None,如果不是，会匹配出原来的head叫做node，然后更新head,返回node中的数据即可。</p>
<p>我们可以改变以下实现手法，使用take方法，取得head的所有权。然后再重新赋值head。</p>
<pre><code class="rust">    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; &#123;
        match self.head.take() &#123;
            None =&gt; None,
            Some(node) =&gt; &#123; //node 为原来的head
                self.head = node.next;	//node.next: Link&lt;T&gt; 变为新头
                Some(node.data)	
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><p>我们可以不实现drop，用编译器为我们实现的——调用head的drop。于是drop Box中的对象，然后Box中的对象是一个Node，Node中又含有Link，这会是一个尾递归？不是的，编译器生成的drop会含有其他的操作。这不是一个尾递归。</p>
<p>我们需要手动的为LinkedList实现drop这个trait。具体的做法是</p>
<p>把递归改为迭代，每次获得一个节点的所有权，让后让其离开作用域自动drop，因为是一个循环，所以不会出现栈溢出这种情况。</p>
<pre><code class="rust">impl &lt;T&gt; Drop for LinkedList&lt;T&gt; &#123;
    fn drop(&amp;mut self) &#123;
        let mut curr = self.head.take(); //获得head的所有权
        while let Some (node) = curr &#123;	//让node绑定的对象离开作用域自动drop
            curr = node.next;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>为LinkedList提供迭代器。他们分别是<code>Iter</code>,<code>IntoIter</code>,<code>IterMut</code>。其中<code>Iter</code>,<code>IterMut</code>需要额外注意生命周期。</p>
<h3 id="IntoIter"><a href="#IntoIter" class="headerlink" title="IntoIter"></a>IntoIter</h3><p>IntoIter是最好实现的。因为其再迭代的时候会消耗容器，所以只需要每次pop以下就好了。</p>
<pre><code class="rust">struct IntoIter&lt;T&gt; &#123;
    list: LinkedList&lt;T&gt;,
&#125;

impl &lt;T&gt; Iterator for IntoIter&lt;T&gt; &#123;
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        self.list.pop()
    &#125;
&#125;
</code></pre>
<h3 id="Iter"><a href="#Iter" class="headerlink" title="Iter"></a>Iter</h3><p>Iter就相对比较难一点，我们需要获取容器的不可变引用。并迭代。如何指向链表的下一个节点，是一个问题。</p>
<p>Iter中定义一个<code>curr: Option&lt;T&gt;</code>，指向当前的节点，每次调用next，就返回curr的值，然后更新curr。</p>
<p>还是可以使用match来匹配。</p>
<pre><code class="rust">pub struct Iter &lt;&#39;a, T&gt; &#123;
    curr: Option&lt;&amp;&#39;a Node&lt;T&gt;&gt;,
&#125;

impl &lt;&#39;a, T&gt; Iterator for Iter&lt;&#39;a, T&gt; &#123;
    type Item = &amp;&#39;a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        match self.curr &#123;
            None =&gt; None,
            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref();
                Some(&amp;node.data)
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>由于self中的curr为Option包裹的引用类型，所以match匹配出来的值也是一个&amp;类型，不用再额外添加引用。、</p>
<p>Some的部分值得拿出来好好说说。</p>
<pre><code class="rust">            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref();
                Some(&amp;node.data)
            &#125;
</code></pre>
<p>先搞清楚类型,<code>curr: Option&lt;Node&lt;T&gt;&gt;</code>,<code>node.next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;</code>。我们直接使用<code> self.curr = node.next</code>来赋值，类型不对。<code>Some(&amp;Node) &lt;- Some(Box&lt;Node&lt;T&gt;&gt;)</code>,要是给Box解引用就好了。使用<code>as_deref</code>方法来返回一个解引用(被Some包裹的)。正好合适。</p>
<p>然后返回node中的data即可，别忘了添加&amp;。</p>
<h3 id="IterMut"><a href="#IterMut" class="headerlink" title="IterMut"></a>IterMut</h3><p>IterMut又设计到了可变性。编码要考虑的因素就更多了。</p>
<p>老样子，我们对Iter使用的方法，故技重施看看。</p>
<pre><code class="rust">pub struct IterMut&lt;&#39;a, T&gt; &#123;
    curr: Option&lt;&amp;&#39;a mut Node&lt;T&gt;&gt;
&#125;

impl &lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; &#123;
    type Item = &amp;&#39;a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        match self.curr &#123;
            None =&gt; None,
            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref_mut();
                Some(&amp;mut node.data)
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>会得到这样的编译错误。</p>
<pre><code class="error">error[E0507]: cannot move out of `self.curr.0` which is behind a mutable reference
  --&gt; src\first.rs:88:15
   |
88 |         match self.curr &#123;
   |               ^^^^^^^^^ help: consider borrowing here: `&amp;self.curr`
89 |             None =&gt; None,
90 |             Some(node) =&gt; &#123;
   |                  ----
   |                  |
   |                  data moved here
   |                  move occurs because `node` has type `&amp;mut Node&lt;T&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>编译器说我们移动了以已经绑定可变引用的变量。</p>
<p>奇怪，为什么Iter可以而IterMut不可以呢？原因是不能对<code>&amp;mut &amp; T</code>进行copy，就是没有实现<code>Copy trait</code>,那怎么办？。那就又回到了peek的情况——移动了一个已经被借用的变量。只不过这个变量是一个可变引用<code>&amp;mut</code>。</p>
<p>按照编译器的方法改。你大可试试，会有更多的错误。换一种方法吧。</p>
<p>还是take方法。</p>
<pre><code class="rust">pub struct IterMut&lt;&#39;a, T&gt; &#123;
    curr: Option&lt;&amp;&#39;a mut Node&lt;T&gt;&gt;
&#125;

impl &lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; &#123;
    type Item = &amp;&#39;a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        match self.curr.take() &#123;
            None =&gt; None,
            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref_mut();
                Some(&amp;mut node.data)
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="iter-into-iter-iter-mut"><a href="#iter-into-iter-iter-mut" class="headerlink" title="iter into_iter iter_mut"></a>iter into_iter iter_mut</h3><p>LinkedList的这三个方法如下定义。</p>
<pre><code class="rust">    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; &#123;
        Iter &#123;
            curr: self.head.as_deref(),
        &#125;
    &#125;

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; &#123;
        IterMut &#123;
            curr: self.head.as_deref_mut()
        &#125;
    &#125;

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; &#123;
        IntoIter &#123;
            list: self
        &#125;
    &#125;
</code></pre>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code class="rust">fn main() &#123;
    let mut ls = LinkedList::new();
    ls.push_front(12);
    ls.push_front(14);
    ls.push_front(100);
    ls.push_front(222);
    ls.pop();
    assert_eq!(ls.peek(), Some(&amp;100));
    assert_eq!(ls.peek_mut(), Some(&amp;mut 100));
    for val in ls.iter() &#123;
        println!(&quot;&#123;&#125;&quot;,val);
    &#125;
    for val in ls.iter_mut() &#123;
        *val += 1;
        println!(&quot;&#123;&#125;&quot;,val);
    &#125;
    for val in ls.into_iter() &#123;
        println!(&quot;&#123;&#125;&quot;,val);
    &#125;
&#125;
</code></pre>
<p>很好的工作了起来！</p>
<p>再来看看数据量大的时候，会不会栈溢出。</p>
<pre><code class="rust">fn main() &#123;
    let mut ls = LinkedList::new();
    let n: usize = 10000000;
    for i in 0..n &#123;
        ls.push_front(i);
    &#125;
&#125;
</code></pre>
<p>很好，栈没有溢出。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果谁犯下了大罪。我一定让他试试在不看资料的情况下手写一个Option+Box的链表。</p>
<p>玩笑归玩笑，好好的看清楚上面的实现，还是能对所有权和借用和声明周期的理解更上一层楼的。</p>
<p>对于peek,peek_mut等函数，你也可以使用map来实现，但是使用map会获得所所有权，又需要额外的处理。本文保留了match方法。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #ff7d73">
                Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/01/Rust通过Box方式实现LinkedList/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/29/Rust字符串处理/">
        <h2 class="post-title">Rust字符串处理</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/29
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Rust中的字符串"><a href="#Rust中的字符串" class="headerlink" title="Rust中的字符串"></a>Rust中的字符串</h1><p>rust中的字符串是一个 UTF-8 编码的可增长字符串。</p>
<p>String 类型是最常见的字符串类型，拥有对该字符串内容的所有权。它与其借用的对应物，原始的 str 有着密切的关系。</p>
<p>rust中的字符串对新手非常的不友好。由于String是基于utf_8编码的，导致很多操作需要额外的中间层。文篇文章的目的在于理清String的各种处理法。</p>
<h1 id="String的数据结构"><a href="#String的数据结构" class="headerlink" title="String的数据结构"></a>String的数据结构</h1><p>String内含一个Vec<u8>,所以String和Vec的结构完全相同。Vec的实现用了多层的嵌套。这里将String的数据结构直接抽象出来</p>
<p>你可以将String理解为这样的数据结构</p>
<ul>
<li>一个ptr 指向u8数组</li>
<li>len为String的长度</li>
<li>capacity为String的容量。</li>
</ul>
<h1 id="如何处理string"><a href="#如何处理string" class="headerlink" title="如何处理string"></a>如何处理string</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>String提供了很多可以直接更新字符串的方法，例如<code>push</code>、<code>push_str</code>、<code>clean</code>、<code>pop</code>等。</p>
<p>还有一些处理字符串的宏。</p>
<p>这些方法和宏标准库文档都已经写的够好的了，或者你也可以看看rust程序语言设计这本书。我不相信我能比标准库撰写人员有着对标准库更好的解释。这一部分，可以直接阅标准库提供的文档或者书籍。</p>
<p>这里列举出一些常用方法的函数原型</p>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.trim">trim</a>(&amp;self) -&gt; &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a></p>
<p>返回除去前导空格的字符串切片</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.split">split</a>&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/struct.Split.html">Split</a>&lt;’a, P&gt; where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>在此字符串切片的子字符串上进行迭代的迭代器，该子字符串由模式匹配的字符分隔</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.split_at">split_at</a>(&amp;self, mid: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.usize.html">usize</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.tuple.html">(</a>&amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a>, &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.tuple.html">)</a> </p>
<p>在索引处将一个字符串切片分成两个</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.parse">parse</a><F>(&amp;self) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/result/enum.Result.html">Result</a>&lt;F, &lt;F as <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html">FromStr</a>&gt;::<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html#associatedtype.Err">Err</a>&gt;where   F: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html">FromStr</a> </p>
<p>将此字符串切片解析为另一种类型</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.repeat">repeat</a>(&amp;self, n: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.usize.html">usize</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String </a>  </p>
<p>通过重复字符串 <code>n</code> 次来创建新的 <a href="%5Chttps://rustwiki.org/zh-CN/std/string/struct.String.html"><code>String</code></a></p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.lines">lines</a>(&amp;self) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/struct.Lines.html">Lines</a>&lt;’_&gt; </p>
<p>在字符串的各行上进行迭代的迭代器，作为字符串切片。</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.replace">replace</a>&lt;’a, P&gt;(&amp;’a self, from: P, to: &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String</a>where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>用另一个字符串替换模式的所有匹配项。</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.replacen">replacen</a>&lt;’a, P&gt;(&amp;’a self, pat: P, to: &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a>, count: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.usize.html">usize</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String</a>where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>用另一个字符串替换模式的前 N 个匹配项</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.find">find</a>&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/option/enum.Option.html">Option</a>&lt;usize&gt;where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>返回此字符串切片中与模式匹配的第一个字符的字节索引</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.get">get</a><I>(&amp;self, i: I) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/option/enum.Option.html">Option</a>&lt;&amp;&lt;I as <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/slice/trait.SliceIndex.html">SliceIndex</a>&lt;str&gt;&gt;::<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/slice/trait.SliceIndex.html#associatedtype.Output">Output</a>&gt;  where I: SliceIndex&lt;str&gt; </p>
<p>返回 <code>str</code> 的子切片</p>
</blockquote>
<p>还有他们的变体等等。例如<code>rfind</code>,<code>get_mut</code>,<code>rsplit</code>等。</p>
<h2 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h2><p>由于String不能像C++中的std::string直接进行下标运算符，很多操作都需要将其转为vec来进行处理。我们需要这两个方法</p>
<ul>
<li><h4 id="pub-fn-into-bytes-self-gt-Vec-lt-u8-Global-gt"><a href="#pub-fn-into-bytes-self-gt-Vec-lt-u8-Global-gt" class="headerlink" title="pub fn into_bytes(self) -&gt; Vec&lt;u8, Global&gt;"></a>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.into_bytes">into_bytes</a>(self) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/vec/struct.Vec.html">Vec</a>&lt;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.u8.html">u8</a>, <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/alloc/struct.Global.html">Global</a>&gt;</h4></li>
<li><h4 id="pub-fn-from-utf8-vec-Vec-lt-u8-Global-gt-gt-Result-lt-String-FromUtf8Error-gt"><a href="#pub-fn-from-utf8-vec-Vec-lt-u8-Global-gt-gt-Result-lt-String-FromUtf8Error-gt" class="headerlink" title="pub fn from_utf8(vec: Vec&lt;u8, Global&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;"></a>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.from_utf8">from_utf8</a>(vec: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/vec/struct.Vec.html">Vec</a>&lt;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.u8.html">u8</a>, <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/alloc/struct.Global.html">Global</a>&gt;) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/result/enum.Result.html">Result</a>&lt;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String</a>, <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.FromUtf8Error.html">FromUtf8Error</a>&gt;</h4></li>
</ul>
<p>你可以点击链接看看标准库的文档。</p>
<p>例如，我们要对输入的字符串只去回车，可以将String转为Vec&#x2F;u8数组，然后对Vec&#x2F;u8数组操作再转为String。</p>
<pre><code class="rust">    let s = String::from(&quot;我爱你rust\n&quot;);
    let mut vec: Vec&lt;u8&gt; = s.into_bytes();
    if vec[vec.len()-1] == b&#39;\n&#39; &#123;
        vec.remove(vec.len()-1);
    &#125;
    let s = String::from_utf8(vec).unwrap();
    println!(&quot;&#123;:#?&#125;&quot;,s);
</code></pre>
<p>转换来转换去不会影响性能吗？不会的，你看这两个方法的函数签名。是所有权在转移而已，并没有复制内部的数据结构。</p>
<p>对每个字符串中的字符之间插入空格</p>
<pre><code class="rust">    let s = String::from(&quot;helloworld&quot;);
    let mut vec: Vec&lt;u8&gt; = s.into_bytes();
    let mut i = 1;
    let mut n = vec.len()-1;
    while n != 0 &#123;
        vec.insert(i,b&#39; &#39;);
        i += 2;
        n -= 1;
    &#125;
    let s = String::from_utf8(vec).unwrap();
    println!(&quot;&#123;:#?&#125;&quot;,s);
</code></pre>
<p>把字符串拆分为不同的单词</p>
<pre><code class="rust">    let s = String::from(&quot;hello world hello rust&quot;);
    let vec: Vec&lt;u8&gt; = s.into_bytes();
    let mut words = vec![];
    let mut f = 0;
    let mut p = false;
    for i in 0..vec.len() &#123;
        if (b&#39;a&#39;..=b&#39;z&#39;).contains(&amp;vec[i]) &amp;&amp; !p &#123;
            p = true;
            f = i;
        &#125; else if vec[i] == b&#39; &#39;&#123;
            p = false;
            words.push(String::from_utf8(Vec::from(&amp;vec[f..i])).unwrap());
        &#125; else if i == vec.len()-1 &#123;
            words.push(String::from_utf8(Vec::from(&amp;vec[f..=i])).unwrap());
        &#125;
    &#125;
    for word in words &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>好家伙，就是为了这点醋才包的饺子。</p>
<h2 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h2><p>rust使用迭代器+闭包的形式来支持函数式编程。还是上述拆分字符串为单词的问题。我们使用函数式会很好的解决。</p>
<pre><code class="rust">    let s = String::from(&quot;hello word hello rust&quot;);
    let words = s.split(&#39; &#39;)
        .map(|s| s.to_string())
        .collect::&lt;Vec&lt;String&gt;&gt;();
    for word in words &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>就是两个字，优雅！</p>
<p>类似的，还有<code>filter</code>,<code>folder</code>,<code>take_while</code>等很多的FP方法。</p>
<p>删除字符串中的所有回车+空格，我们可以使用retain方法。</p>
<pre><code class="rust">    let mut s = String::from(&quot;hello _world \n \n _hello _rust &quot;);
    s.retain(|ch| ![&#39;\n&#39;,&#39; &#39;].contains(&amp;ch));
    println!(&quot;&#123;&#125;&quot;,s);
</code></pre>
<p>还是TM的优雅。如果是用C写相同的功能需要多少倍的代码和时间。</p>
<p>可以看出，函数式编程是一个很好的处理问题的方式，不单单是在处理String中。</p>
<h2 id="结构化-函数式"><a href="#结构化-函数式" class="headerlink" title="结构化+函数式"></a>结构化+函数式</h2><p>你可以将结构化编程和函数式编程组合起来。也是一个不错的选择。还是上述的问题。我们可以这样解决。</p>
<pre><code class="rust">    let s = String::from(&quot;hello word hello rust&quot;);
    let mut words = vec![];
    for word in s.split(&#39; &#39;) &#123;
        words.push(word.to_string());
    &#125;
    for word in words &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>也是同样的优雅。</p>
<h2 id="处理字"><a href="#处理字" class="headerlink" title="处理字"></a>处理字</h2><p>我们里的字，并不是指的计算机系统中的字。而是日常生活中的字。比如’中’是一个字。</p>
<p>可以使用chars这个迭代器来迭代字。</p>
<pre><code class="rust">    let s = String::from(&quot;春江潮水连海平&quot;);
    for word in s.chars() &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>注意用chars处理英文字母的时候，得到的是字符。有或者是处理其他像英文那样的语言。得到的都是单个字符。</p>
<h2 id="处理原始字节"><a href="#处理原始字节" class="headerlink" title="处理原始字节"></a>处理原始字节</h2><p>可以使用bytes来迭代String内部的字节数组</p>
<pre><code class="rust">let s = String::from(&quot;hello _world \n \n _hello _rust &quot;);
for byte in s.bytes() &#123;
    print!(&quot;&#123;&#125; &quot;,byte);
&#125;
</code></pre>
<p>输出：</p>
<blockquote>
<p>104 101 108 108 111 32 95 119 111 114 108 100 32 10 32 10 32 95 104 101 108 108 111 32 95 114 117 115 116 32 </p>
</blockquote>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>一提到字符串的拼接，你第一印象是怎么处理。直接使用+？你可能是一个C++程序员。调用方法？那你可能是一个java程序员。</p>
<p>rust对于上述的两种方式都有提供。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用+"></a>使用+</h3><p>我们看一看std::ops::Add这个trait的定义</p>
<pre><code class="rust">pub trait Add&lt;Rhs = Self&gt; &#123;
    /// The resulting type after applying the `+` operator.
    type Output;	//关联类型
    fn add(self, rhs: Rhs) -&gt; Self::Output; //必须定义的add方法，zhu
&#125;
</code></pre>
<p>标准库为String实现了类似这样的Add trait<code>fn add(self, s: &amp;str) -&gt; String</code>。</p>
<p>我们不能直接将两个String类型的对象相加，但是可以String+字符串面量。并且消耗self。</p>
<p>也就是说，我们进行连+的时候，应当这样写。</p>
<pre><code class="rust">    let hello = String::from(&quot;hello&quot;);
    let world = String::from(&quot;world&quot;);
    let rust = String::from(&quot;rust&quot;);
    // let s = hello + world; error
    //整个表达式从左向右求值。
    let s = hello + &quot; &quot; + &amp;world + &quot; hello &quot; + &amp;rust;		//&amp;String -&gt; &amp;str,隐式的解引用类型转换
    println!(&quot;&#123;s&#125;&quot;);
</code></pre>
<p>这语法也是没谁了。怎么会有这样的不一致性。对String进行+操作左右类型还不一样。所有权还会丢失。</p>
<p>但实际想想标准库这样做是有依据的。</p>
<ul>
<li>左值转移所有权给返回值，这样做可以避免拷贝。</li>
<li>提供了更加统一的接口</li>
</ul>
<h3 id="使用宏"><a href="#使用宏" class="headerlink" title="使用宏"></a>使用宏</h3><p>format！可以拼接String</p>
<pre><code class="rust">    let hello = String::from(&quot;hello&quot;);
    let world = String::from(&quot;world&quot;);
    let rust = String::from(&quot;rust&quot;);
    let s = format!(&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;,hello,world,&quot;hello&quot;,rust);
    println!(&quot;&#123;s&#125;&quot;);
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总而言之，字符串还是很复杂的。不同的语言选择了不同的向开发者展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着开发者们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。	————rust程序语言设计</p>
<p>其实学习如何处理字符串，就是在学习如何使用标准库。如果你对标准库中的一些宏和函数了如指掌。处理字符串对你来说也应当是小菜一碟。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #ff7d73">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Rust-Library/" style="color: #ffa2c4">
                Rust Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/29/Rust字符串处理/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/28/type-traits源码分析-三/">
        <h2 class="post-title">Type-Traits源码分析(三)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/28
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>在第三章中，会有一些新的东西，不同于一二章，TMP开始加速了！你将会看见额外的一些元函数实现手法，你肯定会惊讶它的巧妙，特别是void_t类型。总之，做好准备，这章的难度可不同于以往了！</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="is-one-of"><a href="#is-one-of" class="headerlink" title="__is_one_of"></a>__is_one_of</h2><p>传入一个类型T和一个参数包Ts，返回其T是不是Ts其中的一个类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>有了这个type_traits，可以更加轻松的实现其他type_traits。</p>
<p>这个type_traits的实现方式也是比较的有意思。我们可以有很多种方式来实现<code>__is_one_of</code>这个元函数，包括使用模板递归继承的方式来实现。gcc则是采用的参数包模式展开的方式。</p>
<pre><code class="C++">  template&lt;typename _Tp, typename... _Types&gt;
    using __is_one_of = __or_&lt;is_same&lt;_Tp, _Types&gt;...&gt;; //用is_same这个模式来对参数包展开，相当于每个类型都和_Tp应用于is_same,再用作于__or_，即可获得结果。
</code></pre>
<h2 id="is-signed-x2F-unsinged-integer"><a href="#is-signed-x2F-unsinged-integer" class="headerlink" title="__is_signed&#x2F;unsinged_integer"></a>__is_signed&#x2F;unsinged_integer</h2><p>入一个类型，返回其是不是，如一个有符号&#x2F;无符号的整数果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<pre><code class="C++">  // Check if a type is one of the signed integer types.
  template&lt;typename _Tp&gt;
    using __is_signed_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;, //继承__is_one_of&lt;符合要求的类型参数包&gt;
      signed char, signed short, signed int, signed long,
      signed long long
#if defined(__GLIBCXX_TYPE_INT_N_0)			//条件编译大可忽略
      , signed __GLIBCXX_TYPE_INT_N_0
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
      , signed __GLIBCXX_TYPE_INT_N_1
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
      , signed __GLIBCXX_TYPE_INT_N_2
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
      , signed __GLIBCXX_TYPE_INT_N_3
#endif
      &gt;;		
</code></pre>
<p>实现方式大同小异</p>
<pre><code class="C++">  // Check if a type is one of the unsigned integer types.
  template&lt;typename _Tp&gt;
    using __is_unsigned_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;,
      unsigned char, unsigned short, unsigned int, unsigned long,
      unsigned long long
#if defined(__GLIBCXX_TYPE_INT_N_0)
      , unsigned __GLIBCXX_TYPE_INT_N_0
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
      , unsigned __GLIBCXX_TYPE_INT_N_1
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
      , unsigned __GLIBCXX_TYPE_INT_N_2
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
      , unsigned __GLIBCXX_TYPE_INT_N_3
#endif
      &gt;;
</code></pre>
<h2 id="is-standard-integer"><a href="#is-standard-integer" class="headerlink" title="__is_standard_integer"></a>__is_standard_integer</h2><p>传入一个类型，返回其是不是标准定义的整数，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>这个type_traits是其他type_traits组合起来的一个别名。这也是元函数的一个实现手法。</p>
<pre><code class="C++">  // Check if a type is one of the signed or unsigned integer types.
  template&lt;typename _Tp&gt;
    using __is_standard_integer
      = __or_&lt;__is_signed_integer&lt;_Tp&gt;, __is_unsigned_integer&lt;_Tp&gt;&gt;;
</code></pre>
<h2 id="void-t"><a href="#void-t" class="headerlink" title="void_t"></a>void_t</h2><p>void_t，就是一个void的别名，但是带有类型参数。你会说：这不是脱裤子放屁吗？有什么用，我直接写void不好吗？</p>
<p>实际上void_t是为TMP服务的，并不是让你当作返回值&#x2F;类型声明的。我们可以通过SFINE+void_t这种TMP的手法来实现看似不可能的元函数。你马上就会看到</p>
<p>至于你说为什么叫void_t而不是叫其他类型，那你去问问C++委员会吧，顺便告诉我，我也想知道。</p>
<pre><code class="C++">  // __void_t (std::void_t for C++11)
  template&lt;typename...&gt; using __void_t = void;
</code></pre>
<h2 id="is-referenceable"><a href="#is-referenceable" class="headerlink" title="__is_referenceable"></a>__is_referenceable</h2><p>传入一个类型，返回其是不是可引用的，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>需要注意：一个类型T，如果已经是一个引用，无论是左值还是右值，均不可再添加&amp;，就是说没有<code>(int &amp;) &amp;</code>这样的语法，即引用的引用。但是在模板中，有引用的折叠，别把这件事情忘了。</p>
<p>拿什么是不可引用的呢？</p>
<ul>
<li>void</li>
<li>例如<code>int () const</code>这样的函数</li>
</ul>
<pre><code class="C++">  // Utility to detect referenceable types ([defns.referenceable]).

  template&lt;typename _Tp, typename = void&gt; //第二个类型参数用于辅助，不需要有名字。
    struct __is_referenceable
    : public false_type
    &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct __is_referenceable&lt;_Tp, __void_t&lt;_Tp&amp;&gt;&gt; //如果是一个不可引用的类型，匹配这个特例化失败，转而匹配主模板
    : public true_type
    &#123; &#125;;
</code></pre>
<h2 id="一些特殊的类型"><a href="#一些特殊的类型" class="headerlink" title="一些特殊的类型"></a>一些特殊的类型</h2><p>C++中有一些类型，具有独特的语义。例如 无其他动作的构造。内存布局方式是标准的。无其他动作的拷贝。一个抽象基类，一个被final修饰的类,等等deng’den。想对这些类型实现type_traits不是不行，但是编译器为我们内置这样的功能可能会更好，编译速度也会更加快速。</p>
<h3 id="trivial"><a href="#trivial" class="headerlink" title="trivial"></a>trivial</h3><p>一个trivial需要具有一下的性质</p>
<ul>
<li>有默认构造函数，编译器生成的，或者是显示的&#x3D;default，只能是这两种情况。</li>
<li>内存空间是连续的</li>
<li>不能包含虚函数和虚基类。</li>
<li>成员可以具有不同的访问权限</li>
<li>拥有平凡的拷贝构造函数和移动构造函数。默认的意思同上，也可以使用&#x3D;default。</li>
<li>拥有平凡的拷贝赋值运算符和移动赋值运算符。</li>
</ul>
<h3 id="stand-layout"><a href="#stand-layout" class="headerlink" title="stand_layout"></a>stand_layout</h3><p>一个stand_layout的对象，需要满足以下几种性质</p>
<ul>
<li>所有非静态成员拥有相同的访问级别</li>
<li>类中第一个非静态类型与基类不是同一个类型</li>
<li>所有非静态数据成员都符合标准布局的要求</li>
<li>没有虚类和虚基类</li>
<li>继承时需要满足以下两个情况之一<ol>
<li>派生类中有非静态类，那么这个派生类只能有且只有一个仅包含了静态成员的基类。</li>
<li>基类有非静态成员，那么派生类中不允许有非静态成员。</li>
</ol>
</li>
</ul>
<p>ps：这里涉及到C++对象模型，感兴趣的可以自行学习。</p>
<h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>pod类型需要满足两个要求</p>
<ul>
<li>是一个人trivial类型</li>
<li>是一个stand_layout类型</li>
</ul>
<p>pod类型的一些优势&#x2F;特点</p>
<ul>
<li>POD类型兼容C内存布局，C++可以直接使用C库函数操作POD数据类型，POD类型在C和C++间的操作总是安全的</li>
<li>POD类型可以直接使用字节赋值，使用C语言库函数进行二进制形式的数据交换，包括但不限于如下操作<code>memmove</code>,<code>memcpy</code>等</li>
<li>静态初始化在很多时候可以提高程序性能，而POD类型的静态初始化非常简单（放入目标文件的<code>.bss</code>段，在初始化时直接赋0）</li>
<li>虽然与C完全兼容，但是仍然可以有成员函数</li>
<li>有更长的生命周期（从资源获取到资源释放），非POD类型的生命周期从构造函数结束到析构函数结束</li>
<li>POD类型对象的前部没有填充字节，因此对象指针等于对象第一个成员的指针</li>
</ul>
<p>ps：还是涉及到C++对象模型，有点头秃，大伙看看就好，毕竟术业有专攻。编写应用层C++&#x2F;非底层库看看就好。</p>
<blockquote>
<p>STL的一些算法为了优化性能就会使用is_pod+标签分派的手法来优化性能。在一些很老的标准库中，你会看见对is_pod的手动实现</p>
</blockquote>
<h3 id="literal-type"><a href="#literal-type" class="headerlink" title="literal_type"></a>literal_type</h3><p>简单的说，就可以在用于编译期运算的对象。注意其和字面量的区别。</p>
<h2 id="还有一些编译器为我们内置的type-traits"><a href="#还有一些编译器为我们内置的type-traits" class="headerlink" title="还有一些编译器为我们内置的type_traits"></a>还有一些编译器为我们内置的type_traits</h2><p>这些type_traits的共呢个正如他们的名字所言，你唯一搞不懂的，应当是什么是POD类型？什么又是trivially_copyable性质？</p>
<pre><code class="C++"> /// is_trivial
//普通类型是其存储是连续的普通可复制的，并且仅支持静态默认初始化，无论是否为 cv 限定。它包括标量类型，平凡类和任何此类类型的数组。其实现也是编译器内置的。
  template&lt;typename _Tp&gt;
    struct is_trivial 
    : public integral_constant&lt;bool, __is_trivial(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;), //这里的静态断言，我们在前面说过了，不再解释，下同。
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  // is_trivially_copyable
  template&lt;typename _Tp&gt;
    struct is_trivially_copyable 	//是否具有平凡的拷贝
    : public integral_constant&lt;bool, __is_trivially_copyable(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_standard_layout
  template&lt;typename _Tp&gt;
    struct is_standard_layout	//是否是一个标准布局
    : public integral_constant&lt;bool, __is_standard_layout(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_pod (deprecated in C++20) C++20中已经废弃
  // Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.
  template&lt;typename _Tp&gt;	
    struct
    _GLIBCXX20_DEPRECATED(&quot;use is_standard_layout &amp;&amp; is_trivial instead&quot;)
    is_pod
    : public integral_constant&lt;bool, __is_pod(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_literal_type
  //17开始 20弃用
  template&lt;typename _Tp&gt;
    struct
    _GLIBCXX17_DEPRECATED
    is_literal_type 		//是否是一个字面类型
    : public integral_constant&lt;bool, __is_literal_type(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_empty
  template&lt;typename _Tp&gt;
    struct is_empty			//是否是一个空类型，即类中为空实现
    : public integral_constant&lt;bool, __is_empty(_Tp)&gt;
    &#123; &#125;;

  /// is_polymorphic
  template&lt;typename _Tp&gt;
    struct is_polymorphic		// 是否是一个多态类
    : public integral_constant&lt;bool, __is_polymorphic(_Tp)&gt;
    &#123; &#125;;

#if __cplusplus &gt;= 201402L
#define __cpp_lib_is_final 201402L
  /// is_final
  template&lt;typename _Tp&gt;
    struct is_final		
    : public integral_constant&lt;bool, __is_final(_Tp)&gt;
    &#123; &#125;;
#endif

  /// is_abstract
  template&lt;typename _Tp&gt;
    struct is_abstract
    : public integral_constant&lt;bool, __is_abstract(_Tp)&gt;
    &#123; &#125;;
</code></pre>
<h2 id="is-signed"><a href="#is-signed" class="headerlink" title="is_signed"></a>is_signed</h2><pre><code class="C++">template&lt;typename _Tp,
  bool = is_arithmetic&lt;_Tp&gt;::value&gt; //默认参数是一个bool值,来判断书不是算数类型
  struct __is_signed_helper
  : public false_type &#123; &#125;;

template&lt;typename _Tp&gt;
  struct __is_signed_helper&lt;_Tp, true&gt;	//蕴含着是一个符号类型应当先是算数类型
  : public integral_constant&lt;bool, _Tp(-1) &lt; _Tp(0)&gt;	//如果是一个有符号类型，那么_Tp(-1) &lt; _Tp(0)得到的结果将会是false，是一个无符号类型，-1，会下溢结果为true。
  &#123; &#125;;

/// is_signed
template&lt;typename _Tp&gt;
  struct is_signed
  : public __is_signed_helper&lt;_Tp&gt;::type
  &#123; &#125;
</code></pre>
<h2 id="is-unsigned"><a href="#is-unsigned" class="headerlink" title="is_unsigned"></a>is_unsigned</h2><pre><code class="C++">  /// is_unsigned
  template&lt;typename _Tp&gt;
    struct is_unsigned
    : public __and_&lt;is_arithmetic&lt;_Tp&gt;/*也可以不加这个元函数，is_singed中有*/, __not_&lt;is_signed&lt;_Tp&gt;&gt;&gt; //算数类型的同时对is_singed取反
    &#123; &#125;;
</code></pre>
<h2 id="decltype手法"><a href="#decltype手法" class="headerlink" title="decltype手法"></a>decltype手法</h2><p>C++11中新增了decltype关键字，目的就是解决TMP中的一些问题。decltype会对表达式求值，只会根据表达式来推导类型，这点牢记。我不打算说明decltype的所有细节，你可以查阅资料来了解相关知识。decltype为TMP的实现提供了更多的可能性。decltype+SFINAE也是TMP中的一种很巧妙的手法。</p>
<h2 id="declval"><a href="#declval" class="headerlink" title="declval"></a>declval</h2><p>declval是一个函数，只有声明，没有实现，目的很简单，服务于TMP。因此，关于declval的所有操作，均在编译时期发生。</p>
<pre><code class="C++">  /**
   *  @brief  Utility to simplify expressions used in unevaluated operands
   *  @ingroup utilities
   */
//提供了两个的重载版本
  template&lt;typename _Tp, typename _Up = _Tp&amp;&amp;&gt;
    _Up
    __declval(int);

  template&lt;typename _Tp&gt;
    _Tp
    __declval(long);

  template&lt;typename _Tp&gt;
    auto declval() noexcept -&gt; decltype(__declval&lt;_Tp&gt;(0)); //尾置返回类型
</code></pre>
<h2 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h2><p>如果T是数组类型，则提供成员常量等于数组第nth维的元素数。或者T是其他类型，或者数组的第0维数为无界的并且nth&#x3D;0，则值为0。</p>
<p>你可能会疑惑为什么第0维是无界的时候值为0，第1，2，…维不行吗？别忘了C的语法——要确定数组的列数。</p>
<pre><code class="C++">  /// extent
  template&lt;typename, unsigned _Uint&gt;	
    struct extent
    : public integral_constant&lt;std::size_t, 0&gt; &#123; &#125;;	  //T不是数组类型，值为0

  template&lt;typename _Tp, unsigned _Uint, std::size_t _Size&gt;
    struct extent&lt;_Tp[_Size], _Uint&gt;
    : public integral_constant&lt;std::size_t,
                   _Uint == 0 ? _Size : extent&lt;_Tp,   //三目运算符
                               _Uint - 1&gt;::value&gt;	//递归条件_Uint == 0，在_Uint==0的时候，编译器推断的size正好是nth的长度，实现很巧妙，多看几眼慢慢搞清顺序。
    &#123; &#125;;

  template&lt;typename _Tp, unsigned _Uint&gt;
    struct extent&lt;_Tp[], _Uint&gt;				//如果是一个无界数组
    : public integral_constant&lt;std::size_t,
                   _Uint == 0 ? 0 : extent&lt;_Tp,	//如果是第0维，那么值就是0，否则就递归的继承，回到了上述的情况
                               _Uint - 1&gt;::value&gt; 
    &#123; &#125;;
</code></pre>
<p>用法：</p>
<pre><code class="C++">int main() &#123;
    int arr [][3][2] = &#123;&#125;;
    cout &lt;&lt; std::extent&lt;int[][3][5],0&gt;::value &lt;&lt; endl;  //0
    cout &lt;&lt; std::extent&lt;int[][3][5],1&gt;::value &lt;&lt; endl;  //3
    cout &lt;&lt; std::extent&lt;int[][3][5],2&gt;::value &lt;&lt; endl;  //5
    int arr1[1][2];
    cout &lt;&lt; std::extent&lt;decltype(arr1),0&gt;::value &lt;&lt; endl;   //1
    cout &lt;&lt; std::extent&lt;decltype(arr1),1&gt;::value &lt;&lt; endl;   //2
    
    //decltype(arr)的结果为什么超出我么的预期？gcc出bug了吗？
    cout &lt;&lt; std::extent&lt;decltype(arr),0&gt;::value &lt;&lt; endl;    //0
    cout &lt;&lt; std::extent&lt;decltype(arr),1&gt;::value &lt;&lt; endl;    //0
    cout &lt;&lt; std::extent&lt;decltype(arr),2&gt;::value &lt;&lt; endl;    //0
    return 0;
&#125;
</code></pre>
<p>其实decltype的推导arr的结果为<code>[0][3][2]</code>。是不同于直接传递<code>int[][3][5]</code>的。decltype的推断出一个有界数组，而直接传递arr，arr被当作一个无界数组。</p>
<h2 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h2><p>传入一个类型，返回其数组的维数。</p>
<p>同样是使用递归+继承的方式来实现。</p>
<pre><code class="C++">  /// rank
  template&lt;typename&gt;
    struct rank
    : public integral_constant&lt;std::size_t, 0&gt; &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct rank&lt;_Tp[_Size]&gt;
    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct rank&lt;_Tp[]&gt;
    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; &#123; &#125;;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章更加深入的了解了type_traits的更加高阶的实现技巧。但这还只是TMP的冰山一角而已。无论难度如何，总之，还能够接受。介绍了一些维TMP服务的基本元函数，例如declval等，虽然定义很短，但是很复杂也巧妙。</p>
<p>下一章，会更加深入的分析type_traits,前三章分析的type_traits的耦合度很低，很多的tyep_traits都相对独立。而后些章节。那些type_traits都需要很多的元函数做支撑。并且还会有更加复杂的TMP实现手法等着你。</p>
<p>至此，type_traits的源码差不多分析的近900行，还有剩下的2000多行等待我们探索。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ffa2c4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #00a596">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/28/type-traits源码分析-三/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/type-traits源码分析-二-/">
        <h2 class="post-title">Type-Traits源码分析(二)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>在一中，介绍了一些type_trait的基本设施, 很轻松，唯一比较复杂的就是is_pointer。在二中，将继续探索tyep_traits中的基本设施——这些设施在TMP中，撰写库的时候经常用到。这篇文章不会涉及到一些高级的技巧。这些技巧放在后面分析。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="元函数的实现技巧"><a href="#元函数的实现技巧" class="headerlink" title="元函数的实现技巧"></a>元函数的实现技巧</h2><p>在标准库中，或者自己想要撰写元函数，可以使用这样一种手法。例如想实现一个名为XXX的元函数。</p>
<p>可以另外定义一个元函数叫做XXX_helper&#x2F;XXX_impl(随你的喜好，叫什么猫猫狗狗也没有问题)来解决核心的部分。</p>
<p>而XXX这个元函数，做一些辅助性的操作，例如移除const，volatile。让后让XXX继承XXX_helper来实现功能。</p>
<h2 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h2><p>传入一个类型，返回其是不是void，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>真正的实现是<code>__is_void_helper</code>，而<code>is_void</code>做一些辅助性的操作。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_void_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_void_helper&lt;void&gt;
    : public true_type &#123; &#125;;

  /// is_void
  template&lt;typename _Tp&gt;
    struct is_void
    : public __is_void_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //移除const volatile
    &#123; &#125;;
</code></pre>
<h2 id="is-integral"><a href="#is-integral" class="headerlink" title="is_integral"></a>is_integral</h2><p>传入一个类型，返回其是不是integral，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p><code>integral</code>可以理解为整形，包括无符号类型。或者随你怎么理解都行，只要你看到了实现，你就知道了他是什么意思。</p>
<p>同样的<code>__is_integral_helper</code>做的具体的操作，有很多个特例化模板。你会说编写一个宏更方便不是吗？也许是的！</p>
<pre><code class="C++"> template&lt;typename&gt;
    struct __is_integral_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;bool&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;char&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;signed char&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned char&gt;
    : public true_type &#123; &#125;;

  // We want is_integral&lt;wchar_t&gt; to be true (and make_signed/unsigned to work)
  // even when libc doesn&#39;t provide working &lt;wchar.h&gt; and related functions,
  // so check __WCHAR_TYPE__ instead of _GLIBCXX_USE_WCHAR_T.
#ifdef __WCHAR_TYPE__
  template&lt;&gt;
    struct __is_integral_helper&lt;wchar_t&gt;
    : public true_type &#123; &#125;;
#endif

#ifdef _GLIBCXX_USE_CHAR8_T
  template&lt;&gt;
    struct __is_integral_helper&lt;char8_t&gt;
    : public true_type &#123; &#125;;
#endif

  template&lt;&gt;
    struct __is_integral_helper&lt;char16_t&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;char32_t&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;short&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned short&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;int&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned int&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;long long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned long long&gt;
    : public true_type &#123; &#125;;

  // Conditionalizing on __STRICT_ANSI__ here will break any port that
  // uses one of these types for size_t.
#if defined(__GLIBCXX_TYPE_INT_N_0) //这些条件编译你大可忽略掉，有兴趣也可以看看。
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_0&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_0&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_1&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_1&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_2&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_2&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_3&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_3&gt;
    : public true_type &#123; &#125;;
#endif

  /// is_integral
  template&lt;typename _Tp&gt;
    struct is_integral
    : public __is_integral_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //与is_void使用相同的手法
    &#123; &#125;;
</code></pre>
<h2 id="is-floating-point"><a href="#is-floating-point" class="headerlink" title="is_floating_point"></a>is_floating_point</h2><p>传入一个类型，返回其是不是浮点类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>如果你会了is_integral,那么is_floating_point也无需多言了。</p>
<pre><code class="C++"> template&lt;typename&gt;
    struct __is_floating_point_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;float&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;double&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;long double&gt;
    : public true_type &#123; &#125;;

#if !defined(__STRICT_ANSI__) &amp;&amp; defined(_GLIBCXX_USE_FLOAT128) //同样是条件编译，可忽略
  template&lt;&gt;
    struct __is_floating_point_helper&lt;__float128&gt;
    : public true_type &#123; &#125;;
#endif

  /// is_floating_point
  template&lt;typename _Tp&gt;
    struct is_floating_point
    : public __is_floating_point_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-array"><a href="#is-array" class="headerlink" title="is_array"></a>is_array</h2><p>传入一个类型，返回其是不是数组(有界的&#x2F;无界的)，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>老方法了，主模板+偏特化。值得注意的是，T*不同于T[]和T[N]。例如</p>
<pre><code class="C++">int main() &#123;
    int nums[10] = &#123;1,2,3,4&#125;;
    cout &lt;&lt; std::is_array&lt;decltype(nums)&gt;::value &lt;&lt; endl; //true
    int * const p = nums;
    cout &lt;&lt; std::is_array&lt;decltype(p)&gt;::value &lt;&lt; endl;	//false
    return 0;
&#125;
</code></pre>
<pre><code class="C++">    /// is_array
    // 区别T *, T[], T[N]的不同
  template&lt;typename&gt;
    struct is_array
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct is_array&lt;_Tp[_Size]&gt;	//有界数组
    : public true_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_array&lt;_Tp[]&gt; //无界数组
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-pointer"><a href="#is-pointer" class="headerlink" title="is_pointer"></a>is_pointer</h2><p>传入一个类型，返回其是不是指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>注意<code>const *</code>,<code>* const</code>的不同，前者不是指针具有常量性质，后者才是。</p>
<pre><code class="C++">template&lt;typename&gt;
    struct __is_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct __is_pointer_helper&lt;_Tp*&gt;
    : public true_type &#123; &#125;;

  /// is_pointer
  template&lt;typename _Tp&gt;
    struct is_pointer
    : public __is_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //remove_cv
    &#123; &#125;;
</code></pre>
<h2 id="is-complete-or-unbounded"><a href="#is-complete-or-unbounded" class="headerlink" title="__is_complete_or_unbounded"></a>__is_complete_or_unbounded</h2><p>传入一个类型，返回其是不是完整的或者无界的，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>因为这不是一个最终对外提供的接口。所以可以使用constexpr函数的方式来实现。</p>
<p>首先我们应当知道的一个前置知识：如果是一个类型是非完整类型，或者无界类型，sizeof 会无法应用。例如</p>
<pre><code class="C++">template&lt;typename T&gt;
struct size_is &#123;
    static constexpr size_t value = sizeof(T);
&#125;;
class A; //A仅有声明，是一个非完整类型
int main() &#123;
    cout &lt;&lt; size_is&lt;int&gt;::value &lt;&lt; endl; 	//ok
    cout &lt;&lt; size_is&lt;int[]&gt;::value &lt;&lt; endl;	//error
    cout &lt;&lt; size_is&lt;A&gt;::value &lt;&lt; endl;		//error
    return 0;
&#125;
</code></pre>
<p>一个无界&#x2F;不完整类型还包括</p>
<ul>
<li>引用</li>
<li>函数</li>
<li>void</li>
<li>无界数组</li>
</ul>
<pre><code class="C++">// Helper functions that return false_type for incomplete classes,
  // incomplete unions and arrays of known bound from those.
//为不完整的类、不完整的联合和已知边界数组返回 false_type 的辅助函数。
template &lt;typename _Tp, size_t = sizeof(_Tp)&gt; //如果是非完整类型，或者无界类型，sizeof 会无法应用
    constexpr true_type __is_complete_or_unbounded(__type_identity&lt;_Tp&gt;) //由于我们只关心返回类型，所以不用返回值
                    //或者说返回类型种隐含了返回值true_type::value==true;
    &#123; return &#123;&#125;; &#125;

  template &lt;typename _TypeIdentity,	
      typename _NestedType = typename _TypeIdentity::type&gt;	//上面的模板匹配失败，转而匹配这个模板
    constexpr typename __or_&lt; //是其中一个
      is_reference&lt;_NestedType&gt;,
      is_function&lt;_NestedType&gt;,
      is_void&lt;_NestedType&gt;,
      __is_array_unknown_bounds&lt;_NestedType&gt;	//这个tyep_traits还没有分析，仅仅知道如何用也不妨
    &gt;::type __is_complete_or_unbounded(_TypeIdentity) //如果__or_种的元函数的返回类型皆为false_type，也就是说参数类型不是上面那些类型其中之一，最终结果就是false_type
    &#123; return &#123;&#125;; &#125;
</code></pre>
<h2 id="is-enum-x2F-class-x2F-union"><a href="#is-enum-x2F-class-x2F-union" class="headerlink" title="is_enum&#x2F;class&#x2F;union"></a>is_enum&#x2F;class&#x2F;union</h2><p>传入一个类型，返回其是不是enum&#x2F;class&#x2F;union，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>编译器为我们内置了这三种type_traits。你只需要知道这是内置的就好。</p>
<pre><code class="C++">  /// is_enum
  template&lt;typename _Tp&gt;
    struct is_enum
    : public integral_constant&lt;bool, __is_enum(_Tp)&gt; //无法查看__is_enum的具体实现，下同
    &#123; &#125;;

  /// is_union
  template&lt;typename _Tp&gt;
    struct is_union
    : public integral_constant&lt;bool, __is_union(_Tp)&gt;
    &#123; &#125;;

  /// is_class
  template&lt;typename _Tp&gt;
    struct is_class
    : public integral_constant&lt;bool, __is_class(_Tp)&gt;
    &#123; &#125;;
</code></pre>
<h2 id="is-null-pointer"><a href="#is-null-pointer" class="headerlink" title="is_null_pointer"></a>is_null_pointer</h2><p>传入一个类型，返回其是不是空指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>空指针该如何做特例化。C++11有nullptr,是nullptr_t类型(nullptr_t是decltype(nullptr)的一个别名), 由于任何型别的指针类型都可以转换为nullptr_t，所以，对nullptr_t类型做特例化即可。</p>
<p>关于以后的type_traits，如果还是老生常谈的设计手法。就不会再说了，就像这个type_traits一样。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_null_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_null_pointer_helper&lt;std::nullptr_t&gt;
    : public true_type &#123; &#125;;

  /// is_null_pointer (LWG 2247).
  template&lt;typename _Tp&gt;
    struct is_null_pointer
    : public __is_null_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<p>GCC还提供了一个不推荐使用的拓展。</p>
<pre><code class="C++">  /// __is_nullptr_t (deprecated extension).
  template&lt;typename _Tp&gt;
    struct __is_nullptr_t
    : public is_null_pointer&lt;_Tp&gt;
    &#123; &#125; _GLIBCXX_DEPRECATED_SUGGEST(&quot;std::is_null_pointer&quot;); //这些宏实在是不想深究到底，令人厌烦的宏！
</code></pre>
<h2 id="is-arithmetic"><a href="#is-arithmetic" class="headerlink" title="is_arithmetic"></a>is_arithmetic</h2><p>传入一个类型，返回其是不是可运算的类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>整形类型和浮点类型被视作是可运算的类型，无论是否具有const性质。</p>
<blockquote>
<p>你可能会想到，如果自定义类型也支持+ - * &#x2F;等运算，是不是这个type_traits就不好使了呢？难道有bug吗？</p>
<p>你可以将这个type_traits看作一个规定。并且，不要为任何自定义类型做任何的type_traits的特例化。永远不要，因为这是一个未定义的行为。有关更多， 请看<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/is_arithmetic">std::is_arithmetic - cppreference.com</a></p>
</blockquote>
<pre><code class="C++">  /// is_arithmetic
  template&lt;typename _Tp&gt;
    struct is_arithmetic
    : public __or_&lt;is_integral&lt;_Tp&gt;, is_floating_point&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-fundamental"><a href="#is-fundamental" class="headerlink" title="is_fundamental"></a>is_fundamental</h2><p>传入一个类型，返回其是不是基本类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>可运算类型，void, nullptr_t被视作为基本类型，理由和注意事项同上。</p>
<pre><code class="C++">  /// is_fundamental
  template&lt;typename _Tp&gt;
    struct is_fundamental
    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_void&lt;_Tp&gt;,
           is_null_pointer&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-compound"><a href="#is-compound" class="headerlink" title="is_compound"></a>is_compound</h2><p>传入一个类型，返回其是不是复合类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>只需要对is_fundamental的结果取反，也就是应用__not_即可</p>
<pre><code class="C++">  /// is_compound
  template&lt;typename _Tp&gt;
    struct is_compound
    : public __not_&lt;is_fundamental&lt;_Tp&gt;&gt;::type &#123; &#125;;
</code></pre>
<h2 id="is-object"><a href="#is-object" class="headerlink" title="is_object"></a>is_object</h2><p>传入一个类型，返回其是不是一个对象，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>这里的object指的是广义上的对象。例如int,double类型的实例皆算对象。例如但函数，引用，void类型不算在内。</p>
<pre><code class="C++">struct A &#123;
    int m_data = 0;
&#125;;
int main() &#123;
    cout &lt;&lt; std::is_object&lt;int&gt;::value &lt;&lt; endl;			//true
    cout &lt;&lt; std::is_object&lt;double&gt;::value &lt;&lt; endl;		//true
    cout &lt;&lt; std::is_object&lt;int&amp;&gt;::value &lt;&lt; endl; 		//false
    cout &lt;&lt; std::is_object&lt;A&gt;::value &lt;&lt; endl;			//true
    cout &lt;&lt; std::is_object&lt;void(int,int)&gt;::value &lt;&lt; endl;//false
    return 0;
&#125;
</code></pre>
<p>实现</p>
<pre><code class="C++">/// is_object
template&lt;typename _Tp&gt;
  struct is_object
  : public __not_&lt;__or_&lt;is_function&lt;_Tp&gt;, is_reference&lt;_Tp&gt;,
                        is_void&lt;_Tp&gt;&gt;&gt;::type
  &#123; &#125;;
</code></pre>
<h2 id="is-scalar"><a href="#is-scalar" class="headerlink" title="is_scalar"></a>is_scalar</h2><p>传入一个类型，返回其是不是一个标量类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<blockquote>
<p>标量类型包括算数类型，枚举类型，指针，成员指针，空指针.将在那些元函数应用于__or_即可</p>
</blockquote>
<pre><code class="C++">  /// is_scalar
  template&lt;typename _Tp&gt;
    struct is_scalar
    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_enum&lt;_Tp&gt;, is_pointer&lt;_Tp&gt;, 
                   is_member_pointer&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-compound-1"><a href="#is-compound-1" class="headerlink" title="is_compound"></a>is_compound</h2><p>传入一个类型，返回其是不是一个复合类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<pre><code class="C++">  /// is_compound
  template&lt;typename _Tp&gt;
    struct is_compound // 对is_fundamental取否定即可
    : public __not_&lt;is_fundamental&lt;_Tp&gt;&gt;::type &#123; &#125;; 
</code></pre>
<h2 id="is-same"><a href="#is-same" class="headerlink" title="is_same"></a>is_same</h2><p>传入两个类型，返回其是不是相同类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>对&lt;_Tp, _Tp&gt;做特例化即可。</p>
<pre><code class="C++">  /// is_same
 //下面省略了一些条件编译
  template&lt;typename _Tp, typename _Up&gt; //不同类型的时候
    struct is_same
    : public false_type
    &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_same&lt;_Tp, _Tp&gt; //相同类型的时候
    : public true_type
    &#123; &#125;;
</code></pre>
<h2 id="is-member-object-x2F-function-pointer"><a href="#is-member-object-x2F-function-pointer" class="headerlink" title="is_member_object&#x2F;function_pointer"></a>is_member_object&#x2F;function_pointer</h2><p>传入一个类型，返回其是不是指向类内非静态数据成员&#x2F;成员函数的指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>在文章的最后，我准备了一些更加酷的东西，当然，也更加的复杂。首先，我们应当了解一下基本的原理：</p>
<p>如果A是一个类，那么可以有这样的一种指针<code>type A::*</code> 指向A中类型为type的数据成员(非静态的，下文省略)。类似的，还有成员函数指针。例如</p>
<pre><code class="C++">struct A &#123;
    int a = 10;
    void inc_and_print() &#123;
        ++a;
        cout &lt;&lt; a &lt;&lt; endl;
    &#125;
&#125;;
int main() &#123;
    int A::* p = &amp;A::a;
    //使用
    A x;
    x.*p = 10; //固定的语法形式
    cout &lt;&lt; x.*p &lt;&lt; endl;   //10
    cout &lt;&lt; x.a &lt;&lt; endl;    //10

    using Fun = void (A::*)();
//    void(A::*fun)();
    Fun fun = &amp;A::inc_and_print;
    (x.*fun)(); //such as call A::inc_and_print //a is 11
    return 0;
&#125;
</code></pre>
<p>C++还有这种语法？你会疑问，这是肯定的！但这无关紧要，在什么情况下才能用上这样的语法？貌似真的没有，除了TMP。</p>
<p>你知道了解一点，如果T是一个类，则可以有<code>type T::*</code>这样的形式指向数据成员&#x2F;成员函数，不是类则没有。</p>
<p>并且还要说明的是，不要纠结在这些语法的琐碎上，<strong>Bjarne Stroustrup</strong>也不会对所有的C++语法细节和标准全部一清二楚。不要陷入语法细节的深渊——C++在承受着巨大的历史包袱的同时，还要添加现代的语法特性，想学完C++————下辈子说不定可以！</p>
<p>关于具体的实现，请看源代码，我会一点点说明。</p>
<pre><code class="C++">template&lt;typename&gt;
    struct __is_member_object_pointer_helper //主模板继承false_type
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; //注意这里没有逗号，模板匹配的时候会将一个类型拆分成两个了类型的组合，好复杂的语法，可恶
      //匹配到这个特例化模板可以是数据成员指针，也可以是成员函数指针。如果不是成员函数指针，就是数据成员指针了
    : public __not_&lt;is_function&lt;_Tp&gt;&gt;::type &#123; &#125;; 

  /// is_member_object_pointer
  template&lt;typename _Tp&gt;
    struct is_member_object_pointer 
    : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<p>太复杂了！你可能还是对上述代码中的哪个特例化有疑问，好吧！让我们一探究竟。我们对上述的代码改造一下。对于那个特例化，我们在其内部定义两个类型T1, T2为 _Tp, _Cp的别名，_Tp,_Cp到底被推断为什么类型。</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
namespace jan &#123;
    using std::__not_;
    using std::true_type;
      using std::false_type;
      using std::is_function;
     using std::__remove_cv_t;
    template&lt;typename&gt;
    struct __is_member_object_pointer_helper
    : public false_type &#123; &#125;;

     template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; 
    : public __not_&lt;is_function&lt;_Tp&gt;&gt;::type &#123; 
        using T1 = _Tp;	//这里是我们添加的
        using T2 = _Cp;
    &#125;;

  /// is_member_object_pointer
  template&lt;typename _Tp&gt;
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
&#125;

class A &#123; &#125;;
int main() &#123;
     jan::is_member_object_pointer&lt;int A::*&gt;::type t;
      return 0;
&#125;
</code></pre>
<p>编译器会为我们生成这样的代码。</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
namespace jan
&#123;
  using std::__not_;
  template&lt;typename _Pp&gt;
  
  using std::true_type;
  using std::false_type;
  using std::is_function;
  template&lt;typename _Tp&gt;
  
  using std::__remove_cv_t;
  template&lt;typename std::_Tp&gt;
  using std::__remove_cv_t = typename remove_cv&lt;_Tp&gt;::type;
  
  template&lt;typename type_parameter_0_0&gt;
  struct __is_member_object_pointer_helper : public std::false_type
  &#123;
  &#125;;
  /****************************************注意看这里******************************************/
  /* First instantiated from: insights.cpp:23 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template&lt;&gt;
  struct __is_member_object_pointer_helper&lt;int A::*&gt; : public std::integral_constant&lt;bool, true&gt;
  &#123;
    using T1 = int; //_Tp is int
    using T2 = A;   //_Cp is A
  &#125;;
  /******************************************************************************************/
  #endif
  template&lt;typename _Tp, typename _Cp&gt;
  struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; : public __not_&lt;is_function&lt;_Tp&gt; &gt;::type
  &#123;
    using T1 = _Tp;
    using T2 = _Cp;
  &#125;;
  
  template&lt;typename _Tp&gt; //在这个例子中， _Tp us int A::*
  struct is_member_object_pointer : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt; &gt;::type
  &#123;
  &#125;;
  
  /* First instantiated from: insights.cpp:30 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template&lt;&gt;
  struct is_member_object_pointer&lt;int A::*&gt; : public std::integral_constant&lt;bool, true&gt;
  &#123;
  &#125;;
  #endif 
&#125;
class A&#123; &#125;;
int main()
&#123;
    std::integral_constant&lt;bool, true&gt; t = std::integral_constant&lt;bool, true&gt;(); //这里无关紧要
     return 0;
&#125;
</code></pre>
<p>恍然大悟了吧！</p>
<p>类似的<code>is_member_function_pointer</code>有这样的实现。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_member_function_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_function_pointer_helper&lt;_Tp _Cp::*&gt;
//匹配到这个特例化模板可以是数据成员指针，也可以是成员函数指针。那就用is_function这个type_traits是不是一个函数即可
    : public is_function&lt;_Tp&gt;::type &#123; &#125;; 

  /// is_member_function_pointer
  template&lt;typename _Tp&gt;
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇大部分的源码分析还是轻松的，除了个别的刺头。</p>
<p>你听说过brainfuck这个语言吗？相比于brainfuck这个语言，C++才是真正的brainfunk! </p>
<p>我的🧠要爆炸了！！！</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ffa2c4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00a596">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #ff7d73">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/type-traits源码分析-二-/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/type-traits源码分析-一-/">
        <h2 class="post-title">Type_traits源码分析(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="type-traits概述"><a href="#type-traits概述" class="headerlink" title="type_traits概述"></a>type_traits概述</h1><p>tyep_traits是C++TMP中不可缺少的一部分，也是Modern C++不可缺少的一部分。任何一位C++程序员，如果想学习Modern C++，想学号Modern C++，肯定不能避免学习type_traits。</p>
<h2 id="什么是type-traits"><a href="#什么是type-traits" class="headerlink" title="什么是type_traits?"></a>什么是type_traits?</h2><p>type_traits，顾名思义，为类型萃取器&#x2F;类型特征。type_traits是一系列的元函数。在普通函数中，我们传入数据，返回数据。但是在元函数中，我们传入类型&#x2F;常量，返回类型&#x2F;常量。</p>
<p>C++ type_traits的实现,也就是元函数的一般形式, 使用结构体+模板(模式匹配+模板偏特化)的方式。</p>
<p>使用&lt;&gt;来传入类型(语法层面的), 使用::value&#x2F;::type来获得返回值&#x2F;返回类型(约定俗成的)。<br>例如<code>std::true_type::value == true</code>,<code>std::false_type::value == false</code>,<code>std::remove_const&lt;const int&gt;::value</code></p>
<p>所有的type_traits操作均发生在编译时期。</p>
<h2 id="type-trait能够干什么"><a href="#type-trait能够干什么" class="headerlink" title="type_trait能够干什么?"></a>type_trait能够干什么?</h2><p>type_traits不仅是标准库的重要组成部分，也是模板元编程中的基本技能。</p>
<p>标准库中的类型安全也多亏了type_traits，在各种C++库中也总是能看到type_traits的身影。</p>
<h1 id="type-traits中的约定"><a href="#type-traits中的约定" class="headerlink" title="type_traits中的约定"></a>type_traits中的约定</h1><p>type_traits发展了很长的时间，C++标准演化出来了一套规定<br>通用的规定</p>
<ul>
<li>使用::value来表示返回值(值元函数)</li>
<li>使用::type来表示返回类型(类型元函数)</li>
<li>每个元函数只能返回一个类型或者一个值</li>
<li>元函数可以同时是值元函数和类型元函数</li>
<li>元函数必须是一个模板类</li>
<li>对于一个type_traits,形如XXX_t的形式是一个类型应用XXX后的返回类型</li>
<li>对于一个type_traits,形如XXX_v的形式是一个类型应用XXX后的返回值(C++17)</li>
</ul>
<p>对于一元type_traits的规定</p>
<ul>
<li>接受一个类型参数 + 可选的辅助附加参数</li>
<li>必须可以默认构造</li>
<li>必须可以拷贝构造</li>
<li>必须公开且无歧义</li>
<li>所有的一元元函数都必须从std::integral_constant继承</li>
<li>基本的特征成员不应该被隐藏，而且明确可用</li>
</ul>
<p>对于二元元函数的规定</p>
<ul>
<li>接受有两个类型参数 + 可选的辅助附加参数</li>
<li>必须可以默认构造</li>
<li>必须可以拷贝构造</li>
<li>必须公开且无歧义</li>
<li>所有的一元元函数都必须从std::integral_constant的特例化继承</li>
<li>基本的特征成员不应该被隐藏，而且明确可用</li>
</ul>
<p>对于transformation-traits的规定</p>
<ul>
<li>接受一个类型参数 + 可选的辅助附加参数</li>
<li>定义一个public的名为type的嵌套类型</li>
<li>没有默认&#x2F;拷贝构造的要求(可以有，也可以没有)</li>
</ul>
<blockquote>
<p>你会发现标准库的有些地方没有遵守这个标准——那些代码是在这个标准没有成型之前，例如迭代器有关的类型萃取</p>
</blockquote>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>本篇文章使用gcc编译器，会提到17,20中的type_traits,请确保你所用的编译器支持17，20</p>
<p>对于有些条件编译，不列出源码并且不分析</p>
<p>我会将元函数和type_traits等价起来，如果文中说元函数，你可以联系上下文把其当作type_traits。反之亦然。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>标准库对于type_traits的实现，放在了type_traits中</p>
<h2 id="integral-constant"><a href="#integral-constant" class="headerlink" title="integral_constant"></a>integral_constant</h2><pre><code class="C++"> template&lt;typename _Tp, _Tp __v&gt;
    struct integral_constant
    &#123;
      static constexpr _Tp                  value = __v;
      typedef _Tp                           value_type;
      typedef integral_constant&lt;_Tp, __v&gt;   type;
      constexpr operator value_type() const noexcept &#123; return value; &#125;
    //有constexpr性质，可以编译时期求值
      constexpr value_type operator()() const noexcept &#123; return value; &#125;
    &#125;;
</code></pre>
<p>我们可以看见integral_constant定义的很简单，记得unix的哲学吗? less is more! 几乎所有的type_traits都会直接的或者间接的继承integral_constant</p>
<h2 id="true-type-false-type"><a href="#true-type-false-type" class="headerlink" title="true_type false_type"></a>true_type false_type</h2><p><code>true_type</code>,<code>false_type</code>仅仅是integral_constant的别名，定义如下</p>
<pre><code class="C++">  /// The type used as a compile-time boolean with true value.
  typedef integral_constant&lt;bool, true&gt;     true_type;

  /// The type used as a compile-time boolean with false value.
  typedef integral_constant&lt;bool, false&gt;    false_type;
</code></pre>
<p>很多的元函数都继承这两个类型，例如is_XXX等元函数。</p>
<h2 id="bool-constant"><a href="#bool-constant" class="headerlink" title="bool_constant"></a>bool_constant</h2><p>很好理解</p>
<pre><code class="C++">  /// The type used as a compile-time boolean with true value.
  typedef integral_constant&lt;bool, true&gt;     true_type;

  /// The type used as a compile-time boolean with false value.
  typedef integral_constant&lt;bool, false&gt;    false_type;
</code></pre>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>conditional接受三个参数，一个bool值，两个类型参数，作用相当于编译时期的if，可以这样描述</p>
<p><code>&lt;bool p, T1, T2&gt; p ? T1 : T2</code></p>
<pre><code class="C++">//前置声明
template&lt;bool, typename, typename&gt;
    struct conditional;  
...
/// Define a member typedef @c type to one of two argument types.
  template&lt;bool _Cond, typename _Iftrue, typename _Iffalse&gt; //主模板
    struct conditional
    &#123; typedef _Iftrue type; &#125;;

  // Partial specialization for false.
  template&lt;typename _Iftrue, typename _Iffalse&gt;		//特化模板
    struct conditional&lt;false, _Iftrue, _Iffalse&gt;
    &#123; typedef _Iffalse type; &#125;;
</code></pre>
<h2 id="type-identity"><a href="#type-identity" class="headerlink" title="__type_identity"></a>__type_identity</h2><p>关于个元函数，没有明确的规定，可以教type_is,或者其他的东西。每个标准库的实现都有所不同。作用就是给定一个T类型，返回一个T类型，用于被其他元函数继承。</p>
<pre><code class="C++">  template &lt;typename _Type&gt;
    struct __type_identity
    &#123; using type = _Type; &#125;;

  template&lt;typename _Tp&gt;
    using __type_identity_t = typename __type_identity&lt;_Tp&gt;::type;
</code></pre>
<h2 id="logic-traits"><a href="#logic-traits" class="headerlink" title="logic traits"></a>logic traits</h2><p>合取，析取，否定 traits。其中<code>conjunction</code>、<code>disjunction</code>、<code>negation</code>在定义了宏<code>__cpp_lib_logical_traits 201510</code>才启用</p>
<h3 id="or"><a href="#or" class="headerlink" title="__or_"></a><strong>__or_</strong></h3><p>类似or关键字，__or_元函数接受一个参数包，对这些类型的返回值求析取</p>
<pre><code class="C++">template&lt;typename...&gt;
    struct __or_; //主模板永远不能被匹配匹配到，所以不用定义

  template&lt;&gt;
    struct __or_&lt;&gt;	//如果没有类型，继承true_type
    : public false_type
    &#123; &#125;;

  template&lt;typename _B1&gt;
    struct __or_&lt;_B1&gt; //有一个类型继承哪个类型
    : public _B1
    &#123; &#125;;

  template&lt;typename _B1, typename _B2&gt; //如果时两个类型，递归的继承
    struct __or_&lt;_B1, _B2&gt;
    : public conditional&lt;_B1::value, _B1, _B2&gt;::type 
    //if _B1::value==true，那么不再判断，继承_B1即可，我们关心的是::value的这个返回值。
    //if _B1::value==false, 则继承_B2，此时_B2匹配到接受一个参数的特例化
    &#123; &#125;;

  template&lt;typename _B1, typename _B2, typename _B3, typename... _Bn&gt; //接受多个类型
    struct __or_&lt;_B1, _B2, _B3, _Bn...&gt;
    : public conditional&lt;_B1::value, _B1, __or_&lt;_B2, _B3, _Bn...&gt;&gt;::type
    //if _B1::value==true同理
    //if _B1::value==false, 递归的继承__or_&lt;_B2, _B3, _Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">//这种语法是C++17添加进来的，也很有效的简化了模板元编程的复杂性
template&lt;typename... _Bn&gt;
    inline constexpr bool __or_v = __or_&lt;_Bn...&gt;::value; //__or_v即是类型用用于__or_v后的返回
//__and_v同
</code></pre>
<h3 id="and"><a href="#and" class="headerlink" title="__and_"></a><strong>__and_</strong></h3><p>__and_的功能和实现与__or_的功能和实现大同小异</p>
<pre><code class="C++">  template&lt;typename...&gt;
    struct __and_;

  template&lt;&gt;
    struct __and_&lt;&gt;
    : public true_type //这里继承true_type
    &#123; &#125;;

  template&lt;typename _B1&gt;
    struct __and_&lt;_B1&gt;
    : public _B1
    &#123; &#125;;

  template&lt;typename _B1, typename _B2&gt;
    struct __and_&lt;_B1, _B2&gt;
    : public conditional&lt;_B1::value, _B2, _B1&gt;::type //这里的类型排列相较于__or_是反的
    &#123; &#125;;

  template&lt;typename _B1, typename _B2, typename _B3, typename... _Bn&gt;
    struct __and_&lt;_B1, _B2, _B3, _Bn...&gt;
    : public conditional&lt;_B1::value, __and_&lt;_B2, _B3, _Bn...&gt;, _B1&gt;::type //类型排列同上
    &#123; &#125;;
</code></pre>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    inline constexpr bool __and_v = __and_&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="not"><a href="#not" class="headerlink" title="__not_"></a><strong>__not_</strong></h3><p>__not_对给定类型的::value返回值取反,实现非常的简单</p>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    struct __not_
    : public __bool_constant&lt;!bool(_Pp::value)&gt; //这里有一个强转
    &#123; &#125;;
</code></pre>
<h3 id="conjunction"><a href="#conjunction" class="headerlink" title="conjunction"></a><strong>conjunction</strong></h3><p>合取，功能和__or_一样，通过继承其实现。</p>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    struct conjunction
    : __and_&lt;_Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">template&lt;typename... _Bn&gt;
    inline constexpr bool conjunction_v = conjunction&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="disjunction"><a href="#disjunction" class="headerlink" title="disjunction"></a><strong>disjunction</strong></h3><p>析取，同上</p>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    struct disjunction
    : __or_&lt;_Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">   template&lt;typename... _Bn&gt;
    inline constexpr bool disjunction_v = disjunction&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="negation"><a href="#negation" class="headerlink" title="negation"></a><strong>negation</strong></h3><p>否定，同上</p>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    struct negation
    : __not_&lt;_Pp&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    inline constexpr bool negation_v = negation&lt;_Pp&gt;::value;
</code></pre>
<h2 id="is-l-x2F-r-reference"><a href="#is-l-x2F-r-reference" class="headerlink" title="is_l&#x2F;r reference"></a>is_l&#x2F;r reference</h2><p>传入一个类型，返回其是不是一个左值&#x2F;右值引用类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type</p>
<pre><code class="C++">  /// is_lvalue_reference
  template&lt;typename&gt;		//主模板继承false_type
    struct is_lvalue_reference
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_lvalue_reference&lt;_Tp&amp;&gt; //对于左值引用的特例化，继承true_type
    : public true_type &#123; &#125;;

  /// is_rvalue_reference
  template&lt;typename&gt;			//同上
    struct is_rvalue_reference
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;		//同上
    struct is_rvalue_reference&lt;_Tp&amp;&amp;&gt;
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-reference"><a href="#is-reference" class="headerlink" title="is_reference"></a>is_reference</h2><p>传入一个类型，返回其是不是一个引用类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type</p>
<pre><code class="C++">template&lt;typename&gt;
struct is_reference; //声明

template&lt;typename _Tp&gt;
struct is_reference 		//左值引用/右值引用
    : public __or_&lt;is_lvalue_reference&lt;_Tp&gt;, 这里用__or_来实现
                   is_rvalue_reference&lt;_Tp&gt;&gt;::type
&#123; &#125;;
</code></pre>
<h2 id="is-const"><a href="#is-const" class="headerlink" title="is_const"></a>is_const</h2><p>传入一个类型，返回其是否具有const性质，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>通过普通的模板特化就可以实现</p>
<pre><code class="C++">  /// is_const
  template&lt;typename&gt;
    struct is_const
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_const&lt;_Tp const&gt; //对于const的特化
    : public true_type &#123; &#125;;
</code></pre>
<p>注意，对于&amp;&#x2F;&amp;&amp;is_const的返回类型是一个::false_type,就是所<code>std::is_const&lt;const int &amp;&gt;::value==false</code></p>
<p>类似的，还有<code>const int *</code>也是一样。因为这样的语义表示的指向的对象是常量性质的，而不是引用&#x2F;指针本身是常量性质的。</p>
<h2 id="is-volatile"><a href="#is-volatile" class="headerlink" title="is_volatile"></a>is_volatile</h2><p>传入一个类型，返回其是否具有volatile性质，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>实现方式和is_const大同小异。注意的事项也和is_const是一样的。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct is_volatile
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_volatile&lt;_Tp volatile&gt;
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-function"><a href="#is-function" class="headerlink" title="is_function"></a>is_function</h2><p>传入一个类型，返回其是不是一个函数类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>C++还有这样的功能！这是黑魔法吗？</p>
<p>这不是什么黑魔法，但确实够酷。在你惊叹他的时候，应当了解一下原理。</p>
<p>对于一个T类型，如果其是一个函数&#x2F;&amp;，对其添加const不会发成任何类型上的变化。例如</p>
<pre><code class="C++">void fun() &#123; &#125;
template &lt;typename T&gt;
struct add_const &#123;
  using type = const T;
&#125;;
int main() &#123;
    typename add_const&lt;decltype(fun)&gt;::type c;
  return 0;
&#125;
</code></pre>
<p>编译器会生成这样的代码</p>
<pre><code class="C++">void fun()
&#123;
&#125;

template&lt;typename T&gt;
struct add_const
&#123;
  using type = const T;
&#125;;

/* First instantiated from: insights.cpp:10 */
#ifdef INSIGHTS_USE_TEMPLATE
template&lt;&gt;
struct add_const&lt;void ()&gt; 
&#123;
  using type = void (); //类型上没有发生任何变化
&#125;;

#endif

int main()
&#123;
  void c();
  return 0;
&#125;
</code></pre>
<p>基于这个原理，我们可以轻松实现这个元函数。考虑到对于<code>const T &amp;</code>,<code>const T &amp;&amp;</code>(T不是一个函数类型) 应用is_const:value&#x3D;&#x3D;false &amp;&#x2F;&amp;&amp;继承false_type,主模板添加const性质之后判断得到的类型是不是具有const性质。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct is_function;
  /// is_function
  template&lt;typename _Tp&gt;
    struct is_function
    : public __bool_constant&lt;!is_const&lt;const _Tp&gt;::value&gt; &#123; &#125;;
    
//对引用考虑即可，对指针添加const变为*const
  template&lt;typename _Tp&gt;
    struct is_function&lt;_Tp&amp;&gt; 
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_function&lt;_Tp&amp;&amp;&gt;
    : public false_type &#123; &#125;;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ffa2c4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #ff7d73">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/type-traits源码分析-一-/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/22/unique-ptr源码解析/">
        <h2 class="post-title">Unique_ptr源码解析</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/22
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客是对unique_ptr源代码的分析，本文使用的编译器是MinGW</p>
<p>本篇文章不保证能够说明清楚unique_ptr实现的所有细节以及原因，但会尽可能的做到这样</p>
<p>需要读者有TMP的基础，例如熟悉std::enable_if, std::remove_referene等等的元函数</p>
<p>本篇文章不是一个unique_ptr的使用教程，但是会提及到一些使用中的细节</p>
<h2 id="术语约定"><a href="#术语约定" class="headerlink" title="术语约定"></a>术语约定</h2><ul>
<li>对内置指针有时候称其为raw-pointer&#x2F;裸指针</li>
<li>对于unique_ptr的指向堆区对象的指针，有时候称其为内部指针，有时候称其为指向堆区的指针，或者其他称呼。请联系上下文判别于内置指针的区别。</li>
<li>对于类型需要满足的条件，我们称其为约束条件</li>
</ul>
<h2 id="描述约定"><a href="#描述约定" class="headerlink" title="描述约定"></a>描述约定</h2><ul>
<li>对于大部分的篇幅，都会使用源代码+注释的方式来描述。如果一个问题使用注释描述篇幅过大，会单独拿出来说明</li>
<li>对于所有的源码注释，均保留</li>
</ul>
<h1 id="unique-ptr概述"><a href="#unique-ptr概述" class="headerlink" title="unique_ptr概述"></a>unique_ptr概述</h1><p>unique_ptr是比rew-pointer更为好的选择，标准库实现unique_ptr使接口尽可能的接近原生指针。不同的编译器对其实现有所不同。</p>
<p>gcc编译器对 unique_ptr的实现，大概分为以下几部分</p>
<ul>
<li>defaule_delete 定义的默认删除器，其中没有任何数据成员，是unique_ptr的默认删除器</li>
<li>__uniq_ptr_impl unique_ptr的核心部分</li>
<li>__uniq_ptr_data unique_ptr 和 __uniq_ptr_impl的中间层，unique_ptr内含一个__uniq_ptr_data</li>
<li>unique_ptr<T>     非数组版本，也是最常用的版本</li>
<li>unique_ptr&lt;T[]&gt;   数组版本，一般情况下有更好的替代(vector,array等) </li>
<li>std::make_unique，unique_ptr的配套函数，用于创建unique_ptr</li>
</ul>
<h1 id="需要了解的前置知识"><a href="#需要了解的前置知识" class="headerlink" title="需要了解的前置知识"></a>需要了解的前置知识</h1><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>C++支持OOP,这就涉及到的多态，本章的主题是指针，如果想放心的对于unique_ptr的使用就像使用内置指针一样(某些部分)，需要做类型安全的约束。包括但不限于</p>
<ul>
<li>基类和派生类的指针转换</li>
<li>数组和指针的转换</li>
<li>删除器的转换(读者看到删除器的实现就会知道了)</li>
</ul>
<p>为什么需要额外的类型安全，而不是靠编译器的检擦？</p>
<p>因为C++是一个弱类型语言，就是说在不同的类型之间可以实现隐式的类型转换——这种转换有时候很便利。但有更多的时候会产生副作用。例如精度丢失，数据溢出，甚至是内存泄漏和未定义行为。</p>
<h2 id="区别T-和T"><a href="#区别T-和T" class="headerlink" title="区别T[]和T*"></a>区别T[]和T*</h2><p>在C中<code>T[]</code>和<code>T*</code>可以看作是等价的类型，但是在C++的模板中，请将<code>T[]</code>和<code>T*</code>看作不同类型<br>例如std::is_array的实现</p>
<pre><code class="C++">template&lt;typename&gt;
    struct is_array
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct is_array&lt;_Tp[_Size]&gt;
    : public true_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_array&lt;_Tp[]&gt;
    : public true_type &#123; &#125;;
</code></pre>
<p>类似的如果想用unique_ptr存放数组<code>unique_ptr&lt;T[]&gt;</code>是正确的,而<code>unique_ptr&lt;T*&gt;</code>是不正确的</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>gcc对于unique_ptr的实现放在了unique_ptr.h中</p>
<p>本篇文章将按照源文件从上至下的顺序来剖析unique_ptr的实现</p>
<h2 id="unique-ptr定义的默认删除器"><a href="#unique-ptr定义的默认删除器" class="headerlink" title="unique_ptr定义的默认删除器"></a>unique_ptr定义的默认删除器</h2><pre><code class="c++">//基本的默认删除器实现
/// Primary template of default_delete, used by unique_ptr for single objects
  template &lt;typename _Tp&gt; struct default_delete &#123;
    /// Default constructor
    constexpr default_delete() noexcept = default;

    /** @brief Converting constructor.
     *
     * Allows conversion from a deleter for objects of another type, `_Up`,
     * only if `_Up*` is convertible to `_Tp*`.
     */
     // 正如注释所说，如果底层指针允许准换，则允许删除器转换
     // 空实现目的是做类型约束
     // 使用_Requires检查_Up * 能否转换为_TP *
     // 例如能用基类指针来析构一个派生类对像，却不能用派生类指针析构基类对象(先通过语法再说)
    template &lt;typename _Up, typename = _Require&lt;is_convertible&lt;_Up *, _Tp *&gt;&gt;&gt;
    default_delete(const default_delete&lt;_Up&gt; &amp;) noexcept &#123;&#125;

    //重载的调用运算符，接受一个_Tp指针，对其进行delete
    /// Calls `delete __ptr`
    void operator()(_Tp *__ptr) const &#123;
        //如果是一个非完整类型，例如只声明没有定义，会断言失败
      static_assert(!is_void&lt;_Tp&gt;::value,
                    &quot;can&#39;t delete pointer to incomplete type&quot;);
      static_assert(sizeof(_Tp) &gt; 0, &quot;can&#39;t delete pointer to incomplete type&quot;);
      delete __ptr;
    &#125;
  &#125;;
// _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 740 - omit specialization for array objects with a compile time length

  /// Specialization of default_delete for arrays, used by `unique_ptr&lt;T[]&gt;`
  template &lt;typename _Tp&gt; struct default_delete&lt;_Tp[]&gt; &#123;
  public:
    /// Default constructor
    constexpr default_delete() noexcept = default;

    /** @brief Converting constructor.
     *
     * Allows conversion from a deleter for arrays of another type, such as
     * a const-qualified version of `_Tp`.
     *
     * Conversions from types derived from `_Tp` are not allowed because
     * it is undefined to `delete[]` an array of derived types through a
     * pointer to the base type.
     */
     //允许删除其转换为另一种类型的数组，例如转换为_TP的const限定版本
     //但是不允许从子类转换为父类，不要用多态的方式处理数组，通过基类指针删除由派生类的数组是未定义的
     //所以禁止这种转换
     //具体的信息请参考《More Effective C++》条款5
    template &lt;typename _Up,
              typename = _Require&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;&gt;&gt;
    default_delete(const default_delete&lt;_Up[]&gt; &amp;) noexcept &#123;&#125;

    /// Calls `delete[] __ptr`
    template &lt;typename _Up&gt;
    typename enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type //注意这里的类型是数组的指针
                                    //虽然允许派生类指针隐式的转换为基类指针，为了检查这种转换，我们要写成这样
                                    //例如可以从non-const 转换为const，但不能从derived ** 转换为 base **
    operator()(_Up *__ptr) const &#123;
      static_assert(sizeof(_Tp) &gt; 0, &quot;can&#39;t delete pointer to incomplete type&quot;);
      //调用delete[]
      delete[] __ptr;
    &#125;
  &#125;;
</code></pre>
<p>__uniq_ptr_impl是实现部分，把这个类读懂，就读懂了unique_ptr的一半。unique_ptr的核心实现，全部在这个类中。没有复杂的逻辑，但是做到类型安全的实现方法，还是比较难的部分。__uniq_ptr_impl中没有复杂的关于类型安全的约束。比较复杂的约束在<code>uniqe_ptr&lt;T&gt;</code>和<code>unique_ptr&lt;T[]&gt;</code>中</p>
<pre><code class="C++">// Manages the pointer and deleter of a unique_ptr
//_TP是指向的类型， _DP是删除器的类型
  template &lt;typename _Tp, typename _Dp&gt; class __uniq_ptr_impl &#123;
    
    //这里做了一个type_traits
    //_Up实际上是_Tp, _Ep实际上是_Dp
    //指向堆区对象指针的的类型为_Up *
    template &lt;typename _Up, typename _Ep, typename = void&gt; struct _Ptr &#123;
      using type = _Up *;
    &#125;;

    //如果删除器中声明了删除的指针类型，有优先考虑这个指针类型
    //如果没有，类型替换失败，转而匹配上面的_Ptr
    //这样做的原因，想想一种情况
    //class B; class D : public B;
    //删除器中接受B*而实际存储的对象为D类型对象，在删除器中定义了pointer为B*
    template &lt;typename _Up, typename _Ep&gt;
    struct _Ptr&lt;_Up, _Ep,
                __void_t&lt;typename remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt; &#123;
      //这里假定了给定的_Ep有type类型，并且type下有pointer类型
      using type = typename remove_reference&lt;_Ep&gt;::type::pointer;
    &#125;;

  public:
    //这里做了一个约束条件
    //只是简单的别名定义，std::enable_if::没有取type
    //用到的地方再unique_ptr中
    //这个模板别名目的是为了约束_Dp也就是删除器，不能是一个指针，并且要求具有默认构造函数
    using _DeleterConstraint = enable_if&lt;
        __and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;

    //pointer为_Tp, _Ep经过 _Ptr类型萃取后的的别名
    //::type萃取出来一个指针类型
    //我们把pointer 这个类型直接当作raw-pointer类型
    using pointer = typename _Ptr&lt;_Tp, _Dp&gt;::type;

    //正如断言所言，unique_ptr的删除其必须是一个函数对象或者一个左值引用
    //如果是一个右值引用, !value == false,断言失败
    static_assert(!is_rvalue_reference&lt;_Dp&gt;::value,
                  &quot;unique_ptr&#39;s deleter type must be a function object type&quot;
                  &quot; or an lvalue reference type&quot;);

    __uniq_ptr_impl() = default; // =defalut是调用tuple的默认构造，tuple中的默认构造会为每个对象给定一个初值
                                 //例如int等类型会被初始化为0，而指针类型会被初始化为nullptr
    __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;

    //通过裸指针+删除器的方式构造
    //删除器使用万能引用+转发的形式传递
    template &lt;typename _Del&gt;
    __uniq_ptr_impl(pointer __p, _Del &amp;&amp;__d)
        : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123;&#125;

    //移动构造
    //注意如果类型没有移动构造函数情况就是拷贝构造
    __uniq_ptr_impl(__uniq_ptr_impl &amp;&amp;__u) noexcept
    //将u下的_M_t直接移动给自己
        : _M_t(std::move(__u._M_t)) &#123;
      __u._M_ptr() = nullptr; //滞空u下的_M_ptr
    &#125;

    //移动赋值运算符
    __uniq_ptr_impl &amp;operator=(__uniq_ptr_impl &amp;&amp;__u) noexcept &#123;
      reset(__u.release());
      _M_deleter() = std::forward&lt;_Dp&gt;(__u._M_deleter()); //将删除器转发过去 为什么用转发??
      return *this;
    &#125;

    //_M_ptr获得指向堆区内存的指针
    pointer &amp;_M_ptr() &#123; return std::get&lt;0&gt;(_M_t); &#125;
    //对于const的版本，我们按值返回即可，因为按值返回pointer的耗费较小
    pointer _M_ptr() const &#123; return std::get&lt;0&gt;(_M_t); &#125;
    //_M_ptr获得删除器
    _Dp &amp;_M_deleter() &#123; return std::get&lt;1&gt;(_M_t); &#125;
    //对于删除其，使用const &amp;方式返回，因为删除器是可能是函数对象——这种情值返回可能耗费较大
    //并且删除器有可能不支持拷贝操作
    const _Dp &amp;_M_deleter() const &#123; return std::get&lt;1&gt;(_M_t); &#125;

    //reset调用删除器析构raw-pointer指向的空间，并重新赋值为__p
    //假定不会抛出异常 使用noexcept
    void reset(pointer __p) noexcept &#123;
      const pointer __old_p = _M_ptr();
      _M_ptr() = __p;
      //不为nullptr, 进行析构操作
      if (__old_p)
        _M_deleter()(__old_p);
    &#125;

    //并不析构指针指向的内存，而是返回指针
    //并且将指向堆区部分的指针赋值为nullptr
    pointer release() noexcept &#123;
      pointer __p = _M_ptr();
      _M_ptr() = nullptr;
      return __p;
    &#125;

    //对于两个unique_ptr的swap，只需要交换其指针部分和删除器部分即可
    void swap(__uniq_ptr_impl &amp;__rhs) noexcept &#123;
      //这里的using std::swap请参考《Effective C++》条款25
      using std::swap;
      swap(this-&gt;_M_ptr(), __rhs._M_ptr());
      swap(this-&gt;_M_deleter(), __rhs._M_deleter());
    &#125;

  private:
    //使用一个tuple来存储具体指向对象的指针和删除器,便于实现，上面默认构造函数中有解释
    //并且，tuple具有空间压缩的功能(模板递归继承)
    //这种方式为什么能够压缩空间,是另一个问题了,参考《深度探索C++对象模型》
    tuple&lt;pointer, _Dp&gt; _M_t;
  &#125;;
</code></pre>
<h3 id="关于删除器的约束"><a href="#关于删除器的约束" class="headerlink" title="关于删除器的约束"></a>关于删除器的约束</h3><p>我们可以测试一下。正如我们所说在默认构造一个智能指针的情况下，不允许是一个函数指针，</p>
<p>这是由于内置指针在初始化的时候，也就是删除器初始化的时候，是一个nullptr。所以，在默认构造的情况下，不允许删除器是一个指针类型</p>
<p>如果把指针类型的删除器（函数指针）当作类型参数，编译器会说我找不到默认的构造函数，这是因为unique_ptr的默认构造函数进行了如此的约束，类型替换失败，于是找不到默认构造函数。如果析构器是函数对象或者lambda，就不会有这样的情况</p>
<pre><code class="C++">namespace jan &#123;
    template&lt;typename _Dp&gt;
    using _DeleterConstraint = enable_if&lt;
            __and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;
&#125;
void fun() &#123; &#125;
struct Foo &#123;
    Foo() = delete;
&#125;;
int main() &#123;
    typename jan::_DeleterConstraint&lt;decltype(fun)&gt;::type; //error
    typename jan::_DeleterConstraint&lt;int&gt;::type;    //ok
    typename jan::_DeleterConstraint&lt;Foo&gt;::type;    //error
    return 0;
&#125;
</code></pre>
<h3 id="关于-Ptr萃取指针的说明"><a href="#关于-Ptr萃取指针的说明" class="headerlink" title="关于_Ptr萃取指针的说明"></a>关于_Ptr萃取指针的说明</h3><p>从源代码中可以看出,如果删除器中定义了一个pointer型别，_Ptr会有限萃取出删除器::pointer作为unique_ptr的raw-pointer类型。我们想象这样一种情况。</p>
<pre><code class="C++">class A &#123; &#125;;
class B : public A &#123; &#125;;
class C : public B &#123; &#125;;

struct BDel &#123;
    using pointer = B*;
    void operator()(pointer p) &#123;
        delete p;
    &#125;
&#125;;
struct ADel&#123;
//    using pointer = B*;
    void operator()(A* p) &#123;
        //do something
        //但是和BDel做的事情不一样
        delete p;
    &#125;
&#125;;

int main() &#123;
    unique_ptr&lt;C,BDel&gt; p (new C, BDel&#123;&#125;);
    return 0;
&#125;
</code></pre>
<p>指定Bel为删除器类型，就表明，我们要处理的类型&#x2F;要删除的类型，是B类型或者B的派生类。记者OOP中的一条规则吗?面向接口编程，而不是面向实例编程。这这个情况中，尽管是个C对象，但是仍当作B类型处理。如果没有_Ptr萃取，unique_ptr::pointer就是C*，无法应用于B对象。</p>
<p>就是说尽管我们这样写<code>unique_ptr&lt;C,BDel&gt; p (new C, BDel&#123;&#125;);</code>,仍是可以应用于B对象，就像这样<code>unique_ptr&lt;C,BDel&gt; p (new B, BDel&#123;&#125;)</code></p>
<p>是有一些莫名其妙！！！</p>
<h2 id="uniq-ptr-data"><a href="#uniq-ptr-data" class="headerlink" title="__uniq_ptr_data"></a>__uniq_ptr_data</h2><p>在__uniq_ptr_impl和unique_ptr，又加上了一个中间层，目的是根据删除器是否有移动构造或者移动赋值属性，<br>部分特例化，来匹配不同的情况</p>
<pre><code class="C++">// Defines move construction + assignment as either defaulted or deleted.
  template &lt;typename _Tp, typename _Dp,
            bool = is_move_constructible&lt;_Dp&gt;::value,
            bool = is_move_assignable&lt;_Dp&gt;::value&gt;
  struct __uniq_ptr_data : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    //uisng 使用__uniq_ptr_impl的构造函数，下同
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = default;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = default;
  &#125;;

  template &lt;typename _Tp, typename _Dp&gt;
  struct __uniq_ptr_data&lt;_Tp, _Dp, true, false&gt; : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = default;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = delete;
  &#125;;

  template &lt;typename _Tp, typename _Dp&gt;
  struct __uniq_ptr_data&lt;_Tp, _Dp, false, true&gt; : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = delete;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = default;
  &#125;;

  template &lt;typename _Tp, typename _Dp&gt;
  struct __uniq_ptr_data&lt;_Tp, _Dp, false, false&gt; : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = delete;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = delete;
  &#125;;
</code></pre>
<h2 id="千呼万唤始出来，犹抱琵琶半遮面"><a href="#千呼万唤始出来，犹抱琵琶半遮面" class="headerlink" title="千呼万唤始出来，犹抱琵琶半遮面"></a>千呼万唤始出来，犹抱琵琶半遮面</h2><pre><code class="C++">/// 20.7.1.2 unique_ptr for single objects.
  template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt; class unique_ptr &#123;
    template &lt;typename _Up&gt;
    //如果不符合 __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint中的约束条件
    //enable_if&lt;false&gt;不会取到type这个类型，类型替换失败
    using _DeleterConstraint =
        typename __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;

    //内涵一个_uniq_ptr_data来实现unique_ptr
    __uniq_ptr_data&lt;_Tp, _Dp&gt; _M_t;

  public:
    //简单的型别别名
    using pointer = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;
    using element_type = _Tp;   //被指向元素类型
    using deleter_type = _Dp;   //删除器类型

  private:
    // helper template for detecting a safe conversion from another unique_ptr
    //帮助模板推到是否是安全的转换从另一个unique_ptr
    template &lt;typename _Up, typename _Ep&gt;
    using __safe_conversion_up =
        //先推导两个unique_ptr的内部指针转换是否安全，再看_Up是否是一个数组(数组可以退化为指针,这样的转换是不安全的)
        //约束_Up不能是一个数组
        __and_&lt;is_convertible&lt;typename unique_ptr&lt;_Up, _Ep&gt;::pointer, pointer&gt;,
               __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;

  public:
    //关于unique_ptr的方法功能，可以看见已经有很好的说明了，所以这里我不再说明
    // Constructors.

    /// Default constructor, creates a unique_ptr that owns nothing.
    //模板约束再这里使用，因为这里的删除器约束条件是impl中的约束条件::type
    //相当于对std::enable_if取type
    //如果删除器是一个指针类型，或者没有默认构造函数，会编译失败
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr() noexcept : _M_t() &#123;&#125;


    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an object of @c element_type
     *
     * The deleter will be value-initialized.
     */
     //同上
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    explicit unique_ptr(pointer __p) noexcept : _M_t(__p) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an object of @c element_type
     * @param __d  A reference to a deleter.
     *
     * The deleter will be initialized with @p __d
     */
     //这里做的删除器类型约束为：需要能拷贝构造
    template &lt;typename _Del = deleter_type,
              typename = _Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(pointer __p, const deleter_type &amp;__d) noexcept
        : _M_t(__p, __d) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an object of @c element_type
     * @param __d  An rvalue reference to a (non-reference) deleter.
     *
     * The deleter will be initialized with @p std::move(__d)
     */
     //这里做的删除器类型约束为：需要能拷贝构造
    template &lt;typename _Del = deleter_type,
              typename = _Require&lt;is_move_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(
        pointer __p,
        //约束为不能是一个左值引用
        __enable_if_t&lt;!is_lvalue_reference&lt;_Del&gt;::value, _Del &amp;&amp;&gt; __d) noexcept
        : _M_t(__p, std::move(__d)) &#123;&#125;

    //删除器类型是左值引用，并且对于传入的删除器是一个右值，是不允许的所以  =delete
    template &lt;typename _Del = deleter_type,
              typename _DelUnref = typename remove_reference&lt;_Del&gt;::type&gt;
    unique_ptr(pointer,
               __enable_if_t&lt;is_lvalue_reference&lt;_Del&gt;::value, _DelUnref &amp;&amp;&gt;) =
        delete;

    //对于nullptr,也就是std::nullptr_t类型的构造函数例如unique_ptr&lt;Foo&gt; p(nullptr);
    /// Creates a unique_ptr that owns nothing.
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr(nullptr_t) noexcept : _M_t() &#123;&#125;


    /// Move constructor.
    //仅仅是=default
    unique_ptr(unique_ptr &amp;&amp;) = default;

    /** @brief Converting constructor from another type
     *
     * Requires that the pointer owned by @p __u is convertible to the
     * type of pointer owned by this object, @p __u does not own an array,
     * and @p __u has a compatible deleter type.
     */
     //正如注释所言，从一个unique_ptr构造一个unique_ptr,要求拥有的指针能够转换并且不是数组类型
     //并且要求__u的删除器能够兼容this的删除器
    template &lt;
        typename _Up, typename _Ep,
        typename = _Require&lt;
            __safe_conversion_up&lt;_Up, _Ep&gt;, //看看内部指针能不能安全转换
            typename conditional&lt;is_reference&lt;_Dp&gt;::value, 
                                 is_same&lt;_Ep, _Dp&gt;, //看看删除器是不是一个引用类型，是，需要相同类型
                                 is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt; //不是需要_Ep(__u的删除器类型)能够转换为_Dp
    unique_ptr(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept
        : _M_t(__u.release(), std::forward&lt;_Ep&gt;(__u.get_deleter())) &#123;&#125;

#if _GLIBCXX_USE_DEPRECATED
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;
    /// Converting constructor from @c auto_ptr
    //因为auto_ptr是废弃的特性，所以这个函数不说明了，有兴趣的话读者可以自己分析一下
    template &lt;typename _Up,
              typename = _Require&lt;is_convertible&lt;_Up *, _Tp *&gt;,
                                  is_same&lt;_Dp, default_delete&lt;_Tp&gt;&gt;&gt;&gt;
    unique_ptr(auto_ptr&lt;_Up&gt; &amp;&amp;__u) noexcept;
#pragma GCC diagnostic pop
#endif

    /// Destructor, invokes the deleter if the stored pointer is not null.
    ~unique_ptr() noexcept &#123;
      //如果删除器不是可调用的，会断言失败
      //__is_invocable具体的实现，这里不说明
      static_assert(__is_invocable&lt;deleter_type &amp;, pointer&gt;::value,
                    &quot;unique_ptr&#39;s deleter must be invocable with a pointer&quot;);
      auto &amp;__ptr = _M_t._M_ptr(); //先缓存指针
      if (__ptr != nullptr)        //如果不是空，使用删除器删除
        get_deleter()(std::move(__ptr)); 
      __ptr = pointer();   
    &#125;

    // Assignment.

    /** @brief Move assignment operator.
     *
     * Invokes the deleter if this object owns a pointer.
     */
     //同样的，简单是使用default
    unique_ptr &amp;operator=(unique_ptr &amp;&amp;) = default;

    /** @brief Assignment from another type.
     *
     * @param __u  The object to transfer ownership from, which owns a
     *             convertible pointer to a non-array object.
     *
     * Invokes the deleter if this object owns a pointer.
     */
     //涉及到类型的转换，这个问题上面已经看到过了
     //可以类似的如法炮制
    template &lt;typename _Up, typename _Ep&gt;
    typename enable_if&lt;__and_&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,
                              is_assignable&lt;deleter_type &amp;, _Ep &amp;&amp;&gt;&gt;::value,
                       unique_ptr &amp;&gt;::type
    operator=(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept &#123;
      reset(__u.release());
      get_deleter() = std::forward&lt;_Ep&gt;(__u.get_deleter());
      return *this;
    &#125;

    /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
    //对于nullptr_t的赋值操作
    unique_ptr &amp;operator=(nullptr_t) noexcept &#123;
      reset();
      return *this;
    &#125;

    // Observers.

    /// Dereference the stored pointer.
    //对element_type添加一个左值引用
    //在type_traits中定义的add_lvalue_reference的实现细节，在这里并不想多说
    //我可以负责任的告诉你,add_lvalue_reference会对T, T&amp;&amp;变为T &amp;,对T &amp; 不变
    typename add_lvalue_reference&lt;element_type&gt;::type operator*() const &#123;
      __glibcxx_assert(get() != pointer());
      return *get();
    &#125;

    /// Return the stored pointer.
    //-&gt;运算符，不用多说，看一下就懂
    pointer operator-&gt;() const noexcept &#123;
      _GLIBCXX_DEBUG_PEDASSERT(get() != pointer());
      return get();
    &#125;

    /// Return the stored pointer.
    pointer get() const noexcept &#123; return _M_t._M_ptr(); &#125;

    /// Return a reference to the stored deleter.
    deleter_type &amp;get_deleter() noexcept &#123; return _M_t._M_deleter(); &#125;

    /// Return a reference to the stored deleter.
    const deleter_type &amp;get_deleter() const noexcept &#123;
      return _M_t._M_deleter();
    &#125;

    //隐式转换为bool，可以用在这种场景，例如
    //unique_ptr&lt;Foo&gt; a;
    //if(a) &#123;...&#125;
    /// Return @c true if the stored pointer is not null.
    explicit operator bool() const noexcept &#123;
      return get() == pointer() ? false : true;
    &#125;

    // Modifiers.

    /// Release ownership of any stored pointer.
    pointer release() noexcept &#123; return _M_t.release(); &#125;

    /** @brief Replace the stored pointer.
     *
     * @param __p  The new pointer to store.
     *
     * The deleter will be invoked if a pointer is already owned.
     */
    void reset(pointer __p = pointer()) noexcept &#123;
      static_assert(__is_invocable&lt;deleter_type &amp;, pointer&gt;::value,
                    &quot;unique_ptr&#39;s deleter must be invocable with a pointer&quot;);
      _M_t.reset(std::move(__p));
    &#125;

    /// Exchange the pointer and deleter with another object.
    void swap(unique_ptr &amp;__u) noexcept &#123;
        //断言检查删除器是否右可交换的能力
      static_assert(__is_swappable&lt;_Dp&gt;::value, &quot;deleter must be swappable&quot;);
      //调用_M_t的swap，实际上是__uniq_ptr_impl中的swap
      _M_t.swap(__u._M_t);
    &#125;

    // Disable copy from lvalue.
    //拷贝构造和赋值运算符是删除的
    unique_ptr(const unique_ptr &amp;) = delete;
    unique_ptr &amp;operator=(const unique_ptr &amp;) = delete;
  &#125;;
</code></pre>
<p>对于非数组版本的unique_ptr我们已经分析完成了，下面是对于数组版本的特例化</p>
<p>相对于非数组版本，数组版本主要修改了</p>
<ul>
<li>默认删除器做delete[]动作</li>
<li>重载[]</li>
</ul>
<pre><code class="C++">  /// 20.7.1.3 unique_ptr for array objects with a runtime length
  // [unique.ptr.runtime]
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 740 - omit specialization for array objects with a compile time length
  // 对编译时期能确定长度的数组特例化
  // 对于已经说过的问题，就不再写注释了，请读者自己注意
  template &lt;typename _Tp, typename _Dp&gt; class unique_ptr&lt;_Tp[], _Dp&gt; &#123;
    template &lt;typename _Up&gt;
    using _DeleterConstraint =
        typename __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;

    __uniq_ptr_data&lt;_Tp, _Dp&gt; _M_t;

    //就像remove_cv_t
    template &lt;typename _Up&gt; using __remove_cv = typename remove_cv&lt;_Up&gt;::type;

    // like is_base_of&lt;_Tp, _Up&gt; but false if unqualified types are the same
    // 从实现中和注释中就可以看出，需要判断Up是否是Tp的派生类
    template &lt;typename _Up&gt;
    using __is_derived_Tp =
        __and_&lt;is_base_of&lt;_Tp, _Up&gt;,
               __not_&lt;is_same&lt;__remove_cv&lt;_Tp&gt;, __remove_cv&lt;_Up&gt;&gt;&gt;&gt;;

  public:
    using pointer = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;
    using element_type = _Tp;
    using deleter_type = _Dp;

    // helper template for detecting a safe conversion from another
    // unique_ptr
    //辅助模板来帮助实现从另一个unique_ptr转换是否安全
    //安全转换的条件是：
    //是一个数组
    //poniter和element_type*是同一类型
    //另一个unique_ptr::pointer和::element_type*是同一个类型
    //另一个unique_ptr::element_type(*)[]可以转换为当前的unique_ptr::element_type(*)[]
    //至于为什么要这样设计，还是和用多态方式处理数组有关，下面会说到
    template &lt;typename _Up, typename _Ep, typename _UPtr = unique_ptr&lt;_Up, _Ep&gt;,
              typename _UP_pointer = typename _UPtr::pointer,
              typename _UP_element_type = typename _UPtr::element_type&gt;
    using __safe_conversion_up =
        __and_&lt;is_array&lt;_Up&gt;, is_same&lt;pointer, element_type *&gt;,
               is_same&lt;_UP_pointer, _UP_element_type *&gt;,
               is_convertible&lt;_UP_element_type (*)[], element_type (*)[]&gt;&gt;;

    // helper template for detecting a safe conversion from a raw pointer
    // 辅助模板从裸指针转换为当前的unique_ptr::pointer
    //这段代码实在是太难以阅读了，为了方便，我们进行一些格式上的改变
    // template &lt;typename _Up&gt;
    // using __safe_conversion_raw = __and_&lt;
    //     __or_&lt;__or_&lt;is_same&lt;_Up, pointer&gt;, is_same&lt;_Up, nullptr_t&gt;&gt;,
    //           __and_&lt;is_pointer&lt;_Up&gt;, is_same&lt;pointer, element_type *&gt;,
    //                  is_convertible&lt;typename remove_pointer&lt;_Up&gt;::type (*)[],
    //                                 element_type (*)[]&gt;&gt;&gt;&gt;;
    //满足转换规则只需要满足其中以下条件之一(Up是一个raw-pointer)
    //- Up和pointer是同类型或者Up和nullptr_t是同类型
    //- Up是一个指针并且pointer和element_type*是同一类型并且Up移除指针后的类型的数组指针可以转换为element_type的数组指针
    template&lt;typename Up&gt;

    using _safe_conversion_raw = __and_&lt;
            __or_&lt;
                    __or_&lt;is_same&lt;Up, pointer&gt;, is_same&lt;Up, nullptr_t&gt; &gt;,
                    __and_&lt;
                            is_pointer&lt;Up&gt;, is_same&lt;pointer, element_type *&gt;,
                            is_convertible&lt;typename remove_pointer&lt;Up&gt;::type (*)[], element_type (*)[]&gt;
                          &gt;
                 &gt;
    &gt;;
    // Constructors.

    /// Default constructor, creates a unique_ptr that owns nothing.
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr() noexcept : _M_t() &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an array of a type safely convertible
     * to an array of @c element_type
     *
     * The deleter will be value-initialized.
     */
    template &lt;
        typename _Up, typename _Vp = _Dp, typename = _DeleterConstraint&lt;_Vp&gt;,
        typename =
            typename enable_if&lt;__safe_conversion_raw&lt;_Up&gt;::value, bool&gt;::type&gt; //做了一个类型约束
    explicit unique_ptr(_Up __p) noexcept : _M_t(__p) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an array of a type safely convertible
     * to an array of @c element_type
     * @param __d  A reference to a deleter.
     *
     * The deleter will be initialized with @p __d
     */
     //从一个raw-pointer和一个删除器构造一个uniuqe_ptr
     //很明显的需要raw-pointer可以安全的转换为unique_ptr并且删除器是可以拷贝狗仔的
    template &lt;typename _Up, typename _Del = deleter_type,
              typename = _Require&lt;__safe_conversion_raw&lt;_Up&gt;, //只是类型约束和非数组版的不一样
                                  is_copy_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(_Up __p, const deleter_type &amp;__d) noexcept : _M_t(__p, __d) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an array of a type safely convertible
     * to an array of @c element_type
     * @param __d  A reference to a deleter.
     *
     * The deleter will be initialized with @p std::move(__d)
     */
    template &lt;typename _Up, typename _Del = deleter_type,
              typename = _Require&lt;__safe_conversion_raw&lt;_Up&gt;,
                                  is_move_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(
        _Up __p,
        __enable_if_t&lt;!is_lvalue_reference&lt;_Del&gt;::value, _Del &amp;&amp;&gt; __d) noexcept
        : _M_t(std::move(__p), std::move(__d)) &#123;&#125;

    template &lt;typename _Up, typename _Del = deleter_type,
              typename _DelUnref = typename remove_reference&lt;_Del&gt;::type,
              typename = _Require&lt;__safe_conversion_raw&lt;_Up&gt;&gt;&gt;
    unique_ptr(_Up,
               __enable_if_t&lt;is_lvalue_reference&lt;_Del&gt;::value, _DelUnref &amp;&amp;&gt;) =
        delete;

    /// Move constructor.
    unique_ptr(unique_ptr &amp;&amp;) = default;

    /// Creates a unique_ptr that owns nothing.
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr(nullptr_t) noexcept : _M_t() &#123;&#125;

    template &lt;
        typename _Up, typename _Ep,
        typename = _Require&lt;
            __safe_conversion_up&lt;_Up, _Ep&gt;,
            typename conditional&lt;is_reference&lt;_Dp&gt;::value, is_same&lt;_Ep, _Dp&gt;,
                                 is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;
    unique_ptr(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept
        : _M_t(__u.release(), std::forward&lt;_Ep&gt;(__u.get_deleter())) &#123;&#125;

    /// Destructor, invokes the deleter if the stored pointer is not null.
    ~unique_ptr() &#123;
      auto &amp;__ptr = _M_t._M_ptr();
      if (__ptr != nullptr)
        get_deleter()(__ptr);
      __ptr = pointer();
    &#125;

    // Assignment.

    /** @brief Move assignment operator.
     *
     * Invokes the deleter if this object owns a pointer.
     */
    unique_ptr &amp;operator=(unique_ptr &amp;&amp;) = default;

    /** @brief Assignment from another type.
     *
     * @param __u  The object to transfer ownership from, which owns a
     *             convertible pointer to an array object.
     *
     * Invokes the deleter if this object owns a pointer.
     */
    template &lt;typename _Up, typename _Ep&gt;
    typename enable_if&lt;__and_&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,
                              is_assignable&lt;deleter_type &amp;, _Ep &amp;&amp;&gt;&gt;::value,
                       unique_ptr &amp;&gt;::type
    operator=(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept &#123;
      reset(__u.release());
      get_deleter() = std::forward&lt;_Ep&gt;(__u.get_deleter());
      return *this;
    &#125;

    /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
    unique_ptr &amp;operator=(nullptr_t) noexcept &#123;
      reset();
      return *this;
    &#125;

    // Observers.
    // 重载的[]，实现也是非常简单
    /// Access an element of owned array.
    typename std::add_lvalue_reference&lt;element_type&gt;::type
    operator[](size_t __i) const &#123;
      __glibcxx_assert(get() != pointer());
      return get()[__i];
    &#125;

    /// Return the stored pointer.
    pointer get() const noexcept &#123; return _M_t._M_ptr(); &#125;

    /// Return a reference to the stored deleter.
    deleter_type &amp;get_deleter() noexcept &#123; return _M_t._M_deleter(); &#125;

    /// Return a reference to the stored deleter.
    const deleter_type &amp;get_deleter() const noexcept &#123;
      return _M_t._M_deleter();
    &#125;

    /// Return @c true if the stored pointer is not null.
    explicit operator bool() const noexcept &#123;
      return get() == pointer() ? false : true;
    &#125;

    // Modifiers.

    /// Release ownership of any stored pointer.
    pointer release() noexcept &#123; return _M_t.release(); &#125;

    /** @brief Replace the stored pointer.
     *
     * @param __p  The new pointer to store.
     *
     * The deleter will be invoked if a pointer is already owned.
     */
    template &lt;
        typename _Up,
        typename = _Require&lt;__or_&lt;
            is_same&lt;_Up, pointer&gt;,
            __and_&lt;is_same&lt;pointer, element_type *&gt;, is_pointer&lt;_Up&gt;,
                   is_convertible&lt;typename remove_pointer&lt;_Up&gt;::type (*)[],
                                  element_type (*)[]&gt;&gt;&gt;&gt;&gt;
    void reset(_Up __p) noexcept &#123;
      _M_t.reset(std::move(__p));
    &#125;

    void reset(nullptr_t = nullptr) noexcept &#123; reset(pointer()); &#125;

    /// Exchange the pointer and deleter with another object.
    void swap(unique_ptr &amp;__u) noexcept &#123;
      static_assert(__is_swappable&lt;_Dp&gt;::value, &quot;deleter must be swappable&quot;);
      _M_t.swap(__u._M_t);
    &#125;

    // Disable copy from lvalue.
    unique_ptr(const unique_ptr &amp;) = delete;
    unique_ptr &amp;operator=(const unique_ptr &amp;) = delete;
  &#125;;
</code></pre>
<h2 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h2><p>令人头大的部分终于过去了，占据了本文章绝大篇幅的那些部分。接下来放松一下，看一看<code>std::make_unique</code>的实现吧</p>
<pre><code>在这里仅仅分析14的部分(make_unique是14增添的)，对于14以上的代码，读者有兴趣可以自行了解
</code></pre>
<h3 id="MakeUniq"><a href="#MakeUniq" class="headerlink" title="_MakeUniq"></a>_MakeUniq</h3><p>做的功能就是类型萃取，用作于make_unique的返回值，这样做的目的也是为了实现类型安全</p>
<p>类型参数应为T的地方写成T[]会导致类型替换失败，反之亦然</p>
<pre><code class="C++">  template&lt;typename _Tp&gt;
    struct _MakeUniq
    &#123; typedef unique_ptr&lt;_Tp&gt; __single_object; &#125;;

  template&lt;typename _Tp&gt;
    struct _MakeUniq&lt;_Tp[]&gt;
    &#123; typedef unique_ptr&lt;_Tp[]&gt; __array; &#125;;

  template&lt;typename _Tp, size_t _Bound&gt;
    struct _MakeUniq&lt;_Tp[_Bound]&gt;
    &#123; struct __invalid_type &#123; &#125;; &#125;;
</code></pre>
<p>make_unique的实现部分</p>
<pre><code class="C++">  /// std::make_unique for single objects
  // 非数组版本
  template&lt;typename _Tp, typename... _Args&gt;
    inline typename _MakeUniq&lt;_Tp&gt;::__single_object
    make_unique(_Args&amp;&amp;... __args) //&amp;&amp; ... +forward 的形式转发参数
    &#123; return unique_ptr&lt;_Tp&gt;(new _Tp(std::forward&lt;_Args&gt;(__args)...)); &#125;

  /// std::make_unique for arrays of unknown bound
  //返回一个unique_ptr指向一个长度为__num的数组
  //关于remove_extent_t,请参考https://www.apiref.com/cpp-zh/cpp/types/remove_extent.html
  template&lt;typename _Tp&gt;
    inline typename _MakeUniq&lt;_Tp&gt;::__array
    make_unique(size_t __num)
    &#123; return unique_ptr&lt;_Tp&gt;(new remove_extent_t&lt;_Tp&gt;[__num]()); &#125;
  
  //不能从一个已知界限的数组返回一个unique_ptr
  /// Disable std::make_unique for arrays of known bound
  template&lt;typename _Tp, typename... _Args&gt;
    typename _MakeUniq&lt;_Tp&gt;::__invalid_type
    make_unique(_Args&amp;&amp;...) = delete;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>unique_ptr的源码分析，就告一段落了。还有很多很多细节和实现手法没有剖析，剖析了的细节和实现手法，一些也没有说明为什么要这样做。</p>
<p>如果日后发现的错误，会在这里更新勘误表。</p>
<p>如果你有任何的问题，可以通过邮箱，QQ来联系到我。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00bcd4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #00a596">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/22/unique-ptr源码解析/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/万能引用和重载中的问题以及解决方案/">
        <h2 class="post-title">万能引用和重载中的问题以及解决方案</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="使用万能引用来通用式的处理左值右值排列组合的情况"><a href="#使用万能引用来通用式的处理左值右值排列组合的情况" class="headerlink" title="使用万能引用来通用式的处理左值右值排列组合的情况"></a>使用万能引用来通用式的处理左值右值排列组合的情况</h1><p>我曾经在一次开发中遇到过这样的问题，我有一个User class，他里面有string：id, name, passward，以及其他内置类型.如果是在C++11之前，写出一个好的构造函数应当是很容易的，但是C++11之后，有了移动语义，写出一个完美的构造函数确实不容易。</p>
<p>这样想，我想尽可能的利用好移动语义，假设我们的name等等成员不是一个短字符串，这时候移动语义对性能会有优化。现在又3个string类型的成员，考虑到每个成员的左值和右值，有8种构造函数的写法(不算默认构造)。要是这种可以进行移动的成员再多几个呢——这是一个指数级增长的趋势。这种写法显然是不行的。那就用模板——还要是万能模板。可以初步设计出这样的构造函数。</p>
<pre><code class="C++">class User &#123;
public:
    template &lt;typename T&gt;
    User(T &amp;&amp; _name, T &amp;&amp; _id, T &amp;&amp; _password) :
        name(forward&lt;T&gt;(_name), forward&lt;T&gt;(_id),forward&lt;T&gt;(_password)) &#123; &#125;
&#125;
</code></pre>
<p>这样哪个无论什么样的组合，我们均可用一个函数来完成。而且对于其他有移动语义的类型来书，再加上一个F &amp;&amp;即可，这是线性增加的，还算不错。</p>
<h1 id="万能引用和重载会互相冲突"><a href="#万能引用和重载会互相冲突" class="headerlink" title="万能引用和重载会互相冲突"></a>万能引用和重载会互相冲突</h1><p>当形参只有一个的时候，会有些微妙的变化。</p>
<p>现在假设User中只有一个string类型的name，如果你依旧考虑像上面一样实现构造函数，会有一些隐晦的错误。</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    User(T &amp;&amp; _name): name(std::forward&lt;T&gt;(_name)) &#123; &#125;
private:
    string name;
&#125;;


int main()
&#123;
    User user(&quot;hello&quot;); //很好，这个甚至是直接再类中用const char * 直接构造了一个字符串
    User user1(user);       // error
    return 0;
&#125;
</code></pre>
<p>编译器会给出我们这样的一个错误</p>
<blockquote>
<p>No matching constructor for initialization of ‘std::string’ (aka ‘basic_string<char>‘)</p>
</blockquote>
<p>编译器说无法匹配string的构造函数，莫名奇妙有些。<br>实际上，编译器给出的错误一点问题也没有。</p>
<p>我们先来回复一个拷贝构造的函数原型 <code>User(const User &amp; user)</code><br>我们传递的user不具有const性质，而模板会生成一个non-const的形参，看起来像这样<code>User(User &amp; _name): name(_name)</code>(此处省略forward,下同)，编译器觉得这个non-const的版本更加匹配，随后使用一个User对象来构造string，那肯定是不行的。<br>如果我们的user具有const性质，编译器就不会报错。</p>
<pre><code class="C++">int main()
&#123;
    const User user(&quot;hello&quot;); 
    User user1(user);       // 工作的很好
    return 0;
&#125;
</code></pre>
<p>这种和直觉上不服的行为肯定不是我们想要的，如果你留意编译器的警告，或者说是clang-tidy的静态分析，你会看见这样的警告</p>
<blockquote>
<p>Clang-Tidy: Constructor accepting a forwarding reference can hide the copy and move constructors</p>
<p>Clang-Tidy：接受转发引用的构造函数可以隐藏复制和移动构造函数</p>
</blockquote>
<p>还有这样的情况，假设我们只需要构造一个int类型的数据成员，其他的数据成员都调用默认构造。</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(T &amp;&amp; _name): name(std::forward&lt;T&gt;(_name)) &#123;
        cout &lt;&lt; &quot;T&amp;&amp;&quot; &lt;&lt; endl;
    &#125;
    explicit User(int _age): age(_age), name() &#123; &#125;
private:
    string name;
    int age;
&#125;;
int main()
&#123;
    User user(25);
    //...假设这里经过算法的计算，得出的一个double类型来当作age， 我们也期望这种隐式转换double -&gt; int(即向下取整)
    double ans = 18.63;
    User user1(ans)
    return 0;
&#125;
</code></pre>
<p>不好了，编译器又给出了错误！</p>
<p>原因是万能引用为我们实例化了一个<code>User (double &amp; _name): name(_name)</code>,精确度高于手写的int版本的构造函数——用一个double构造一个string，当然是不行的了。</p>
<p>类似的成员函数应用万能模板也有这样的重载问题。</p>
<h2 id="在继承体系中，这个问题也会出现，甚至更加错综复杂"><a href="#在继承体系中，这个问题也会出现，甚至更加错综复杂" class="headerlink" title="在继承体系中，这个问题也会出现，甚至更加错综复杂"></a>在继承体系中，这个问题也会出现，甚至更加错综复杂</h2><p>现在Reader继承User</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(T &amp;&amp; _name): name(std::forward&lt;T&gt;(_name)) &#123;
        cout &lt;&lt; &quot;T&amp;&amp;&quot; &lt;&lt; endl;
    &#125;
    explicit User(int _age): age(_age), name() &#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age;
&#125;;

class Reader : public User &#123;
public:
    Reader(const Reader &amp; reader) :
            User(reader), phone_number(reader.phone_number) &#123; &#125;
private:
    string phone_number;
&#125;;
</code></pre>
<p>编译器依旧还是这个错误</p>
<blockquote>
<p>No matching constructor for initialization of ‘std::string’ (aka ‘basic_string<char>‘)</p>
</blockquote>
<p>原因是Reader &amp; cast -&gt; User &amp; 是一种隐式转换。</p>
<p>万能引用又出来作怪，生成这样的版本<code>User(Reader &amp; _name): name(_name))</code></p>
<p>显然，这个版本更加精确，使用Reader &amp; 构造 string当然不行。</p>
<p>《Modern Effective C++》,对些情况是这样总结的</p>
<ul>
<li>把万能引用作为候选重载型别，几乎总会让该重载版本在始料未及的情况下被调用</li>
<li>完美转发构造函数的问题尤为严重，因为对于非常量的左值型别而言，他们一般都会形成相对于复制构造函数的更加匹配，并且还会劫持派生类中对基类的复制和构造函数的调用。</li>
</ul>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决这个问题的方法还是有很多的，我们可以权衡利弊的来考虑。</p>
<h2 id="退而求其次"><a href="#退而求其次" class="headerlink" title="退而求其次"></a>退而求其次</h2><p>不是谁都有精力去学习复杂的Modern C++(这里大部分的意思是关于TMP)，使用一些简单的新特性也是不错的。我们可以完全不用万能引用，因为相比代码可读性极具下降而带来不稳定的性能提升，如果你不是一个完美主义者，代码可读性应当是应该的选择。</p>
<h3 id="舍弃重载"><a href="#舍弃重载" class="headerlink" title="舍弃重载"></a><strong>舍弃重载</strong></h3><p>大可像Rust那样，舍弃重载，也是解决办法之一，但是由于语法问题，构造函数时语言固有的，或许你也可以麻烦一点，用static函数实现？就使用默认构造，然后一一修改值——这样效率反而低了，舍本逐末不可取。总之，舍弃重载可以暂时的解决问题，但不是一个长久之计。</p>
<h3 id="传递const-T-amp"><a href="#传递const-T-amp" class="headerlink" title="传递const T &amp;"></a>传递const T &amp;</h3><p>这就是98时候的写法了，经典永不过时，这种写法简洁又不失高性能，并且不会又其他的问题出现，这种方式大家应当都很熟悉，还是很值得考虑的。</p>
<h2 id="使用现代方法"><a href="#使用现代方法" class="headerlink" title="使用现代方法"></a><strong>使用现代方法</strong></h2><p>如果你选择了使用现代方法解决此问题，就代表了你踏进了Modern C++的大门，不仅仅是关于&amp;&amp;和&amp;的语法游戏，你必须具有TMP(模板元编程的基础),才可以游刃有余的写出奇妙的Modern C++代码，如果你还不具备这项技能，又想使用高级手法来解决问题，那你应当做好准备迎接一轮又一轮的新特性学习。</p>
<blockquote>
<p>题外话：我把Modern C++代码说做是“奇妙的”，而不是“精美的”、“简洁的”这类词是有原因的，一个基本的事实，Modern C++代码并不简洁，甚至是丑陋和复杂，但这些复杂的代码背后的工作原理，了解之后没有人不会惊叹，不会大呼奇妙。</p>
</blockquote>
<h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a><strong>传值</strong></h3><p>可以使用值传递+移动构造的方式来代替万能引用和转发。如果对象的移动语义有较低的成本使用 pass by value and use std::move也是一个比较好的选择。</p>
<p>比如说像这样</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(string _name): name(std::move(_name)) &#123;
    &#125;
    explicit User(int _age): age(_age), name() &#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>但是这个选择不够通用，如果对象没有移动语义，或者是POD类型，这样做性能反而会下降。你可以阅读这个文章<a target="_blank" rel="noopener" href="https://jan6055.github.io/2022/09/17/pass-by-value-and-use-std-move/">https://jan6055.github.io/2022/09/17/pass-by-value-and-use-std-move/</a> 来了解相关信息。</p>
<h3 id="标签分派"><a href="#标签分派" class="headerlink" title="标签分派"></a><strong>标签分派</strong></h3><p>如果你看过一些STL的源代码，可能会熟悉这种方式，大致的思路是这样的，我们把构造函数委派给其他函数，这些函数做具体的实现，并且他们有不同的重载版本，分别接受构造所需要的参数和一个名为true_type&#x2F;false_type类型的对象</p>
<blockquote>
<p>true_type和false_type由标准库提供，仅仅是定义，并未添加任何数据和行为， 实现标签的效果。</p>
</blockquote>
<p>判断T是不是整形，我们可以使用<code>std::is_integral</code>，但是考虑左值的情况，T被推断为int &amp;，我们应当先把引用性质给移除，可以使用<code>std::remove_reference</code>得出的代码就是这样<code>std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;()</code>, 我们使用的_t后缀的模板（TMP中叫做元函数）来直接获得类型——这是C++14支持的，但是，别忘了使用<code>()</code>来生成一个对象，才可用于重载。</p>
<p>具体的实现如下</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(T &amp;&amp; arg) &#123;
        init(std::forward&lt;T&gt;(arg),
        typename std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;()
        );
    &#125;

    template&lt;typename T&gt;
    void init(T &amp;&amp; _name, false_type) &#123;
        name = std::forward&lt;T&gt;(_name);  //这里是赋值操作，如果使用这样的手法对于构造函数而言，就只能这样
        age = 0;
    &#125;
    void init(int _age, true_type) &#123;
        //name会隐式的初始化
        age = _age;
    &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>这确实够复杂，先别放松，更复杂的还在后面！</p>
<h3 id="使用TMP对万能模板做出限制"><a href="#使用TMP对万能模板做出限制" class="headerlink" title="使用TMP对万能模板做出限制"></a><strong>使用TMP对万能模板做出限制</strong></h3><p>先说明一点，你应当了解TMP并且熟悉其最基本构成，还应当知道SFINAE，如果你不知道，快去找相关书籍看吧，如果我把这里展开说明，并且把用到的TMP技巧细节全部说一遍，那就偏离主题了。并且，我也没有足够的能力讲清TMP中的所有细节和问题，这件事情你应当请教C++标准委员会(bushi</p>
<p>我们可以让万能引用拒绝User类的对象，也拒绝int类的对象。在现代C++中，这是可以实现的——你甚至能在98里实现，但是需要点技巧。</p>
<p>使用enable_if来让编译器类型替换失败，也就是SFINAE, 但是我们应当考虑到左值的情况T , T&amp;并不是一种类型，比如int, int&amp;, 还有<code>const T, volatile T, const volatileT</code> 这些和T均不是一种类型。可以使std::decay来去掉cvr性质。</p>
<p>具体的实现是这样</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T,
             typename = typename std::enable_if&lt;!std::is_same&lt;User,std::decay_t&lt;T&gt;&gt;::value &amp;&amp;
                                                !std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;::value
                                               &gt;::type&gt;
    explicit User(T &amp;&amp; _name) : name(std::forward&lt;T&gt;(_name)) &#123; &#125;
    explicit User(int _age) : age(_age), name()&#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>这样实现还真是复杂，如果没有C++14<code>_t</code>的元函数，那么将会更加复杂，感谢C++14!<br>大功告成了吗，并没有。对于继承关系来说，还是存在问题。如果子类中调用基类的构造函数，就是我们讨论过的哪个问题。在实例化的时候，在经过类型退化后，T被推断为Reader，这就又回到了我们之前所说的问题。</p>
<p>好在STL中提供了<code>is_base_of</code>这个元函数，能够判断一个类型是否是另一个类型的基类,<code>is_base_of&lt;T,T&gt;::value = ture</code></p>
<p>于是我们可以简单的修改一下代码。</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T,
             typename = typename std::enable_if&lt;!std::is_base_of&lt;User,std::decay_t&lt;T&gt;&gt;::value &amp;&amp;
                                                !std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;::value
                                               &gt;::type&gt;
    explicit User(T &amp;&amp; _name) : name(std::forward&lt;T&gt;(_name)) &#123; &#125;
    explicit User(int _age) : age(_age), name()&#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;

class Reader : public User &#123;
public:
    Reader(const Reader &amp; reader) :
            User(reader), phone_number(reader.phone_number) &#123; &#125;
private:
    string phone_number;
&#125;;
</code></pre>
<p>问题迎刃而解！你现在是否感叹Modern C++的巧妙了呢？</p>
<h1 id="万能模板的不足"><a href="#万能模板的不足" class="headerlink" title="万能模板的不足"></a>万能模板的不足</h1><p>你会说，能有什么不足呢？这么高级的技巧，多么的神奇。实际上，万能引用的强大如此，不足也是如此。回头看看经典版本</p>
<pre><code class="C++">class User &#123;
public:
    explicit User(const string &amp; _name): name(_name) &#123; &#125;
    explicit User(int _age) : age(_age), name() &#123; &#125;
    User(const User &amp;) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>正所谓洗去铅华只剩金，实现了同样的功能，难道我们要为性能舍弃掉如此的可读性和简洁性吗。同样的，如果是团队合作，小伙伴们可都不一定会这样的高级技巧。到头来还要你自己维护。如果没有注释，等个几天——你就不知道自己写的是什么啦，真是太棒了！</p>
<p>使用模板的一个不可避免的问题就是当错误发生时，不好定位。你应该有没有按照规范使用过STL容器的经历，看见了编译器给你报告的错误。很吓人，如果没有经验的人看到这些错误（可能有几百行甚至几千行）。该怎么定位问题。虽然我们可以使用<code>statci_assert</code>来未雨绸缪。但也不是所有的时候情况都很客观。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，要不要使用如此晦涩复杂的特性，还是取决于程序员本身，你也可以使用const &amp;快快乐乐的写代码，正因为</p>
<blockquote>
<p>你没有用到的东西，不应当给你增添任何负担，你用到的东西，没有什么比C++提供的更好了</p>
</blockquote>
<p>使用Modern C++也是你自己的选择，除非写库，很少有人能用到模板开发，真正把这些Modern C++特性用到生产环境的，并且用好的，我想都是在C++领域发光发热的大牛们吧。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ff7d73">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/TMP/" style="color: #ffa2c4">
                TMP
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/万能引用和重载中的问题以及解决方案/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/17/ROV/">
        <h2 class="post-title">ROV</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h1><p>我们有这样的一段代码</p>
<pre><code class="C++">X getX() &#123;
    X x;
    //...
    return x;
&#125;
</code></pre>
<p>你可能会说，w在返回的时候需要进行拷贝一次。如果你还抱有这种想法，你应该拥向现代C++的怀抱了，现在的标准规定，针对这种情况以及类似的情况，编译器应当做返回值优化(return value optimmization)。使得调用getWidget就像直接在调用处构造了一个对象，而不用经过一次复制。</p>
<h1 id="C-标准对于返回值的优化"><a href="#C-标准对于返回值的优化" class="headerlink" title="C++标准对于返回值的优化"></a>C++标准对于返回值的优化</h1><blockquote>
<p>此处参考C++标准库中文第二版 P22-P23</p>
</blockquote>
<p>C++标准指出，对于以上的代码，有着这样的保证。</p>
<ul>
<li>如果X有一个可取的copy&#x2F;move构造函数，编译器可以选择忽略其中的copy版本。</li>
<li>否则，如果X有一个move构造函数，X就被moved</li>
<li>否则，如果X有一个copy构造函数，X就被copied</li>
<li>否则，报告出一个编译器错误</li>
</ul>
<p>我们需要对上述的规则一一解释<br>按照惯例，我们依旧需要准备一个测试所用的类</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
struct Foo &#123;
    int a = 0;
    double b = 0;
    string c;
    Foo() = default;
    Foo(int _a, double _b, const string &amp; _c) : a(_a), b(_b), c(_c) &#123; &#125;
    Foo(const Foo &amp; foo) : a(foo.a), b(foo.b), c(foo.c) &#123;
        cout &lt;&lt;  &quot;call &amp;&quot; &lt;&lt; endl;
    &#125;
    Foo(Foo &amp;&amp; foo)  noexcept : a(foo.a), b(foo.b), c(std::move(foo.c))  &#123;
        cout &lt;&lt; &quot;call &amp;&amp;&quot; &lt;&lt; endl;
    &#125;

&#125;;

Foo getFoo_1(int a = 0, double b = 0, const string &amp; c = &#123; &#125;) &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret(a,b,c);
    return ret;
&#125;
Foo getFoo_2(int a = 0, double b = 0, const string &amp; c = &#123; &#125;) &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret(a,b,c);
    return std::move(ret);
&#125;
Foo getFoo_3() &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret;
    ret.a = 10;
    ret.a *= 20;
    return ret;
&#125;
Foo getFoo_4() &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret;
    Foo &amp; r_ret = ret;
    return r_ret;
&#125;

Foo getFoo_5() &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    static Foo ret;
    return ret;
&#125;
void work(const Foo &amp; foo) &#123;
&#125;
int main()
&#123;
    work(getFoo_1(0,0,&quot;hello&quot;));
    work(getFoo_2());
    work(getFoo_3());
    work(getFoo_4());
    work(getFoo_5());
    return 0;
&#125;
</code></pre>
<p>测试的结果如下</p>
<pre><code>+++++   //RVO
+++++   
call &amp;&amp; //我们的自作聪明，组织了编译器的优化，因为move将对象变为&amp;&amp;，则moved
+++++   //RVO
+++++   
call &amp;  //这里我们返回了一个引用，编译器不再进行RVO而是copide
+++++   
call &amp;  //返回了一个static变量，move是不可行的，因此copide
</code></pre>
<h1 id="测试结果的思考"><a href="#测试结果的思考" class="headerlink" title="测试结果的思考"></a>测试结果的思考</h1><p>不难看出，编译器在很多的情况下都会为我们做返回值优化，即使我们在工厂函数中进行了一些额外的操作。</p>
<p>我们自作聪明的move操作，反而会阻止编译器的RVO，如果对象的移动语义成本不低，我们会聪明反被聪明误。</p>
<p>对于那些不可避免的copy，是没有办法规避的。</p>
<h1 id="不要自作聪明"><a href="#不要自作聪明" class="headerlink" title="不要自作聪明"></a>不要自作聪明</h1><p>你也许会绞尽脑汁的想象出这样的代码，甚至还会很得意的以为自己解决的返回值优化的问题</p>
<pre><code class="C++">X &amp;&amp; getX() &#123;
    X x;
    return x;
&#125;
</code></pre>
<p>实际上这样的行为不可取，因为右值引用也是一个引用，返回局部对象的引用—-你是嫌弃debug时候消耗的精力还不够多吗。</p>
<p>你可能又会反驳说，那我可以这样</p>
<pre><code class="C++">X &amp;&amp; getX() &#123;
    X x;
    return std::move(x);
&#125;
</code></pre>
<p>很遗憾，还是不可以，你大可可以自己试试，你一旦访问这样返回的对象，程序就会马上崩溃！！！同理的，你也不应当对要返回的局部对象实施forward.</p>
<p>所以，不要自己耍小聪明了，该怎么写就怎么写，编译器会为优化做操劳。</p>
<h1 id="对于参数包的优化"><a href="#对于参数包的优化" class="headerlink" title="对于参数包的优化"></a>对于参数包的优化</h1><p>对于参数的参数包的优化，也是一样的，你就把他当作和上面的情况一样就可以。</p>
<pre><code class="C++">template&lt;typename ... Args&gt;
Foo getFoo_6(Args &amp;&amp; ... args) &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo foo(std::forward&lt;Args&gt;(args)...);
    return foo;
&#125;

...

work(getFoo_6(10,10.3,&quot;hello&quot;));
</code></pre>
<p>你可以自己运行一下试试看。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ffa2c4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ff7d73">
                Modern C++
            </a>
        </span>
        
    </div>
    <a href="/2022/09/17/ROV/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <i class="fa-solid fa-caret-left fa-fw"></i>
            </span>
        </a>
        
    </div>
    <div class="page-index">
        
        <span>
            
            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        
        <span class="current">
            2
        </span>
        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <i class="fa-solid fa-caret-right fa-fw"></i>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4 " alt="avatar">
        </div>
        <div class="name">
            Jan6055
        </div>
        <div class="descriptions">
            
            <div class="description">
                兴趣：
            </div>
            
            <div class="description">
                C++
            </div>
            
            <div class="description">
                Rust
            </div>
            
            <div class="description">
                Haskell
            </div>
            
            <div class="description">
                这是我的个人博客，用于记录学习到的技能
            </div>
            
            <div class="description">
                我希望我的博客会帮到你
            </div>
            
            <div class="description">
                如果你对博客中的内容有疑问，请联系
            </div>
            
            <div class="description">
                QQ: 1796728809
            </div>
            
            <div class="description">
                email: 1796728809@qq.com
            </div>
            
            <div class="description">
                wangq6055@outlook.com
            </div>
            
            <div class="description">
                目前:
            </div>
            
            <div class="description">
                在校大二学生
            </div>
            
            <div class="description">
                在学习Modern C++ &amp;&amp; 各种计算机基础
            </div>
            
            <div class="description">
                时不时摆烂，很爽
            </div>
            
            <div class="description">
                But I love coding!
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/jan6055">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hello @you
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Jan6055
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>