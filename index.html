
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Jan6055的Blog</title>
        <meta name="author" content="Jan6055">
        <meta name="description" content="关于编程的，C++，Rust，Haskell等等。I Love Codingi!">
        <meta name="keywords" content="">
        <link rel="icon" href="">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Jan6055的Blog</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Jan6055的Blog</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(e1.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Jan6055的Blog</h1>
                <h3>Hello! and Enjoy!</h3>
                <h5>关于编程的，C++，Rust，Haskell等等。I Love Codingi!</h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/09/17/const-container-s-iterator-is-const-iterator/">
        <h2 class="post-title">Const Container&#39;s Iterator Is Const_iterator</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>就拿vector举例子</p>
<p>我们转到其代码</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220917130246653.png" alt="image-20220917130246653"></p>
<p>可以看见对于const的重载版本，返回的为const_iterator.</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在Modern Effective C++中说到，在通用的代码中，优先选用非成员版的begin()&#x2F;end(),也正是因为如此。</p>
<p>书中给出了cbegin()的一种实现方式。</p>
<pre><code class="C++">template &lt;typename C&gt;
auto cbegin(const C &amp; c)-&gt; decltype(c.begin()) &#123;
    return c.begin();
&#125;
</code></pre>
<p>因为对于具有const性质的容器（在标准库中的是这样，如果是其他库提供的容器，可能不会提供这样的行为），返回的迭代器是const_iterator,所以，这样做是正确的。</p>
<p>对于数组来说，也是一样的。begin对于数组有特例化。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220917132258921.png" alt="image-20220917132258921"></p>
<p>当数组具有const性质的时候，例如const int nums[10], _Tp会被推导为const int, 返回类型就是const int *, 就是数组的const_iterator</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/09/17/const-container-s-iterator-is-const-iterator/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/17/pass-by-value-and-use-std-move/">
        <h2 class="post-title">Pass by Value and Use Std::move</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="一个警告引发的思考"><a href="#一个警告引发的思考" class="headerlink" title="一个警告引发的思考"></a>一个警告引发的思考</h1><p>在c++11之前，无论是effective系列还是c++教程，都会告诉我们在一定情况下使用const &amp;来节省性能。但是在c++11之后，有了移动语义，使一些不可能的行为变成了可能。我们先来看一段简单的代码。</p>
<pre><code class="cpp">class Person &#123;
private:
    unsigned m_age = 0;
    string m_name;
    Person(const string &amp; name) : m_name(name) &#123; &#125;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>clang-tidy会给出这样的一个警告。</p>
<blockquote>
<p>Clang-Tidy: Pass by value and use std::move</p>
</blockquote>
<p>为什么会这样呢，这无疑是一个正确的构造函数，但是为什么还要给我们这样的警告呢？</p>
<h1 id="使用值传递加移动语义避免不必要的消耗"><a href="#使用值传递加移动语义避免不必要的消耗" class="headerlink" title="使用值传递加移动语义避免不必要的消耗"></a>使用值传递加移动语义避免不必要的消耗</h1><p>我们按照警告更改成后是这样</p>
<pre><code class="cpp">Person(string  name) : m_name(std::move(name)) &#123; &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>你可能会感到疑惑？为什么使用了值传递还会有更高的性能呢？这似乎和直觉不符。</p>
<p>慢慢来，我们一点点分析。</p>
<p>为了测试，我们准备一个类Foo，和一个代理的测试类Test。</p>
<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct Foo &#123;
    Foo() &#123;
//        cout &lt;&lt; &quot;default&quot; &lt;&lt; endl;
    &#125;
    Foo(Foo &amp;&amp;)  noexcept &#123;
        cout &lt;&lt; &quot;&amp;&amp;&quot; &lt;&lt; endl;
    &#125;
    Foo(const Foo &amp; ) &#123;
        cout &lt;&lt; &quot;&amp;&quot; &lt;&lt; endl;
    &#125;
    Foo &amp; operator=(const Foo &amp;) &#123;
        cout &lt;&lt; &quot;operator=(&amp;)&quot;  &lt;&lt; endl;
        return *this;
    &#125;
    Foo &amp; operator=(Foo &amp;&amp; ) noexcept &#123;
        cout &lt;&lt; &quot;operator=(&amp;&amp;)&quot;  &lt;&lt; endl;
        return *this;
    &#125;
    Foo operator+(const Foo &amp;) &#123;
//        cout &lt;&lt; &quot;operator+(&amp;)&quot; &lt;&lt; endl;
        return *this;
    &#125;
&#125;;

struct Test1 &#123;
    Foo m_foo;
    void setFoo(Foo foo) &#123;
        m_foo = std::move(foo);
    &#125;
&#125;;

struct Test2 &#123;
    Foo m_foo;
    void setFoo(const Foo &amp; foo) &#123;
        m_foo = foo;
    &#125;
&#125;;
int main()
&#123;
    Test1 test1;
    Foo foo;
    Foo foo1;
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(foo);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(foo + foo1);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(Foo&#123;&#125;);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(std::move(foo));
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(std::move(Foo&#123;&#125;));
    cout &lt;&lt; &quot;-----\n&quot; &lt;&lt; endl;

    Test2 test2;
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;

    test2.setFoo(foo);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test2.setFoo(foo + foo1);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test2.setFoo(Foo&#123;&#125;);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test2.setFoo(std::move(foo));
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>对于不同的情况，或由不同的结果，C++的特性和复杂性在这里体现的淋漓尽致。</p>
<blockquote>
<p>首先我们应当知道现代C++规定了编译器应当对于返回值进行优化。对于这样的一个函数</p>
<p>X foo() { X x; return x; }</p>
<p>现在的编译器在调用x的时候，就像直接调用构造X::X()一样，不必经过额外的拷贝。对于返回值优化问题，还有一些规则，我打算放在另一篇博客里面说。</p>
<p>详情请见C++标准库(中文第二版)P19,P20,P21</p>
</blockquote>
<p>所以，甚至对于返回值优化的情况，我们也应当考虑进去。比如说对于</p>
<p><code>setFoo(Foo&#123;&#125;)和setFoo(std::move(foo))</code>可能会有和我们预期不符合的结果。</p>
<p>运行结果</p>
<pre><code>-----
&amp;			 //copy ctor
operator=(&amp;&amp;) //move
-----
&amp;			 //这里的copy，是+运算符返回的时候产生的
operator=(&amp;&amp;) //move
-----
operator=(&amp;&amp;) //这里只有一个move而Foo&#123;&#125;没有copy到形参，是编译器优化后的结构
-----
&amp;&amp;		     //使用std::move所以移动构造
operator=(&amp;&amp;) //move
-----
&amp;&amp;            //使用std::move编译器不再优化Foo&#123;&#125;，转而和上种情况一样
operator=(&amp;&amp;) //move
-----

-----
operator=(&amp;)  //按引用传参，ctor
-----
&amp;			 //这里的copy，是+运算符返回的时候产生的
operator=(&amp;)  //ctor
-----
operator=(&amp;)  //编译器优化，只有一个ctor
-----
operator=(&amp;)  //Clang-Tidy：将 std::move() 的结果作为 const 引用参数传递； 实际上不会发生任何动作,所以同上
-----
operator=(&amp;)  //Clang-Tidy：将 std::move() 的结果作为 const 引用参数传递； 实际上不会发生任何动作。同上
-----
</code></pre>
<blockquote>
<p>关于这个问题，Modern Effective C++也有探讨。见条款41。</p>
</blockquote>
<p>这够令人头大了，实际情况可能比我们想象的还要复杂。</p>
<p>但是综上来看，我们不难得出一个结论。如果类型的移动语义具有较低的成本，可以使用pass by value and use std move的这种方式来进行性能优化。</p>
<p>但是，如果类型的移动语义具有一定的消耗，不推荐这样做。就像如果我们处理的是一些短字符串，那么引用方式的传递肯定比值传递+移动这种方式要高效。如果是较长的字符串，使用值传递+引用的方式比较高效。</p>
<p>并且，如果对象支持移动操作，那么他就会移动，如果对象不支持移动操作，那么值传递+引用的方式会copy两次，这是需要注意的。</p>
<p>这些复杂的请况都要”归功“编译器的优化，如果实在搞不明白，那就任他去吧！说实话，作者在这里对于所有的细节也不是全部清晰。那就记住我们上面得出的的结论即可。我们不是编译器的实现者，这些问题无关大雅。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/09/17/pass-by-value-and-use-std-move/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/02/template/">
        <h2 class="post-title">C++模板详解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>模板是一个非常强大的C++功能，STL的各种组件也是基于模板的。所以，无论是写程序了，还是读程序，都有必要了解一下C++的模板。</p>
<p>关于什么是模板或者模板的基本定义，这里就不讲述了，本篇文章主要罗列出在使用模板过程中的一些问题和模板一些令人头疼的语法，并配合简单的demo，如果你只是希望查阅语法或者了解一些知识点，这篇文章可能会帮到你。</p>
<p>声明：使用了using namespace std。对于应该包含进来的头文件，不再显示的声明。文中所有demo均经过测试。本文章基于《C++ Primer Plus》和《C++ Prime》。</p>
<hr>
<h2 id="模板的基本声明和定义"><a href="#模板的基本声明和定义" class="headerlink" title="模板的基本声明和定义"></a>模板的基本声明和定义</h2><h3 id="模板的声明"><a href="#模板的声明" class="headerlink" title="模板的声明"></a>模板的声明</h3><pre><code>template &lt;typename T&gt;  int compare (T t1, T t2);
template &lt;typename T&gt; class compare;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="定义一个模板函数"><a href="#定义一个模板函数" class="headerlink" title="定义一个模板函数"></a>定义一个模板函数</h3><pre><code class="cpp">template &lt;typename T&gt;
int compare(T &amp; t1, T &amp; t2)
&#123;
    if(t1 &gt; t2) 
        return 1;
    if(t1 == t2)
        return 0;
    if(t1 &lt; t2)
        return -1;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="定义一个模板类"><a href="#定义一个模板类" class="headerlink" title="定义一个模板类"></a>定义一个模板类</h3><pre><code class="cpp">template &lt;typename T&gt;
class compare
&#123;
private:
    T _val;
public:
    explicit compare(T &amp; val) : _val(val) &#123; &#125;
    explicit compare(T &amp;&amp; val) : _val(val) &#123; &#125;
    bool operator==(T &amp; t)
    &#123;
        return _val == t;
    &#125;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="模板参数作用域"><a href="#模板参数作用域" class="headerlink" title="模板参数作用域"></a>模板参数作用域</h3><p>就如同其他的函数参数一样，或者是变量一样，就是普通的作用域规则。</p>
<pre><code class="cpp">using T = int;
T a = 10;
template &lt;typename T&gt; class A;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 模板声明里的T不是上面的int而是模板参数。</p>
<pre><code class="cpp">template &lt;typename T&gt; class A
&#123;
    U val; //error
    template&lt;typename U&gt; class B;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="关于模板工作原理"><a href="#关于模板工作原理" class="headerlink" title="关于模板工作原理"></a>关于模板工作原理</h3><blockquote>
<p>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。</p>
<p>模板类在没有调用之前是不会生成代码的。</p>
<p>由于编译器并不会直接编译模板本身，所以模板的定义通常放在头文件中。</p>
</blockquote>
<h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>顾名思义，模板参数不是一个类型而是一个具体的值——这个值是常量表达式。</p>
<p>当一个模板被实例化时，，非类型参数被一个<strong>用户提供</strong>的或者<strong>编译器推断</strong>出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。</p>
<p>有一句话说：C++的强大在于他的编译器强大，下面这个例子就是很好的说明。</p>
<pre><code class="cpp">template &lt;size_t N, size_t M&gt;
int str_compare(const char (&amp;str1)[N], const char (&amp;str2)[M])
&#123;
    return strcmp(str1,str2);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 使用方法</p>
<pre><code class="cpp">str_compare(&quot;hello&quot;,&quot;nihao&quot;)
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>为什么？？？我们甚至没有用&lt;&gt;来传递模板参数。这是因为编译器在编译阶段已经帮助我们计算好了应该开辟多大空间的数组。我们也可以指定长度。N，M只是隐式的传入进去。</p>
<p>编译器也可以自动帮助我们推断参数时什么类型，从而不用显示的调用模板函数，对于上面的compare函数，我们可以这样调用，前提时保证参数类型相同。</p>
<pre><code class="cpp">compare(10,20);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>非类型模板参数的范围</p>
<p>整形，指针或者左值引用都是一个非类型模板参数。</p>
<p>我们可以想到，对于指针或者引用，应当保证实参必须具有静态的生存期，保证其不会被释放。</p>
<h3 id="inline和constexp"><a href="#inline和constexp" class="headerlink" title="inline和constexp"></a>inline和constexp</h3><p>放在模板之后，函数之前即可</p>
<pre><code class="cpp">template &lt;typename T&gt;
inline int compare(T t1, T  t2);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="在模板类中使用模板类"><a href="#在模板类中使用模板类" class="headerlink" title="在模板类中使用模板类"></a>在模板类中使用模板类</h3><p>这个应该很好理解，根据自己的需求，我们可以这样定义</p>
<pre><code class="cpp">template &lt;typename T&gt;
class A
&#123;
private:
    vector&lt;T&gt; vec;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 也可以这样定义</p>
<pre><code class="cpp">template &lt;typename T&gt;
class B
&#123;
private:
    vector&lt;int&gt; vec;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="友元与模板类"><a href="#友元与模板类" class="headerlink" title="友元与模板类"></a>友元与模板类</h3><p>通过上面编译器为模板生成具体代码的原理可以看出这样有什么不同</p>
<pre><code class="cpp">template &lt;typename N&gt;  
class C
  friend A&lt;N&gt;;
  friend B&lt;int&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 由于具体的原理类似宏替换，每个对应的C<N>都有友元A<N>和B<int>、</p>
<p>即有这样友元关系C<int> A<int> B<int>, C<string> A<string> B<string>以此类推。</p>
<p>还有这样的模板友元——所有的实例化都是其友元</p>
<pre><code class="cpp">template &lt;typename N&gt;
class C
    template &lt;typename T&gt; friend class D;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 但是没有这样的写法</p>
<pre><code class="cpp">template &lt;typename T&gt; friend class D&lt;T&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>或者这样的写法</p>
<pre><code class="cpp">template &lt;typename T&gt; friend D&lt;T&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>模板允许模板参数为自己的友元</p>
<p>首先说明，模板允许内置类型为自己的友元。</p>
<pre><code class="cpp">friend int;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样写是完全正确的，但是实际上有什么意义呢？</p>
<p>还是有意义的，我们可以这样写</p>
<pre><code class="cpp">template &lt;typename T&gt;
class People
&#123;
    friend T;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样就保证了在传入内置类型的时候不会有错误。</p>
<h3 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h3><p>用法和函数的默认参数基本相同</p>
<pre><code class="cpp">template &lt;typename T = int&gt; class A;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>默认的情况下T就是int</p>
<pre><code class="cpp">A&lt;&gt; a; // T is int
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="二义性的解决"><a href="#二义性的解决" class="headerlink" title=": : 二义性的解决"></a>: : 二义性的解决</h3><p>对于普通类的:: ，我们可以知道它究竟是一个类还是一个静态成员，就像下面这样。</p>
<pre><code class="cpp">string::size_type a;
string::npos;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>对于模板类来说，我们还是知道表达的是什么，但是已经说过了，模板类在没有 调用之前不会生成代码，这可坏了。对于T::mem，究竟是什么呢？是静态成员？还是一个类型的typedef？</p>
<p>对于这个问题，使用typename修饰。</p>
<p>当我们希望通知编译器一个名字表示一个类型时，使用且必须使用关键字typename，来表示其是一个类型。</p>
<p>于是，我们可以写出这样的代码。</p>
<pre><code class="cpp">template &lt;typename T&gt;
typename T::val_typefunc ();
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>表的不是一个静态数据成员而是一个类型。</p>
<p>或者这样的代码</p>
<pre><code class="cpp">typedef typename T::mem s_type;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>表示s_type是一个类型的别名而不是数据成员的别名。</p>
<p>如果转到string::size_type的定义，可以看见他是一个typename 的 typedef。</p>
<h3 id="类模板成员函数"><a href="#类模板成员函数" class="headerlink" title="类模板成员函数"></a>类模板成员函数</h3><p>本质上就是个函数，只要掌握了模板的工作原理，我们我们就可以轻松的写出类模板成员函数。</p>
<pre><code class="cpp">class Math
&#123;
public:
    template &lt;typename N&gt; inline static  N sqrt(N);
&#125;;

template&lt;typename N&gt;
N Math::sqrt(N val)
&#123;
    return val * val;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>首先来一点一点解析</p>
<p>这是一个模板函数，返回值为N类型，所以，模板语法写在前面，让编译器知道应该返回类型，紧接着就是返回类型，返回类型同上都是写在比较靠前的位置。接着就是函数的标签。</p>
<p>对于定义来说，应该知道是哪个类下的函数，所以和普通的方法一样加上一个作用域即可。</p>
<p>假如把类写成这样呢？</p>
<pre><code class="cpp">template &lt;typename N&gt;
class Math
&#123;
public:
    inline static  N sqrt(N);
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>那方法的定义应该是写成这样的。</p>
<pre><code class="cpp">template&lt;typename N&gt;
N Math&lt;N&gt;::sqrt(N val) 
&#123;
    return val * val;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这里就可以看出</p>
<blockquote>
<p>前面说到的，模板不是一个具体的类，而是根据这个模板编译器生成对应的版本。</p>
<p>对于每一个版本，都是不同的类。就像重载函数一样，即便参数个数和函数的具体算法完全一样，但类型不同他们也是不同的函数，只不过函数名相同而已。</p>
<p>那么就应该可以得到每个版本的类都对应的一个相应版本的静态成员。所以Math<N>::这样写也就很好理解了。</p>
</blockquote>
<h3 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h3><p>我已经不知道用什么语言来下面的代码了。但是我们知道了一些事情。</p>
<p>无论是定义还是声明，模板语法的优先级是最高的，不同模板的优先级又根据其声明顺序来判断，其次是函数修饰，然后是返回值。根据这个原则我们可以轻松的解析这个函数。 </p>
<pre><code class="cpp">template &lt;typename T&gt; class A
&#123;
public:
    template &lt;typename It&gt;  A&lt;T&gt; sum(It _begin, It _end);
&#125;;

template &lt;typename T&gt;        //最外层模板
template &lt;typename It&gt;       //内层模板
A&lt;T&gt;                         //返回值
A&lt;T&gt;::sum(It _begin, It _end)//函数标签 
&#123;&#125;                           //算法实现

//不妨写的更美观一点
template &lt;typename T&gt;
  template &lt;typename It&gt;
  A&lt;T&gt; A&lt;T&gt;::sum(It _begin, It _end)&#123;
      
  &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>注意：上面的代码和下面的代码写的足够复杂，下面的代码对其进行一些小小的修改。 </p>
<p>具体的用法，虽然下面的例子看起来有些造作，但是还是能说明一些问题的</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;
template &lt;typename T&gt; class A
&#123;
private:
    vector&lt;T&gt; vec;
public:
    template &lt;typename It&gt;  T sum(It _begin, It _end);
    A(initializer_list&lt;T&gt; initlist)    
    &#123;
        for(auto it = initlist.begin();it != initlist.end();++it)
        &#123;
            vec.push_back(*it);
        &#125;
    &#125;
    typename vector&lt;T&gt;::iterator begin()
    &#123;
        return vec.begin();
    &#125;
    typename vector&lt;T&gt;::iterator end()
    &#123;
        return vec.end();
    &#125;
&#125;;

template &lt;typename T&gt;
  template &lt;typename It&gt;
  T A&lt;T&gt;::sum(It _begin, It _end)
  &#123;
    T tot ;
    memset(&amp;tot,0,sizeof (T));
    while(_begin != _end)
    &#123;
        tot += *_begin++;
    &#125;
    return tot;
  &#125;


int main()
&#123;
    A&lt;int&gt; a &#123;1,2,3,4&#125;;
    cout &lt;&lt; a.sum(a.begin(),a.end());
    return 0;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 虽然这样的语法很是令人头疼，但是多用即可熟练，或者说使用类型别名来避免这样的问题，并且最好不要把学习精力放在语法上——在没有熟悉语法之前。</p>
<h3 id="实例化优化"><a href="#实例化优化" class="headerlink" title="实例化优化"></a>实例化优化</h3><p>当模板被调用时才会被编译，那么就会存在这样一种情况——<strong>相同地实例化可能出现在多个文件对象中</strong>。当两个或多个独立编译地源文件适用了相同地模板，并提供了相同地模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>为了解决这种问题，我们可以控制显示实例化。具体的做法如下</p>
<p>用关键字extern显示的实例化声明</p>
<pre><code class="cpp">extern template class A&lt;string&gt;;                   //声明
template int compare(const int &amp;, const int &amp;);    //定义
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<blockquote>
<p>将一个实例化声明为extern就表示承诺在程序的其他位置有该实例化的一个非extern声明（定义）。</p>
<p>由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何用此实例化版本的代码之前。 </p>
</blockquote>
<p>解释的来说：因为文件其他处已将有一个实例化——编译器生成好的或者是自己定义的，由于编译单元为.cpp文件，所以在一个文件中实例号的代码并不能用于另一个文件，这就显着很捞。而extern正是解决这个问题的。 </p>
<h2 id="类型转换和参数推断"><a href="#类型转换和参数推断" class="headerlink" title="类型转换和参数推断"></a>类型转换和参数推断</h2><p>与非普通地类型转换一样，模板类在传递模板参数的时候也会进行相应的转换，只不过这种转换增添了更多的规则，参数推断和类型转换的关系是非常紧密的。</p>
<p>类型转换这里的问题如果想要清楚的了解，那恐怕是非常可怕的，我有时候在想，通过这么多的转换规则 ，我们就可见一斑的看出C++的设计是多么的巧妙。虽然这的知识点很乱，但其实只要抓住隐藏在这背后的观念就能清晰的对付各种转换了。</p>
<p>其中一个规则是：如果能够进行安全转换，那么编译器可以隐式转换</p>
<p>最经典的一个例子就是non-const 到const的转换。</p>
<p>为了展示的方便，会忽略掉一些代码</p>
<pre><code class="cpp">template&lt;typename T&gt;
bool func(const T t1, const T t2)
&#123;
    return less&lt;T&gt;()(t1,t2);
&#125;

...

    int a = 10;
    const int b = 20;
    func&lt;int&gt;(a,b);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这里的int转为cosnt int是允许的，因为这是按值传递，并且non-const 转为 cosnt也不会带来什么坏处。因此，编译器会执行这样的转换。</p>
<p>我们不妨修改一下这个函数</p>
<pre><code class="cpp">bool func(const T &amp; t1, const T &amp; t2);
bool func(T &amp; t1, T &amp; t2);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上述第一个声明会正常调用——虽然是引用，和上面的是同样的道理。</p>
<p>而第二个却不会正常调用——因为b是一个cosnt 将要转换为non-const，我中转换是不安全的，所以编译不允许这样的转换。</p>
<p>假设我们这样调用两个函数</p>
<pre><code class="cpp">func&lt;int&gt;(10,20);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>同样的，对于第一个是允许的——虽然讲右值绑定到左值引用上，但是我们用const修饰形参，保证其不会改变，所以编译器同意这样的转换。</p>
<p>而对于第二个，编译器则不允许这样的转换，因为我们的形参是non-const的，不能保证不修改形参的值，形参正好又是一个引用，这样可以修改实参的值——恰好实参是一个右值——是不允许被修改的，所以编译器不允许这样的转换。</p>
<p>基于上面的转换规则，我们可以知道，如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换。</p>
<blockquote>
<p>上面的是C++ Primer的原文，实际上笔者在学习的过程中，发现了其错误。</p>
</blockquote>
<p>先来看一下代码</p>
<pre><code class="cpp">template &lt;typename T&gt; bool func(const T &amp; t1, const T &amp; t2);
...
int a[10];
int b[10];
func(a,b);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样是可以的。那这样呢？</p>
<pre><code class="cpp">template &lt;typename T&gt; T func(const T &amp; t1, const T &amp; t2);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<pre><code class="cpp">template&lt;typename T1, typename T2, typename T3&gt;
T1 sum(T2 t2, T3 t3)
&#123;
    return t2 + t3;
&#125;

...

sum&lt;long long&gt;(10,200); //or sum&lt;long long, int, int&gt;();
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>就不可以了，这个声明对应着C++ Primer的声明。</p>
<p>为什么一样的形参列表只有返回值不同编译器就会发出警告，这是为什么。</p>
<p>其实我们到目前为止的讨论，都适用于普通函数，模板的本质其实也是模板为我们生成对应的版本，为了解开上面的疑惑，我们可以先来复习以下引用的知识。</p>
<pre><code class="cpp">    int *&amp; ref_apple_point = &amp;apple; //error
    int * const &amp; ref_apple_point_const = &amp;apple; //ok
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>根据这两行代码我们可以得到一些启示。</p>
<p>因为数组名是一个常量，const T &amp; t1这样的形参是可以接受的。但对于返回值来说，可就麻烦了。返回值为内置数据类型的模板函数，对于这个问题，这没有什么好说的。返回类型为T的模板函数，他返回的是一个什么具体类型呢？首先T被u推断为* const，那么返回类型也应该是 *const</p>
<p> 在这里我们先留下一个悬念，当我们理解和编译器是如何推断T是何种类型的时候，这个问题可能就会迎刃而解。</p>
<h3 id="返回值类型推断"><a href="#返回值类型推断" class="headerlink" title="返回值类型推断"></a>返回值类型推断</h3><p>在编译器遇见函数列表之前，所有的形参都是不存在的，那么我们需要使用这样的尾置返回类型。</p>
<pre><code class="cpp">auto func(It &amp; _beg, It &amp; _end) -&gt; decltype(*_beg)
&#123;
    //...
    auto sum = *_beg;
    sum = 0;
    for_each(_beg,_end,[&amp;sum](const int &amp; val)&#123; sum+= val;&#125;);
    //...
    return sum;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样的代码还是有一些问题的，如果我们要返回一个拷贝而不是引用呢？要用到一个类型转换模板工具。</p>
<p>remove_reference&lt;&gt;    移除引用——关于其他的类型转换，不再本文章讨论范围内读者可自行查阅。</p>
<p>这个模板类有一个名为type的public成员，能够获得相应的类型。所以我们可以这样写</p>
<pre><code class="cpp">template &lt;typename It&gt;
auto func(It &amp; _beg, It &amp; _end) -&gt; typename remove_reference&lt;decltype(*_beg)&gt;::type //don&#39;t forget typename
&#123;
    //...
    auto sum = *_beg;
    sum = 0;
    for_each(_beg,_end,[&amp;sum](const int &amp; val)&#123; sum+= val;&#125;);
    //...
    return sum;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>在某些情况下我们可以指定返回u类型，例如</p>
<pre><code class="cpp">template&lt;typename T1, typename T2, typename T3&gt;
T1 sum(T2 t2, T3 t3)
&#123;
    return t2 + t3;
&#125;

sum&lt;long long&gt;(10,200); //or sum&lt;long long, int, int&gt;();
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>显示模板参数按从左到右的顺序一次匹配。</p>
<h3 id="兼容类型的模板问题"><a href="#兼容类型的模板问题" class="headerlink" title="兼容类型的模板问题"></a>兼容类型的模板问题</h3><p>有这样的代码</p>
<pre><code class="cpp">template&lt;typename T&gt;
T sum(T t1, T t2)
&#123;
    return t1 + t2;
&#125;

sum(10,3.14);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>虽然int和double兼容，但是只有一个类型参数，编译器傻了，T为int？精度会丢失，肯定是不可行的，T为double?貌似也不行，这样会导致数据溢出。无奈我们只好这样了。</p>
<pre><code class="cpp">template&lt;typename T1， typename T2&gt;
??? sum(T1 t1, T2 t2)
&#123;
    return t1 + t2;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>至于返回类型，全交给程序员来规定，或者用尾部返回类型。</p>
<h3 id="函数指针实参推断"><a href="#函数指针实参推断" class="headerlink" title="函数指针实参推断"></a>函数指针实参推断</h3><p>有趣的是，虽然在未实例化之前，编译器没有生成具体的代码，但我们仍然可以进行函数指针绑定的操作。</p>
<pre><code class="cpp">template &lt;typename T&gt; int compare(const T &amp; t1, const T &amp; t2) &#123; &#125;

int (*pf_int)(const int &amp;,const int &amp;) = compare;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>同样的我们也可以将模板函数作为回调函数进行传参，但此时可能会产生二义性，所以注意显示的写出模板参数。</p>
<blockquote>
<p>当参数是一个函数模板实例的地址时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型的值。</p>
</blockquote>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>这里是重中之重！！！重中之重！！！</p>
<p>很多的模板问题都与此有关。</p>
<p>关于const和&amp;的问题，我们上面已经讲过了。这里再进行进一步的说明。</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><pre><code class="cpp">template &lt;typename T&gt; void func1(T &amp;) &#123; &#125;
template &lt;typename T&gt; void func2(const T &amp;) &#123; &#125;
void aa()
&#123;
    int a = 10;
    const int b = 20;
    func1(a);   //T is int 
    func1(b);      //T is const int
    func2(a);      //T is int
    func2(b);      //T is int
    func2(10);     //T is int 
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>还是比较有意思的，看func2(b)的调用，虽然我们将const int类型传入进去，但是编译器为我们推导的还是int，原因应该和参数类型有关，如果编译器为我们推导的是const int ，那么const const int是不合法的，所以只好为我们推倒为int，即使我们调用时候的类型是const int。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><pre><code class="cpp">template &lt;typename T&gt; void func(T &amp;&amp;);
func(10);         //T is int
func(b);          //b is a left_val T is ???
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>我们可以根据引用折叠可以推断出类型。</p>
<h3 id="引用折叠和万能引用"><a href="#引用折叠和万能引用" class="headerlink" title="引用折叠和万能引用"></a><strong>引用折叠和万能引用</strong></h3><p>众所周知在非模板函数中可以使用const &amp; 来接受任意类型参数，在模板中，也有类似这样的万能引用，就是&amp;&amp;。知道了这样的原因是有着引用折叠得的存在。</p>
<p>先说结论：在传递参数的过程中，无论多么复杂的引用传参，最后都会被折叠为&amp; 或者 &amp;&amp;.</p>
<blockquote>
<p>如果我们间接创建了一个引用的引用，则这些引用形成折叠。除了右值引用的右值引用会被折叠为一个右值引用，剩下全部折叠为一个左值引用。即</p>
<p>T&amp; &amp;, T&amp; &amp;&amp;， T&amp;&amp; &amp;都会折叠为T&amp;</p>
<p>T&amp;&amp; &amp;&amp;会被折叠为&amp;&amp;</p>
</blockquote>
<p>这就意味着我们 可以解释上面的问题。</p>
<p>当我们将一个左值传递给一个右值引时候，编译器推断T的类型为&amp;。注意是T的类型为左值引用，不是整个形参是T &amp;。</p>
<p>所以</p>
<pre><code class="cpp">func(b);          //b is a left_val T is int&amp;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上述的两个规则导致了</p>
<blockquote>
<p>如果一个函数参数是一个指向模板类型参数的右值引用，则他可以被绑定到一个左值。</p>
<p>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数将被参数将被实例化为一个普通左值引用参数。</p>
</blockquote>
<p> 这两个规则又暗示了我们——我们可以将任意类型的实参传递给参数为右值引用的函数。</p>
<p>当代码中涉及的类型可能是非引用类型，也可能是引用类型的时候，编写正确的代码就变得异常困难（虽然remove_reference这样的转换类型对我们可能有所帮助）。</p>
<blockquote>
<p>PS：由于这里的知识是在是很乱，笔者在写这里的时候也实在无能为力，所以大量了引用C++ Primer的原文。但是有一点可以保证——笔者在这里写的demo虽然没有什么实际意义仅用于演示——但是也能说明一些问题。</p>
<p>如果读者对模板的细节想以探究经，可以翻越C++ Primer——中文第五版P508-P610。</p>
<p>如果想巩固这里的语法，可以作相应的配套习题。</p>
</blockquote>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>折磨的篇章终于过去了，让我们用好奇心来看一看std::move这个工具。</p>
<h3 id="短小精悍的std-move定义"><a href="#短小精悍的std-move定义" class="headerlink" title="短小精悍的std::move定义"></a>短小精悍的std::move定义</h3><p>如下</p>
<pre><code class="cpp">template &lt;typename T&gt;
typename remove_reference&lt;T&gt;::type &amp;&amp; move(T &amp;&amp; t)
&#123;
    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); 
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="std-move的解析"><a href="#std-move的解析" class="headerlink" title="std::move的解析"></a>std::move的解析</h3><p>因为move可以接受任意对象，所以应当是一个模板类。</p>
<p>既然我们要保证返回一个右值，那我们应当明确的得到一个非左右值引用类型——即普通类型。</p>
<p>那么就可以先移除引用再加上右值引用——这样保证了返回一个右值引用对应了</p>
<pre><code class="cpp">typename remove_reference&lt;T&gt;::type &amp;&amp;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>既然接受任意一个对象，那美可以用&amp;&amp;来接受实参，对应</p>
<pre><code class="cpp">move(T &amp;&amp; t)
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>我们只需要返回一个右值即可，所以只有一个return语句。</p>
<p>我们回想以下为什么要使用std::move——获得一个右值进行移动构造？又或者是仅仅需要一个右值？不管出于什么原因，最终的目的就是为了优化程序，所以通过形参创建一个额外的右值并返回这样是不可取的，是脱裤子放屁，所以我们要使用这条语句</p>
<pre><code class="cpp">static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>通常情况下，static——cast用于合法的类型转换，但是又一种情况例外，虽然一个左值不能隐式转换为右值，但是可以使用static_cat将其显示的转换为右值——前提我们先移除对象身上的引用效果。</p>
<p>模板和重载</p>
<p>模板也是可以被重载的，只要没有二义性。像在C++库中，存在着大量的模板重载技术，或者是可变模板参数中，也存在着模板的重载。</p>
<p>对于实例化的选择，遵循以下的规则。</p>
<blockquote>
<p>1.对于一个调用，其候选函数是所有可行的实例化</p>
<p>2.可行函数按类型转换来排序。当然，可用于函数模板调用和的类型转换是非常有限的。</p>
<p>3.和普通函数一样，如果恰又一个函数比任何其他函数都更好的匹配，则选择此函数。</p>
<p>4.如果多个函数提供了同样好的匹配</p>
<p>​    1）优先选择非模板函数</p>
<p>​    2）没有非模板函数我选择更加特例化的模板</p>
<p>​    3）否则有二意性</p>
<p>正确的定义一组重载的函数模板需要对类型键的关系以及模板幻术允许的优先的实参类型转换有着深刻的理解。</p>
<p>注意：虽然非模板函数的优先级很高——但那也是没有对应模板匹配的情况下，所以，在重载模板的时候仔细观察和思考。</p>
</blockquote>
<p>所以我们为了适配字符串的比较，可以写出这样的代码</p>
<pre><code class="cpp">template&lt;size_t N, size_t M&gt;
int compare(const char str1[N], const char str2[M])
&#123;
    return strcmp(str1,str2);
&#125;
//或者
int compare(const char * const str1, const char * const str2)
&#123;
    return strcmp(str1,str2);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 根据上面的匹配规则，我们还可以递归的调用模板类自己实现某些功能</p>
<pre><code class="cpp">template&lt;typename T&gt; string debug_rep(const T &amp; t)
&#123;
    ostringstream ret;
    ret &lt;&lt; t ;
    return ret.str();
&#125;

template&lt;typename T&gt; string debug_rep(const T * p)
&#123;
    ostringstream ret;
    ret &lt;&lt; &quot;pointer :&quot; &lt;&lt; p;
    if(p != nullptr)
        ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);
    else
        ret &lt;&lt; &quot; nullptr&quot;;
    return ret.str();
&#125;

//适配C风格字符串
string debug_reo(char * p)
&#123;
    return debug_rep(string(p));    //这是一个右值，不能获取其地址
&#125;

string debug_rep(const char * p)
&#123;
    return debug_rep(string(p));
&#125;

int main()
&#123;
    string s(&quot;hello&quot;);
    string* ps = &amp;s;
    cout &lt;&lt; debug_rep(ps) &lt;&lt; endl &lt;&lt; debug_rep(s);
    return 0;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>运行结果</p>
<p><img src="https://img-blog.csdnimg.cn/d552c7ad9be5484282089868bd42fd4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX19KQU5fXw==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<h3 id="模板函数匹配的特殊性"><a href="#模板函数匹配的特殊性" class="headerlink" title="模板函数匹配的特殊性"></a>模板函数匹配的特殊性</h3><p>难道没有发现一个异常的地方吗？对于指针版本的调用，可以这样实例化两个函数</p>
<pre><code class="cpp">string debug_rep(const string* &amp; t);
string debug_rep(string * p);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 对于普通函数，这是无疑的二义性，但是模板会选择特例化高的，原因是const T&amp;可以实例化任何类型，而const T * p只能实例化指针类型——特例化程度更高。所以会调用后者。</p>
<p>这就说明了：不要将普通函数的匹配机制应用于模板函数匹配机制——虽然两者很像，但是还是有某些地方是不一样的。</p>
<h3 id="注意重载模板声明顺序"><a href="#注意重载模板声明顺序" class="headerlink" title="注意重载模板声明顺序"></a>注意重载模板声明顺序</h3><p>由于模板的特性，使得其可以递归的调用自己的不同版本，但是注意要调用的版本一定要事先声明或者定义，否则可能出现函数不匹配的情况</p>
<p>我们把适配char * 接口的字符串的函数放到最前面，我们发现编译器会右值河阳的错误。</p>
<blockquote>
<p>No matching function for call to ‘debug_rep’</p>
<p>调用“debug_rep”没有匹配的函数 </p>
</blockquote>
<p>或者我们将两个debug_rep的模板版本调换以下顺序。 </p>
<blockquote>
<p>Call to function ‘debug_rep’ that is neither visible in the template definition nor found by argument-dependent lookup</p>
<p>调用函数“debug_rep”，该函数在模板定义中既不可见，也不通过参数相关查找找到</p>
</blockquote>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><p>我们编写的模板，不可能保证对于所有的类型都能适用——compare函数就是很经典的例子，对于两个指针类型，仅仅是毫无意义的比较。这时候我们用到模板特例化的技术可以很好的解决这样的问题。</p>
<p>由于less的底层是使用&lt;来比较的，所以less并没有适配字符指针。那么，我们可以编写这样的模板特例化。</p>
<pre><code class="cpp">template &lt;&gt;        //表示一个模板特例化——语法规定
int compare(const char * const &amp; str1, const char * const &amp; str2) //具体的类型
&#123;
    return strcmp(str1,str2);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>可以看出，模板特例化的尖括号中没有任何说明，所以模板特例化要对所有模板那参数都进行特例化。 </p>
<p>注意，上面的特例化只能处理字符指针，不能处理数组或者字符串面量——这和函数匹配机制有关。这个特例化仅仅接受char*以及其const版本，虽然字符数组的名字就是他的地址，但是在模板中会被解释为一个字符数组的引用，更加的精准匹配。如果想要支持字符面量（本质上是字符数组）和字符数组，请写一个重载的模板函数——见模板重载。</p>
<p>我们可以使用调试观察是如何推断实参类型的</p>
<p><img src="https://img-blog.csdnimg.cn/cac84050194042999a46dff60b811f6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX19KQU5fXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<p>推断为一个数组的引用——这显然比将数组转换为指针再进行匹配更加精确。</p>
<h3 id="特例化和重载-的区别"><a href="#特例化和重载-的区别" class="headerlink" title="特例化和重载 的区别"></a>特例化和重载 的区别</h3><p>特例化就是一个特殊的实例化——模板的实例化，所以，特例化仅仅是模板的一个实例化，不会影响函数匹配。 </p>
<p>并且，模板特例化一定要保证模板的之前的声明或者定义。如果不这样做——编译器不会报错，但是会有一些令人匪夷所思的地方。模板会由编译器实例化，而不是调用自己特例化版本——这种错误往往很难查找。所以，记住一个规则：特例化一个模板，一定要保证其在原模板的定义域中。</p>
<h3 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h3><p> 这里引用《C++ Primer》的例子——对其做一些解析。</p>
<p>hash容器是能够进行十分快速的查找容器，像hash_map, hash_set等。他们的底层使用什么来映射哈希值呢? hash模板类。<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/functional/hash/?kw=hash">hash - C++ Reference (cplusplus.com)</a></p>
<p>那么对于我们自定义的类型来说，没有其对应算法，为了能够使用我们的自定义类型，我们可以定义一个其特例化版本。</p>
<p> 一个hash的特例化必须包括</p>
<blockquote>
<p>一个重载的调用运算符，接受一个容器关键字类型的对象，返回一个size_t——用于映射对象的哈希值。</p>
<p>两个类型成员，result_type, argument_type，分别调用运算符返回类型和参数类型。</p>
<p>默认构造函数和拷贝赋值运算符。</p>
</blockquote>
<p>于是我们可以写出如下的代码。</p>
<pre><code class="cpp">class Book
&#123;
    friend class std::hash&lt;Book&gt;;    //hash使用了私有成员，所以将其声明为友元
private:
    int book_id;
    string book_name;
public:
    Book() = default;
    Book(const int a, const string &amp; _name) : book_id(a), book_name(_name) &#123; &#125;
    bool operator==(const Book &amp; b) const
    &#123;
        return book_id == b.book_id;
    &#125;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 我们首先定义一个Book类，然后提供其&#x3D;&#x3D;运算符确保hash模板能够自持我们的自定义类型。</p>
<p>随后我们在std命名空间中特例化一个和hash，</p>
<pre><code class="cpp">namespace std
&#123;
    template &lt;&gt;
    struct hash&lt;Book&gt;
    &#123;
        //必须提供的成员
        typedef size_t result_type;
        typedef Book argument_type;
        size_t operator()(const Book &amp; b) const;
    &#125;;
    size_t
    hash&lt;Book&gt;::operator()(const Book &amp;b) const &#123;
        //自定义如何组织hash_val
        return hash&lt;string&gt;()(b.book_name) ^ hash&lt;int&gt;()(b.book_id);
    &#125;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>之后，我们就可以使用unordered_set&#x2F;map，来操纵我们的自定义类型了。 </p>
<p>为了能够让自定义数据类型的特例化能够被正常使用，应该将其放在类声明对应的头文件中，或者用别的头文件将其包含进来。</p>
<h3 id="部分模板特例化"><a href="#部分模板特例化" class="headerlink" title="部分模板特例化"></a>部分模板特例化</h3><p>我们可以指定<strong>一部分而非所有的模板参数，或者是参数的一部分而非全部特性</strong>。一个模板的部分特例化本身是一个模板，使用它时用户还必须为哪些在特例化版本呢中未指定的模板参数提供实参。</p>
<p>部分特例化一部分模板参数特例化，没有特例化的部分额外的提供实参。</p>
<p>标准库的remove_reference 就是使用一系列的特例化完成其功能的，我们将其转到定义。</p>
<p>这里部分特例化的时参数的引用性质。</p>
<pre><code class="cpp">  template&lt;typename _Tp&gt;
    struct remove_reference
    &#123; typedef _Tp   type; &#125;;

  template&lt;typename _Tp&gt;
    struct remove_reference&lt;_Tp&amp;&gt;
    &#123; typedef _Tp   type; &#125;;

  template&lt;typename _Tp&gt;
    struct remove_reference&lt;_Tp&amp;&amp;&gt;
    &#123; typedef _Tp   type; &#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 具体的语法：</p>
<p>在正常的模板声明之后，在类的后面使用尖括号&lt;&gt;放入要特例化的实参，这些实参于原始模板中的参数按照位置对应。也就是对应着上面源码中的</p>
<pre><code class="cpp">struct remove_reference&lt;_Tp&amp;&amp;&gt;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<blockquote>
<p>注意：模板部分特例化并不是对于某个单单的模板参数特例化，也可能是模板参数属性的特例化，这点对于理解类模板部分特例化十分重要</p>
<p>注意：我们只能部分特例化类模板，而不能部分特例化模板函数。 </p>
</blockquote>
<p>例如我们定义一个泛用的模板类和实例化一个其专门用来处理指针的类</p>
<pre><code class="cpp">template &lt;typename T&gt;
class A;

template &lt;typename T&gt;
class A&lt;T *&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="特例化成员"><a href="#特例化成员" class="headerlink" title="特例化成员"></a>特例化成员</h3><p>我们可以只特例化特定的成员函数而不是特例化整个模板类。</p>
<pre><code class="cpp">template &lt;typename T&gt;
class A
&#123;
private:
    T val;
public:
    A(const T &amp; t) : val(t) &#123; &#125;
    void func();
&#125;;

template&lt;&gt;
void A&lt;int&gt;::func()
&#123; &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 那我们这样得到的就是对于A<int>的实例化下的一个特例化func——这个func只在int的实例化版本生效。也就是说，实例化int版本的A其对应的func是我们特例化的这个版本，而其他成员还是正常的实例化。</p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>声明：关于模板的递归调用，都有一个基线函数，只不过是没有写出。</p>
<p>关于可变参数模板，一部分引用我之前的文章，再在这里做一些补充</p>
<blockquote>
<p><strong>可变模板参数</strong> <em>variadic template</em></p>
<p><strong>包</strong>          <em>packet</em></p>
<p><strong>模板参数包</strong>   <em>template parameter packet</em></p>
<p><strong>函数参数包</strong>   <em>function paremeter packet</em> </p>
</blockquote>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/JAN6055/article/details/122818685?spm=1001.2014.3001.5501">C++——C++11的标准（下）___JAN__的博客-CSDN博客<img src="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" alt=" ">https://blog.csdn.net/JAN6055/article/details/122818685?spm=1001.2014.3001.5501</a></p>
<p>详情见这篇文章的可变模板参数。 </p>
<p><strong>补充：</strong></p>
<p><strong>sizeof…运算符</strong></p>
<p>能够获得包中参数的个数</p>
<pre><code class="cpp">template&lt;typename T, typename... Args&gt;
void var_fun(const T &amp; t, const Args&amp;... args)
&#123;
    //cout &lt;&lt; t;
    cout &lt;&lt; &quot;element numbers of packs is &quot; &lt;&lt; sizeof...(Args);
    //var_fun(args...);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>包拓展</strong></p>
<blockquote>
<p><strong>拓展</strong>    <em>packs expand</em></p>
<p>包拓展简单的来说将他分解为其构成的元素，如果说将参数变为包的过成类比为压缩未见，那么包拓展就是解压文件，但包拓展不仅仅是包展开。</p>
</blockquote>
<p>当拓展一个包时，我们还要提供用于，每个拓展元素的<strong>模式</strong>。拓展一个包就是将它费解为构成的原书，对每个元素应用模式，获得拓展后的列表。我们通过在模式右边防一个省略号…来触发拓展操作 。</p>
<blockquote>
<p>什么是模式？</p>
<p>在实际生活中，当我们说以一种模式打开某个东西，或者是什么模式打开时。指定的是固有的模式，比如说性能模式，均衡模式等。而抱拓展的模式更像是对于每个元素都调用一次相应的函数，包拓展需要我们自定义模式——其实就是一个函数，返回值为包中的一个元素应用模式后的结果，所有这样的结果组合在一起，也就是包以这个模式（函数）展开。</p>
</blockquote>
<p>看一下标准库的配置器中是如何使用的展开</p>
<pre><code class="cpp">noexcept(noexcept(::new((void *)__p)
                _Up(std::forward&lt;_Args&gt;(__args)...)))
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这是一个函数异常声明的部分，当用一个包构造一个元素的时候不会抛出异常，仅当，使用转发模式对参数包进行展开的时候不抛出异常。</p>
<pre><code class="cpp">    var_func(args...);      //默认的包展开
    //注释部分的...不为关键字，和C++语法没有任何关系
    //相当于这样&#123;ele1, ele2, ele3, ... ,elen&#125;
    var_fun(mul(2,args)...);    //带有模式的包展开
    //第二种展开模式相当于这样
    //&#123; mul(2,ele0),mul(2,ele1),mul(2,ele2), ... mul(2,elen) &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>具体实验</p>
<pre><code class="cpp">template &lt;typename T&gt;
void print(const T &amp; t)
&#123;
  cout &lt;&lt; t &lt;&lt; endl;
&#125;
template &lt;typename T, typename... Args&gt;
void print(const T &amp;t ,const Args... args)
&#123;
  cout &lt;&lt; t &lt;&lt; endl;
  print(args...);
&#125;

template &lt;typename T&gt;
int up(T &amp; t)
&#123;
  t *= 2;
  return t;
&#125;
template &lt;typename... Args&gt;
void func(Args&amp;&amp;... args)
&#123;
  print(up(args)...);
&#125;

int main()
&#123;
  func(1,2,3,4,5);
  return 0;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 运行结果</p>
<p><img src="https://img-blog.csdnimg.cn/07fd5425aa89414d88e86c521823742e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<h3 id="可变模板参数的具体作用"><a href="#可变模板参数的具体作用" class="headerlink" title="可变模板参数的具体作用"></a>可变模板参数的具体作用</h3><p>可变模板参数可以说是一个核弹，比如tuple就是使用其实现的，模板类tuple以私有继承的方式继承它自己并结合模板部分特例化。如下</p>
<pre><code class="cpp">template&lt;typename T, typename ... Args&gt;
class tuple&lt;T,Args...&gt; : private tuple&lt;Args...&gt;
&#123;
    //something
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 还是很奇妙的，具体详情请观看侯捷老师的视频——bilibili ： <img src="https://img-blog.csdnimg.cn/d4465dc3a3e84b0ba1857922cf22379d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX19KQU5fXw==,size_13,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<h2 id="模板技巧"><a href="#模板技巧" class="headerlink" title="模板技巧"></a>模板技巧</h2><p>模板的功能还是很强大的，我们有必要学习一些模板技巧。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><blockquote>
<p> 什么是转发？</p>
<p>某些函数需要将其一个或多个实参连<strong>同类型不变的****传递</strong>给其他函数。这个过程就叫<strong>转发。</strong></p>
<p>很形象，一个函数把数据原封不动的传递给另一个函数，就是转发。</p>
</blockquote>
<p>什么时候会用到转发呢？比如说我们有这样的一个函数，在容器尾部直接使用我们穿进来的参数构造一个元素，这个时候使用转发就是很有必要的。如果我们不适用转发技术，可能会造成变量的复制，也许有的时候这个函数能正常使用，但是有的时候我们就需要引用来做事，所以这样做留下的错误的隐患。 </p>
<p>假设有func1(int &amp;，args) fun2 work(args，int&amp;);</p>
<p>我们需要传进func1一个整形，经过func2的中间媒介，传入work，并在work中改变那个变量。</p>
<p>读者可以试一下func2中使用什么样的参数，经过怎样的变换可以对原来的参数的性质原封不动的传递给work。这是比较简单的情况了。STL的部分函数实现会有恐怖的调用层次，如果不使用转发技术后果可想而知。</p>
<h3 id="使用std-forward"><a href="#使用std-forward" class="headerlink" title="使用std::forward"></a>使用std::forward</h3><p>要说转发一定离不开std::forward</p>
<p>forward返回实参类型的右值引用。它和move很像，但前者是返回给定类型的右值引用，如果给定的类型是左值引用也返回其右值引用——左值引用，并且其必须显式的指定模板参数；而move无论模板参数类型是什么都返回一个右值引用（只能是右值引用），因为前面已经看到了move的实现方法。</p>
<p>于是我们可以定义下面的转发函数    </p>
<pre><code class="cpp">template &lt;typename F, typename T1, typename T2&gt;
void fun(F f, T1 &amp;&amp; t1, T2 &amp;&amp; t2)
&#123;
    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>使用右值引用作为模板参数——确保接受任意对象，并保证其能保持原来的性质不变（见引用折叠）。在发送参数的过程中获得对应类型的右值——确保其传递给函数的参数的性质不变（见引用折叠）。</p>
<p>更简单的来说，上述的写法是对于所有类型的对象，无论进行何种参数传递，其参数的性质都不会改变的通用情况。</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><p>根据上面转发的关键字，我们可以知道，在进行转发的时候应该以何种模式进行包展开。</p>
<pre><code>(Args&amp;&amp; ... args) //以右值引用展开参数包
std::forward&lt;Args&gt;(args)... //将包中的每一个元素应用于forward
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 所以我们可以这样做</p>
<pre><code class="cpp">template&lt;typename ... Args&gt;
void buffer_fun(Args &amp;&amp;... args)
&#123;
    work(std::forward&lt;Args&gt;(args)...);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="make-shared的工作原理"><a href="#make-shared的工作原理" class="headerlink" title="make_shared的工作原理"></a>make_shared的工作原理</h3><p>std::make_shred就是基于转发参数包实现的。</p>
<p>让我们先来回忆make_shared的其中一个使用方法。</p>
<p>make_shared<T> name (args);</p>
<p>很明显的可以推断其应该使用用可变模板参数，我们转到其定义</p>
<pre><code class="cpp">  template&lt;typename _Tp, typename... _Args&gt;
    inline shared_ptr&lt;_Tp&gt;
    make_shared(_Args&amp;&amp;... __args)
    &#123;
      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;
      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),
                       std::forward&lt;_Args&gt;(__args)...);
    &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>可以看见，其使用部分特例化和可变参数模板，将包转发给了std::allocate_shared进行空间分配，我们进一步的转到std::allocate_shared中可以看见其有进一步的将其转发给了其他的模板</p>
<pre><code class="cpp">  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;
    inline shared_ptr&lt;_Tp&gt;
    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)
    &#123;
      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);

      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;&#123;__a&#125;,
                 std::forward&lt;_Args&gt;(__args)...);
    &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<hr>
<p>至此，C++的模板的基础知识点大抵应该是都讲完了，如果日后有一些杂项补充的话会更在下面。</p>
<blockquote>
<p>后来的话: 这篇文章有一些地方讲的还是比较不清晰的，现在已经修正了一部分，并且增添了对一部分知识点的代码，日后也会慢慢修改。如果你发现本篇文章的错误或者对本篇文章有什么建议可以评论区留言或者私信笔者。</p>
<p>​                                                            ——2022.6.1</p>
</blockquote>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/09/02/template/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
    </div>
    <div class="next">
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src=" " alt="avatar">
        </div>
        <div class="name">
            Jan6055
        </div>
        <div class="descriptions">
            
            <div class="description">
                Description...
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/jan6055">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Jan6055的Blog
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Jan6055
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>