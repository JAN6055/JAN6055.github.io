
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hello @You</title>
        <meta name="author" content="Jan6055">
        <meta name="description" content="">
        <meta name="keywords" content="C++,Rust,Jan6055">
        <link rel="icon" href="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hello @you</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hello @you</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(http://p6.qhimg.com/bdr/__85/t015c7bbab0a42e2cf9.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Hello @you</h1>
                <h3>enjoy coding</h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/10/22/Qt-2D绘图/">
        <h2 class="post-title">Qt-2D绘图</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/22
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="为什么需要2D绘图"><a href="#为什么需要2D绘图" class="headerlink" title="为什么需要2D绘图"></a>为什么需要2D绘图</h1><p>Qt虽然为我们提供了强大的开发类库。但是对于复杂的GUI界面。我们还需要定制自己的界面样式。例如代码编辑器中的左侧行号，就需要我们自己绘制。</p>
<h1 id="2D绘图的基本架构"><a href="#2D绘图的基本架构" class="headerlink" title="2D绘图的基本架构"></a>2D绘图的基本架构</h1><ul>
<li><code>QPainter</code>用来执行绘图操作</li>
<li><code>QPainterDevice</code>一个可绘制的设备，相当于画布一样，提供了一个二维空间的抽象，是所有可绘制设备的基类</li>
<li><code>QPaintEngine</code>提供一些接口用于<code>QPinter</code>和<code>QPainterDevive</code>内部。使得<code>QPainter</code>可在不同的设备上进行绘制，相当于一个适配器一样。</li>
<li>我们可以重写<code>paintEvent</code>函数来进行自己的绘制。</li>
</ul>
<h1 id="使用画家"><a href="#使用画家" class="headerlink" title="使用画家"></a>使用画家</h1><pre><code class="C++">void MainWindow::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);
    painter.drawLine(10,10,100,100);
    painter.drawLine(QPoint(0,0),QPoint(width(),height()));
    painter.drawRect(0,0,50,50);
    painter.drawRoundedRect(20,20,80,80,10,10);
&#125;
</code></pre>
<p>我们可以使用画笔画点，线，面等。还可以画一些其他的集合形状。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20221022101806985.png" alt="image-20221022101806985"></p>
<h1 id="使用画笔"><a href="#使用画笔" class="headerlink" title="使用画笔"></a>使用画笔</h1><p>我们可以为画家提供画笔。比如笔的粗细，线条的风格，颜色等等。</p>
<pre><code class="C++">    QPen pen(Qt::green,4);
    painter.setPen(pen);
</code></pre>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20221022102205538.png" alt="image-20221022102205538"></p>
<p>我们还可以为笔提供其他的不同属性。详细信息请查看Qt帮助文档，官方文档有很好的解释。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qpen.html">QPen Class | Qt GUI 6.4.0</a></p>
<h1 id="使用画刷"><a href="#使用画刷" class="headerlink" title="使用画刷"></a>使用画刷</h1><p>使用画刷来填充区域。同画笔一样，画刷也有自己的属性。</p>
<pre><code class="C++">void MainWindow::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);
    QPen pen(Qt::green,2);
    painter.setPen(pen);
    QRect rect(50,50,400,400);
    QBrush brush(Qt::blue);
    painter.setBrush(brush);
    painter.drawRect(rect);

    brush.setColor(QColor(52,66,35));
    painter.setBrush(brush);
    painter.drawEllipse(220,20,50,50);
&#125;
</code></pre>
<p>使用画刷可以对画出的图形进行填充。如果没有指定画刷，那么画出的图形将不会被填充。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20221022103200127.png" alt="image-20221022103200127"></p>
<p>我们还可以使用画刷绘制纹理。</p>
<pre><code class="C++">void MainWindow::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);
    QPen pen(Qt::green,2);
    painter.setPen(pen);
    QBrush brush(Qt::blue);
    QPixmap p (&quot;C:\\Users\\wangq\\Pictures\\Screenshots\\屏幕截图_20221022_103721&quot;);
    brush.setTexture(p);
    QRect rect(0,0,p.width(),p.height());
    painter.setBrush(brush);
    painter.drawRect(rect);
&#125;
</code></pre>
<p>为了方便，我们随手截取一个图片，不用qrc文件，直接读取C盘下的文件。最终的显示效果是这样的。</p>
<p>纹理和图片还是有不同的。为了方便这里就这样做的。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20221022104125514.png" alt="image-20221022104125514"></p>
<p>画刷提供一些风格，可以查阅Qt文档来查看。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbrush.html#details">QBrush Class | Qt GUI 6.4.0</a></p>
<h1 id="一些便捷的方法"><a href="#一些便捷的方法" class="headerlink" title="一些便捷的方法"></a>一些便捷的方法</h1><p>如果想要绘制一个矩形区域为一个颜色。我们可以把画笔和画刷设置为一样的颜色。</p>
<h2 id="fillRect-x2F-eraseRect"><a href="#fillRect-x2F-eraseRect" class="headerlink" title="fillRect&#x2F;eraseRect"></a>fillRect&#x2F;eraseRect</h2><p>实际上这样做有些麻烦，我们可以使用<code>fillRect</code>函数含填充一个矩形区域,使用<code>eraseRect</code>来擦除一个矩形区域内的内容。</p>
<pre><code class="C++">void MainWindow::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);
    painter.fillRect(0,0,20,this-&gt;height(),QBrush(Qt::darkGray));
    //擦除一部分区域
    painter.eraseRect(10,0,10,this-&gt;height()/2);
&#125;
</code></pre>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20221022104846786.png" alt="image-20221022104846786"></p>
<h1 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h1><p>抗锯齿又被称为反锯齿或者反走样，就是对图形的边缘惊醒平滑处理。在游戏中有广泛的应用。</p>
<p><code>QPainter</code>在进行绘制的时候可以使用<code>QPainter::RenderHint</code>渲染提示来指定是否要使用抗锯齿功能。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>QPainter::Antialiasing</code></td>
<td>指示绘图引擎在可能的情况下应该进行边缘的抗锯齿</td>
</tr>
<tr>
<td><code>QPainter::TextAntialiasing</code></td>
<td>指示绘图引擎在可能的情况下应该绘制抗锯齿的文字</td>
</tr>
<tr>
<td><code>QPainter::SmoothPixmapTransform</code></td>
<td>指示绘图引擎应该使用一个平滑pixmap转换算法(比如双线性插值)而不是最邻近插值算法</td>
</tr>
</tbody></table>
<p>我们可以看见最开始的画图结果，线条有很强的锯齿感。</p>
<p>我么对其进行抗锯齿操作。</p>
<pre><code class="C++">painter.setRenderHint(QPainter::Antialiasing);
</code></pre>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20221022112302663.png" alt="image-20221022112302663"></p>
<p>我们可以很明显的看见抗锯齿之后的效果明显平滑了许多。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/GUI/" style="color: #00a596">
                GUI
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Qt/" style="color: #ff7d73">
                Qt
            </a>
        </span>
        
    </div>
    <a href="/2022/10/22/Qt-2D绘图/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/20/正则表达式/">
        <h2 class="post-title">正则表达式</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/20
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>限定符应用于限定符前的字符。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>出现1次或者0次</td>
</tr>
<tr>
<td>*</td>
<td>出现任意多次</td>
</tr>
<tr>
<td>+</td>
<td>出现任意多次，但不是0次</td>
</tr>
<tr>
<td>{x}</td>
<td>出现x次</td>
</tr>
<tr>
<td>{x,y}</td>
<td>出现[x,y]次</td>
</tr>
<tr>
<td>{x,}</td>
<td>出现x次或x次以上</td>
</tr>
</tbody></table>
<p>匹配多个字符</p>
<p>使用<code>()</code>将需要匹配的多个字符括起来</p>
<p>运算符</p>
<table>
<thead>
<tr>
<th>OP</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>str1|str2</td>
<td>str1或者str2</td>
</tr>
</tbody></table>
<p>元字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>数字字符</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符</td>
</tr>
<tr>
<td>\w</td>
<td>单词字符(所有的英文字符+数字+下划线)</td>
</tr>
<tr>
<td>\W</td>
<td>非单词字符</td>
</tr>
<tr>
<td>\s</td>
<td>空白字符(包括空格+制表+换行)</td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符</td>
</tr>
<tr>
<td>.</td>
<td>任意字符，但不包含换行符</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾</td>
</tr>
</tbody></table>
<p>可以使用<code>\</code>来进行转意。例如匹配<code>&quot;\d&quot;</code>使用<code>\\d</code>。匹配<code>&quot;.&quot;</code>使用<code>\.</code>。</p>
<h1 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h1><p>正则表达式默认是贪婪匹配，会匹配尽可能多的字符</p>
<p>我们可以使用？改为懒惰匹配，匹配尽可能少的字符。</p>
<p>例如我们要匹配<code>&lt;span&gt;&lt;b&gt; This is a text&lt;\b&gt;&lt;\span&gt;</code>中html的标签。</p>
<p>使用:<code>&lt;.+?&gt;</code></p>
<p>示例</p>
<h2 id="RGB匹配"><a href="#RGB匹配" class="headerlink" title="RGB匹配"></a>RGB匹配</h2><p><code>#[a-fA-F0-9]&#123;6&#125;\b</code></p>
<h2 id="IPV4地址匹配"><a href="#IPV4地址匹配" class="headerlink" title="IPV4地址匹配"></a>IPV4地址匹配</h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/正则表达式/" style="color: #03a9f4">
                正则表达式
            </a>
        </span>
        
    </div>
    <a href="/2022/10/20/正则表达式/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/15/x64-asm调用约定/">
        <h2 class="post-title">X64-Asm调用约定</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/15
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="API与ABI"><a href="#API与ABI" class="headerlink" title="API与ABI"></a>API与ABI</h1><p>API：<strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface，又称为<strong>应用编程接口</strong>，就是软件系统不同组成部分调用的约定。</p>
<p>ABI：<strong>A</strong>pplication <strong>B</strong>inary <strong>I</strong>nterface,<strong>又称应用二进制接口</strong>，就是软件系统不同组成部分间机器代码的调用约定。</p>
<p>比如我们书写C的时候。反转一个字符串可以是这样的签名<code>void reverse(char *, int len)</code>。只要遵循调用的约定，就能完成相应的任务。</p>
<p>ABI则是相较于底层机器代码而言。我们也可以按照一套规范来约定函数的调用时参数时如何传递。</p>
<h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><table>
<thead>
<tr>
<th>寄存器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>rdi</td>
<td>第一个参数</td>
</tr>
<tr>
<td>rsi</td>
<td>第二个参数</td>
</tr>
<tr>
<td>rdx</td>
<td>第三个参数</td>
</tr>
<tr>
<td>rcx</td>
<td>第四个参数</td>
</tr>
<tr>
<td>r8</td>
<td>第五个参数</td>
</tr>
<tr>
<td>r9</td>
<td>第六个参数</td>
</tr>
</tbody></table>
<p>对于更多的参数，就用栈来传递。假设我们要传递10个参数</p>
<table>
<thead>
<tr>
<th>栈操作</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>push data</td>
<td>第10个参数</td>
</tr>
<tr>
<td>push data</td>
<td>第9个参数</td>
</tr>
<tr>
<td>push data</td>
<td>第8个参数</td>
</tr>
<tr>
<td>push data</td>
<td>第7个参数</td>
</tr>
</tbody></table>
<p>因为栈是后进后出的，所以压栈的时候参数要反向压栈。在出栈的时候才能得到正确的顺序。只需要不断的出栈就可以获得第7-10个参数。</p>
<p>但是因为函数调用的原因，rsp会被压栈。再考虑到函数的序言，以对齐等情况。实际上在栈中的参数，并不能直接使用，需要跳过一些字节。我们下面的代码又展示。</p>
<h1 id="浮点数调用约定"><a href="#浮点数调用约定" class="headerlink" title="浮点数调用约定"></a>浮点数调用约定</h1><p>使用xmm寄存器来传递浮点数。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>xmm0</td>
<td>第一个参数</td>
</tr>
<tr>
<td>xmm1</td>
<td>第二个参数</td>
</tr>
<tr>
<td>xmm2</td>
<td>第三个参数</td>
</tr>
<tr>
<td>xmm3</td>
<td>第四个参数</td>
</tr>
<tr>
<td>xmm4</td>
<td>第五个参数</td>
</tr>
<tr>
<td>xmm5</td>
<td>第六个参数</td>
</tr>
<tr>
<td>xmm6</td>
<td>第七个参数</td>
</tr>
<tr>
<td>xmm7</td>
<td>第八个参数</td>
</tr>
</tbody></table>
<p>对于多的参数传递，不是用过栈来完成，巫妖使用SIMD来实现。本篇不讨论。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>rax&#x2F;xmm0用来保存返回值</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="assembly">extern printf
section .data
        first   db &quot;A&quot;,0
        second  db &quot;B&quot;,0
        third   db &quot;C&quot;,0
        fourth  db &quot;D&quot;,0
        fifth   db &quot;E&quot;,0
        sixth   db &quot;F&quot;,0
        seventh db &quot;G&quot;,0
        eighth  db &quot;H&quot;,0
        ninth   db &quot;I&quot;,0
        tenth   db &quot;G&quot;,0
        fmt1    db &quot;The String is: %s%s%s%s%s%s%s%s%s%s&quot;,10,0
        fmt2    db &quot;PI = %f&quot;,10,0
        pi              dq 3.14
section .bss
section .text
        global main
main:
        push rbp
        mov rbp, rsp

        mov rdi, fmt1
        mov rsi, first
        mov rdx, second
        mov rcx, third
        mov r8,  fourth
        mov r9,  fifth
        push tenth
        push ninth
        push eighth
        push seventh
        push sixth

        mov rax, 0
        ;此时栈没有对齐，但是我们没有使用xmm，所以不会发生错误
        call printf

        and rsp, 0xfffffffffffffff0 ;使用and，最低4位为0，其余位不变
        movsd xmm0, [pi]
        mov rdi, fmt2
        mov rax, 1
        call printf

        leave
        ret
</code></pre>
<p>2</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #ff7d73">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ffa2c4">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/15/x64-asm调用约定/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/15/x64-asm外部函数/">
        <h2 class="post-title">X64-Asm外部函数</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/15
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="函数和变量的可见性"><a href="#函数和变量的可见性" class="headerlink" title="函数和变量的可见性"></a>函数和变量的可见性</h1><p>我们在写单文件的时候会将main声明为<code>glabal</code>。这表示<code>main</code>函数是一个全局函数。在链接的时候对外部可见。我们也可以使用global来声明其他的任何函数和变量。并使用extern来导入他们。</p>
<p>function.asm</p>
<pre><code class="assembly">extern printf
extern c_area	;这些函数在其它的文件中定义
extern c_circum
extern r_area
extern r_circum
global pi		;声明为全局的,别的文件可以导入pi
section .data
        pi      dq 3.141592654
        radius  dq 10.0
        side1   dq 4
        side2   dq 5
        fmtf    db &quot;%s %f&quot;,10,0
        fmti    db &quot;%s %d&quot;,10,0
        ca      db &quot;The circle area is &quot;,0
        cc      db &quot;The circle circumreference is &quot;,0
        ra      db &quot;The rectangle area is &quot;, 0
        rc      db &quot;The rectangle circumreference is&quot;,0
section .bss
section .text
        global main
main:
        enter 0,0
        movsd xmm0, [radius]
        call c_area ;调用外部函数
        mov rdi, fmtf
        mov rsi, ca
        mov rax, 1
        call printf

        movsd xmm0, [radius]
        call c_circum
        mov rdi, fmtf
        mov rsi, ca
        mov rax, 1
        call printf

        mov rdi, [side1]
        mov rsi, [side2]
        call r_area
        mov rdi, fmti
        mov rsi, ra
        mov rdx, rax
        mov rax, 0
        call printf

        mov rdi, [side1]
        mov rsi, [side2]

        call r_circum
        mov rdi, fmti
        mov rsi, rc
        mov rdx, rax
        mov rax, 0
        call printf

        leave
        ret
</code></pre>
<p>circle.asm</p>
<pre><code class="assembly">extern pi
section .text
        global c_area ;声明为全局的函数
        global c_circum
c_area:
        section .text
        enter 0, 0
        movsd xmm1, [pi]
        mulsd xmm0, xmm0
        mulsd xmm0, xmm1
        leave
        ret
;-----------------------------------------------
c_circum:
        section .text
        enter 0, 0
        movsd xmm1, [pi]
        addsd xmm0, xmm0
        mulsd xmm0, xmm1
        leave
        ret
</code></pre>
<p>rect.asm</p>
<pre><code class="assembly">section .text
        global r_area  ;声明为全局的
        global r_circum
;-------------------------
;rdi: 长
;rsi: 宽
;area: rax, rdx
r_area:
        enter 0,0
        mov rax, rdi
        imul rax, rsi
        leave
        ret
;------------------
r_circum:
        enter 0, 0
        mov rax, rdi
        add rax, rsi
        add rax, rax
        leave
        ret
</code></pre>
<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>我们依旧按照依赖关系来书写makefile</p>
<p>因为调用外部函数。这些函数放在了其他的.o文件中。最终的可执行文件不仅需要function.o文件，还需要那顶定义了全局函数的其他.o文件。对于这些.o文件，再按照其依赖树递归的书写即可。</p>
<pre><code class="makefile">function: function.o circle.o rect.o
        gcc -g -o function function.o circle.o rect.o -no-pie
function.o: function.asm
        nasm -f elf64 -g -F dwarf function.asm -l function.lst
circle.o: circle.asm
        nasm -f elf64 -g -F dwarf circle.asm -l circle.lst
rect.o: rect.asm
        nasm -f elf64 -g -F dwarf rect.asm -l rect.lst
</code></pre>
<p>最终我们键入make指令并运行</p>
<pre><code class="text">The circle area is  314.159265
The circle area is  62.831853
The rectangle area is  20
The rectangle circumreference is 18
</code></pre>
<p>大功告成。</p>
<h1 id="手动的制造一些错误"><a href="#手动的制造一些错误" class="headerlink" title="手动的制造一些错误"></a>手动的制造一些错误</h1><p>我们将函数的global给注释掉。不出意外的话，会得到一个链接错误。</p>
<pre><code class="error">/usr/bin/ld: function.o: in function `main&#39;:
function.asm:39: undefined reference to `r_area&#39;
</code></pre>
<p>正如我们所料。再ld链接function.o和rect.o的时候，说没有找到r_area的定义（我们将其的global声明给去掉了）。</p>
<p>再比如对pi变量实行同样的操作。</p>
<pre><code class="error">/usr/bin/ld: circle.o: in function `c_area&#39;:
circle.asm:8: undefined reference to `pi&#39;
/usr/bin/ld: circle.o: in function `c_circum&#39;:
circle.asm:17: undefined reference to `pi&#39;
</code></pre>
<p>还是同样的错误，ld又会说，我没有找到某个东西的定义。</p>
<h1 id="链接的一些细节"><a href="#链接的一些细节" class="headerlink" title="链接的一些细节"></a>链接的一些细节</h1><p>我们再不同的文件中定义了不同的函数，在编译的时候，这些asm文件被单独的编译。那么函数调用如何编译呢？答案是先放着，等到链接的时候再替换具体的跳转地址。</p>
<pre><code class="assembly">0000000D E8(00000000)                call c_area
</code></pre>
<p>我们查看<code>.lst</code>文件，发现调用指令(E8)后的地址为0。</p>
<p>也可以使用objdump来查看function.o的反汇编</p>
<pre><code class="assembly">e8 00 00 00 00          callq  71 &lt;main+0x71&gt;
</code></pre>
<p>&lt;main+0x71&gt;并不是真正的函数地址，我们还是可以看见e8后面的地址还是0</p>
<p>我们再来查看function反汇编</p>
<pre><code class="assembly">40113d:       e8 be 00 00 00          callq  401200 &lt;c_area&gt;
</code></pre>
<p>再链接过后，可以看见跳转地址 成功的被替换。</p>
<p>如果你觉得这是偶然——好吧，换个方式说服你。</p>
<p>我们反汇编<code>funciton.o</code>文件，并查找所有的call指令，对于最后链接出来的可执行文件，执行同样的操作。</p>
<p><code>objdump -d function.o | rg call</code></p>
<pre><code class="assembly">   d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;
  2b:   e8 00 00 00 00          callq  30 &lt;main+0x30&gt;
  39:   e8 00 00 00 00          callq  3e &lt;main+0x3e&gt;
  57:   e8 00 00 00 00          callq  5c &lt;main+0x5c&gt;
  6c:   e8 00 00 00 00          callq  71 &lt;main+0x71&gt;
  8d:   e8 00 00 00 00          callq  92 &lt;main+0x92&gt;
  a2:   e8 00 00 00 00          callq  a7 &lt;main+0xa7&gt;
  c3:   e8 00 00 00 00          callq  c8 &lt;main+0xc8&gt;
</code></pre>
<p>还是上面说到过的<code>&lt;main+0x...&gt;</code>这并不是真正的函数跳转地址。</p>
<p><code> objdump -d function | rg call</code></p>
<pre><code class="assembly">  401014:       ff d0                   callq  *%rax
  401068:       ff 15 82 2f 00 00       callq  *0x2f82(%rip)        # 403ff0 &lt;__libc_start_main@GLIBC_2.2.5&gt;
  401101:       e8 7a ff ff ff          callq  401080 &lt;deregister_tm_clones&gt;
  40113d:       e8 be 00 00 00          callq  401200 &lt;c_area&gt;
  40115b:       e8 d0 fe ff ff          callq  401030 &lt;printf@plt&gt;
  401169:       e8 a9 00 00 00          callq  401217 &lt;c_circum&gt;
  401187:       e8 a4 fe ff ff          callq  401030 &lt;printf@plt&gt;
  40119c:       e8 8f 00 00 00          callq  401230 &lt;r_area&gt;
  4011bd:       e8 6e fe ff ff          callq  401030 &lt;printf@plt&gt;
  4011d2:       e8 66 00 00 00          callq  40123d &lt;r_circum&gt;
  4011f3:       e8 38 fe ff ff          callq  401030 &lt;printf@plt&gt;
  40127c:       e8 7f fd ff ff          callq  401000 &lt;_init&gt;
  401299:       41 ff 14 df             callq  *(%r15,%rbx,8)
</code></pre>
<p>可以看见，e8后面的地址均被替换。</p>
<p>关于链接的细节，并不打算展开细说。那样就脱离的本篇的主题了。</p>
<h1 id="C函数"><a href="#C函数" class="headerlink" title="C函数"></a>C函数</h1><p>为什么<code>makefile</code>中没有对printf的引用呢？gcc可以自动识别C苦衷源代码函数的引用。这意味着你不应该使用C函数的名成来命名为自己的函数！这回导致链接出错。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果想使用外部函数&#x2F;变量，请将那个函数声明为<code>global</code>。链接的时候链接器会自动替换跳转地址。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #03a9f4">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #00bcd4">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/15/x64-asm外部函数/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/15/x64-asm栈对齐和栈帧/">
        <h2 class="post-title">X64-Asm栈对齐和栈帧</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/15
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="栈对齐"><a href="#栈对齐" class="headerlink" title="栈对齐"></a>栈对齐</h1><p>在英特尔手册中, 你会发现当调用函数时，栈要求必须是16字节对齐。</p>
<p>一些SIMD指令(Single Instruction, Multiple Data，一条指令操作多个数据)对较大的数据执行并进行操作可能要求这些数据位于内存中16字节的倍数上。例如printf于xmm一起使用的时候，会将栈对齐位16个字节。如果用不带xmm的printf，则可以不用进行对齐，但是这样迟早会出问题。</p>
<p><strong>请记住，函数调用的时候，会将栈对齐位16倍数</strong></p>
<p>那么我们随便写一些东西</p>
<p>makefile</p>
<pre><code class="makefile">test: test.o
        gcc -o test test.o -no-pie
test.o: test.asm
        nasm -f elf64 -g -F dwarf test.asm -l test.lst
</code></pre>
<p>前面我们已经说过的，在函数调用的时候总是应当栈对齐。</p>
<p>在<code>call main</code>之前，栈是对齐的。在<code>call main</code>之后。rsp-8。此时栈还差8个字节对齐。我们可以用这个程序来验证。</p>
<p>注意我们的程序把栈对齐的指令给注释掉了</p>
<pre><code class="asm">extern printf
section .bss
section .data
        fmt             db &quot;The number is %d&quot;,10,0
        rsp_fmt db &quot;rsp is %x&quot;,10,0
section .text
        global main
main:

        ;push rbp
        ;mov rbp, rsp
        mov rdi, fmt
        mov rsi, 10
        mov rax, 0
        call printf

        ;print rsp
        mov rdi, rsp_fmt
        mov rsi, rsp
        mov rax, 0
        call printf
        ;mov rsp, rbp
        ;pop rbp
        ret
</code></pre>
<p>在我的机器上，有这样的输出结果。也许你的会不同，但是有一点是一样的。你的rsp的值最低位不应该是0。或者更确切的来说，应当是8</p>
<pre><code>The number is 10
rsp is d52880f8
</code></pre>
<p>把用于栈对齐的指令取消注释，再次运行。得到的rsp的值最低位应当是0。</p>
<pre><code>The number is 10
rsp is 23cfdfe0
</code></pre>
<p>这就是为什么程序要使用序言和尾声。 </p>
<p>我猜现在你还有一个疑问。为什么被调用者要保存rsp，而不是rdi，rsi其他的寄存器？</p>
<p>为了解决这个疑问，我们还要了解一个东西——栈帧。</p>
<h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>在函数的每次调用过程中，都需要在栈空间实现自己的一个独立的栈，我们可以把这独立的栈叫做栈帧。</p>
<p>更准确的说： 每一次函数的调用,都会在调用栈(call stack)上维护一个独立的栈帧(stack frame).每个独立的栈帧一般包括:</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>
<li>函数调用的上下文</li>
</ul>
<p><code>rbp</code>是 x86_64 上的帧指针。代码中，它会获取堆栈指针 ( <code>rsp</code> ) 的快照，以便在对 <code>rsp</code> 进行调整时(即为局部变量或 <code>push</code> 将值保留到堆栈上)，局部变量和函数参数仍然可以从 <code>rbp</code> 的恒定偏移量访问.</p>
<p>再回到我们的问题,为什么要保存rbp? 我们已经说过了，每个函数都有一个自己的栈帧。当调用函数的时候，会修改rbp。因此在将rbp用于栈帧之前(调用函数前),应当将其保存。以免rbp丢失而导致非正常行为。还有另外一些原因：我们对于函数调用中的参数，会有约定的寄存器。例如第一个参数位rdi,第二个参数位rsi等。rbp在函数的调用中不用传递任何参数。</p>
<h1 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h1><p>函数可以分为两种类型，分支函数&#x2F;枝干函数，叶子函数。我们把函数的调用关系映射到一个树——我们已经熟悉的数据结构。分支函数就是会调用其他函数的函数。而叶子函数就是不会调用其他函数的函数。</p>
<p>因为叶子函数不会调用其他函数，通常可以忽略栈帧和栈对齐。只要你不把栈搞乱即可。但注意用xmm和printf的时候，即使是叶子函数，还是要进行对齐。</p>
<h1 id="序言和尾声的代替"><a href="#序言和尾声的代替" class="headerlink" title="序言和尾声的代替"></a>序言和尾声的代替</h1><p>可以使用<code>enter 0,0</code>来代替函数的序言。这样做可能造成性能问题。</p>
<p>可以使用<code>leave</code>来代替尾声。单不必担心性能问题。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>无论如何，始终包含栈帧并检查堆栈是一个好习惯。以后可以为我们省去很多麻烦。</p>
<p>还有一个理由是：gdb或者基于gdb的调试器，在调试的时候都期望可以找到一个栈帧。如果代码中没有这些栈帧。则会发生不可预测的行为。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #ff7d73">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ff7d73">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/15/x64-asm栈对齐和栈帧/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/14/x64-asm浮点数操作/">
        <h2 class="post-title">X64-Asm浮点数操作</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/14
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="XMM寄存器"><a href="#XMM寄存器" class="headerlink" title="XMM寄存器"></a>XMM寄存器</h1><p>xmm寄存器一共有个，每个xmm寄存器128位。他们的编号分别是xmm0-xmm15.可用于浮点数的操作。</p>
<h1 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h1><p>计算机中浮点数使用IEEE编码。单精度为32位，双精度位64位。</p>
<h1 id="浮点数编程"><a href="#浮点数编程" class="headerlink" title="浮点数编程"></a>浮点数编程</h1><p>对于浮点数使用移动指令，不能使用mov，要使用movsd——表示移动一个单精度浮点数。类似的add等操作也需要做出相应的改变。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>movsd</td>
<td>移动一个双精度浮点数</td>
</tr>
<tr>
<td>movss</td>
<td>移动一个单精度浮点数</td>
</tr>
<tr>
<td>addsd</td>
<td>将两个双精度浮点数相加</td>
</tr>
<tr>
<td>addss</td>
<td>将单个双精度浮点数相加</td>
</tr>
<tr>
<td>subsd</td>
<td>将两个双精度浮点数相减</td>
</tr>
<tr>
<td>subss</td>
<td>将单个双精度浮点数相减</td>
</tr>
<tr>
<td>mulsd</td>
<td>将两个双精度浮点数相乘</td>
</tr>
<tr>
<td>mulss</td>
<td>将两个单精度浮点数相乘</td>
</tr>
<tr>
<td>divsd</td>
<td>将两个双精度浮点数相除</td>
</tr>
<tr>
<td>divss</td>
<td>将单个双精度浮点数相除</td>
</tr>
<tr>
<td>sqrtsd</td>
<td>对双精度浮点数求平方根</td>
</tr>
<tr>
<td>sqrtss</td>
<td>对单精度浮点数求平方根</td>
</tr>
</tbody></table>
<p>下满的代码时对浮点数进行+-*&#x2F;和平方根运算。</p>
<pre><code class="asm">;fcalc.asm

extern printf
section .data
        number1         dq 9.0
        number2         dq 73.0
        fmt                     db &quot;The numbers are %f and %f&quot;,10,0

        fmtfloat        db &quot;%s %f&quot;,10,0
        f_sum           db &quot;The float sum of %f and %f is %f&quot;,10,0
        f_dif           db &quot;The float difference of %f and %f is %f&quot;,10,0
        f_mul           db &quot;The float product of %f and %f is %f&quot;,10,0
        f_div           db &quot;The float division of %f and %f is %f&quot;,10,0
        f_sqrt          db &quot;The float squareroot of %f is %f&quot;,10,0
section .bss
section .text
        global main
main:
        push rbp
        mov rbp, rsp

        ;打印数字
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, fmt
        mov rax, 2 ;用到两个xmm寄存器
        call printf

        ;sum
        movsd xmm2, [number1]
        addsd xmm2, [number2] ;number1+number2结果放在xmm2中

        mov rdi, f_sum
        mov rax, 3
        call printf

        ;difference
        movsd xmm2, [number1]
        subsd xmm2, [number2]
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, f_dif
        mov rax, 3
        call printf

        ;mul
        movsd xmm2, [number1]
        mulsd xmm2, [number2]
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, f_mul
        mov rax, 3
        call printf

        ;division
        movsd xmm2, [number1]
        divsd xmm2, [number2]
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, f_div
        mov rax, 3
        call printf

        ;squareroot
        sqrtsd xmm1, [number1]
        movsd xmm0, [number1]
        mov rdi, f_sqrt
        mov rax, 2
        call printf
        ;exit

        mov rsp, rbp
        pop rbp
        ret
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #00bcd4">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ffa2c4">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/14/x64-asm浮点数操作/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/13/x64-asm调用printf/">
        <h2 class="post-title">X64-Asm调用printf</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>使用extent来导入c函数</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #03a9f4">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ffa2c4">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/13/x64-asm调用printf/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/13/x64-asm整数的运算/">
        <h2 class="post-title">X64-Asm整数的运算</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <table>
<thead>
<tr>
<th>操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>用于加法，会设置CF,OF,SF,ZF。可用于无符号和有符号</td>
</tr>
<tr>
<td>sub</td>
<td>用于减法，会设置CF,OF,SF,ZF。可用于无符号和有符号</td>
</tr>
<tr>
<td>inc</td>
<td>自增1，不会影响标志寄存器</td>
</tr>
<tr>
<td>dec</td>
<td>自减1，不会影响标志寄存器</td>
</tr>
<tr>
<td>sal</td>
<td>左移</td>
</tr>
<tr>
<td>sar</td>
<td>算数右移</td>
</tr>
<tr>
<td>imul</td>
<td>有符号数相乘。得到的结果需要用两个寄存器来保存（qword x qword），地位放在rax中，高位放在rdx中。</td>
</tr>
<tr>
<td>idiv</td>
<td>无符号除法。得到的结果放在rax中，余数放在rdx中。</td>
</tr>
</tbody></table>
<pre><code class="asm">extern printf
section .data
        number1         dq 128
        number2         dq 19
        neg_num         dq -12
        fmt                     db &quot;The numbers are %ld and %ld&quot;,10,0
        fmtint          db &quot;%s %ld&quot;,10,0
        sumi            db &quot;The sum is&quot;,0
        difi            db &quot;The differrnce is&quot;,0
        inci            db &quot;Number 1 Incremented:&quot;,0
        deci            db &quot;Number 1 decremented:&quot;,0
        sali            db &quot;Number 1 Shift left 2(x4):&quot;,0
        sari            db &quot;Number 1 Shift right 2(/4):&quot;,0
        sariex          db &quot;Number 1 Shift right 2(/4) with &quot;
                                db &quot;sing extension:&quot;,0
        multi           db &quot;The productz is&quot;,0
        divi            db &quot;The integer quotient is&quot;,0
        remi            db &quot;The modulo is&quot;,0
section .bss
        resulti resq 1
        modulo  resq 1
section .text
        global main
main:
        push rbp
        mov rbp, rsp

        ;显示数字
        mov rdi, fmt
        mov rsi, [number1]
        mov rdx, [number2]
        mov rax, 0
        call printf

        ;加法
        mov rax, [number1]
        add rax, [number2]
        mov [resulti], rax

        ;显示结果
        mov rdi, fmtint
        mov rsi, sumi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;减法
        mov rax, [number1]
        sub rax, [number2]
        mov [resulti], rax

        ;显示结果
        mov rdi, fmtint
        mov rsi, difi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;++
        mov rax, [number1]
        inc rax
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, inci
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;--
        mov rax, [number1]
        dec rax
        mov [resulti], rax

        ;显示结果
        mov rdi, fmtint
        mov rsi, deci
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;左移运算
        mov rax, [number1]
        sal rax, 2 ;x4
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, sali
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;右移运算
        mov rax, [resulti]
        sar rax, 2 ; /4
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, sari
        mov rdx, [resulti]
        mov rax, 0
        call printf

        mov rax, [neg_num]
        sar rax, 2
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, sariex
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;乘法
        mov rax, [number1]
        imul qword [number2]
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, multi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;除法
        mov rax, [number1]
        mov rdx, 0
        idiv qword [number2]
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, divi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        mov rdi, fmtint
        mov rsi, remi
        mov rdx, [modulo]
        mov rax, 0
        call printf

        mov rsp, rbp
        pop rbp
        ret
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #ff7d73">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ffa2c4">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/13/x64-asm整数的运算/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/02/Rust指针/">
        <h2 class="post-title">Rust Raw-Ptr</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>提到指针，就一定避免不了谈到引用。因为引用时指针的封装。引用总能指向一个有效的对象，并在指向一个动态对象的时候有着大小的保证。引用的好处有如下几点</p>
<ul>
<li>总能保证引用有效数据</li>
<li>引用与usize大小的倍数对其</li>
<li>引用可以为动态类型大小提供上述保障</li>
</ul>
<p>我们可以使用{:p}的格式来表示要打印指针</p>
<pre><code class="rust">    let a = 10;
    println!(&quot;&#123;:p&#125;&quot;,&amp;a);
</code></pre>
<p>可以看见&amp;a这里被当作了一个指针。</p>
<p>同样的，还能取得数组的首地址。</p>
<pre><code class="rust">    let nums = [10; 5];
    println!(&quot;&#123;:p&#125;&quot;,&amp;nums);
</code></pre>
<p>本应是引用，却有了取地址的意思。一定程度上，把引用和指针一视同仁，把引用看作封装后的指针。</p>
<p>现在再来看解引用操作。</p>
<pre><code class="rust">    let a = 10;
    let ra = &amp;10;
    println!(&quot;&#123;&#125;&quot;,*ra);
</code></pre>
<p>恍然大悟了！虽然ra可以自动解引用，也可以手动解引用。这不就是C吗？取地址和解引用。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>rust更倾向于把指针封装起来，毕竟为了安全嘛。原始指针我们叫做<code>raw-ptr</code>。</p>
<p>什么时<code>raw-ptr</code>呢？就是一个引用呗。那肯定也支持指针算数操作。比如加法运算。</p>
<pre><code class="rust">    let a = 10;
    let ra = &amp;10;
    let b = ra + 1;
    println!(&quot;&#123;b&#125;&quot;);
</code></pre>
<p>很不幸，b是11。因为标准库为我们实现了&amp;i32 i32的Add trait。这样操作就相当于两个i32相加。</p>
<h2 id="raw指针类型"><a href="#raw指针类型" class="headerlink" title="raw指针类型"></a>raw指针类型</h2><p>众所周知C&#x2F;C++中有<code>T*</code>类型，例如<code>int *; double *</code>等。Rust同样的也提供了这样的类型。写法和C&#x2F;C++颇有不同。</p>
<pre><code class="rust">    let a = 10;
    let pa: * const i32 = &amp;a;
    println!(&quot;&#123;:p&#125;&quot;,pa);
    let pa = &amp;a as * const i32;
    println!(&quot;&#123;:p&#125;&quot;,pa);
</code></pre>
<p>Rust中的raw-ptr分为<code>const</code>, <code>mut</code>两种性质。意思为指向的对象不可变，指向的对象可变。</p>
<p>对raw-ptr执行解引用操作需要在unsafe中进行。</p>
<pre><code class="rust">    let a = 10;
    let pa: * const i32 = &amp;a;
    unsafe &#123;
        // *pa = 20; //error
    &#125;
    println!(&quot;&#123;:p&#125;&quot;,pa);
    let pa = &amp;a as * const i32 as * mut i32;
    unsafe &#123;
        *pa = 20;
    &#125;
    assert_eq!(20, a);
    println!(&quot;&#123;:p&#125;&quot;,pa);
</code></pre>
<p>从一个&amp;T来到*mut T需要额外的转换，要先转换为<code>*const</code>,再转换为<code>*mut</code>。但是可以从&amp;mut T直接转换为一个<code>*mut</code>指针。</p>
<pre><code class="rust">    let mut a = 10;
    let pa = &amp;mut a as *mut i32;
</code></pre>
<h2 id="raw指针会破坏rust的借用和所有权规则"><a href="#raw指针会破坏rust的借用和所有权规则" class="headerlink" title="raw指针会破坏rust的借用和所有权规则"></a>raw指针会破坏rust的借用和所有权规则</h2><p>你可能看见了a是一个非mut的变量，却经过*mut指针之手改变为20，使用的时候要注意。rust的不可变性，也不是那么的不可变啊。</p>
<p>这样太容易带来歧义了。按照rust的说法，非mut的，就是不可变，维度指针打破了这种规则。如果指针操作的一个变量可能改变，请生命为mut避免带来歧义。</p>
<h2 id="mut隐式的转换为-const"><a href="#mut隐式的转换为-const" class="headerlink" title="*mut隐式的转换为*const"></a>*mut隐式的转换为*const</h2><pre><code class="rust">   let p: *mut i32 = ptr::null_mut();
   let q: *const i32 = p; //隐式转换
</code></pre>
<h1 id="空指针null"><a href="#空指针null" class="headerlink" title="空指针null"></a>空指针null</h1><p>大多数的C&#x2F;C++错误，空指针是罪魁祸首。rust在safe中没有提供空指针。而是使用Option的None枚举来代表空语义。</p>
<p>现在设计到的raw-ptr,讨论空指针是不可避免的。</p>
<h2 id="ptr-null"><a href="#ptr-null" class="headerlink" title="ptr::null()"></a>ptr::null()</h2><p>但是null这个关键字并没有被rust引入。如果你想获得一个空指针，可以用<code>ptr::null()</code></p>
<pre><code class="rust">let p: * const i32 = ptr::null();
</code></pre>
<p>单纯的对空指针解引用则是一个未定义的行为。在windows上可能会得到一个error,在linux上可能会段错误。</p>
<pre><code class="rust">    unsafe &#123;
        println!(&quot;&#123;&#125;&quot;,*p);
    &#125;
</code></pre>
<p>用<code>ptr_null()</code>获得的指针是不可变的(指向的对象)。</p>
<pre><code class="rust">    let mut p: * const i32 = ptr::null();
    let a = 10;
    p = &amp;a as *const i32;
    unsafe &#123;
        *p = 20; //error
    &#125;
</code></pre>
<h2 id="ptr-mut-null"><a href="#ptr-mut-null" class="headerlink" title="ptr::mut_null()"></a>ptr::mut_null()</h2><p>同样是获得指针，但是是可变的(指向的对象)</p>
<pre><code class="rust">    let mut p: * mut i32 = ptr::null_mut();
    let mut a = 10;
    p = &amp;a as *const i32 as *mut i32;
    unsafe &#123;
        *p = 20; //ok
    &#125;
</code></pre>
<h2 id="is-null"><a href="#is-null" class="headerlink" title="is_null()"></a>is_null()</h2><p>你可以使用is_null来判断一个指针是否为空。</p>
<pre><code class="rust">    let p: * const i32 = ptr::null();
    assert!(p.is_null());
</code></pre>
<h1 id="使用raw-ptr迭代容器"><a href="#使用raw-ptr迭代容器" class="headerlink" title="使用raw-ptr迭代容器"></a>使用raw-ptr迭代容器</h1><p>rust肯定不推荐使用raw-ptr来迭代容器。毕竟标准库已经为我们提供了那么多用于迭代的方法。rust也内置了<code>for in</code>来进行迭代。如果不是为学习&#x2F;系统编程。没人会这样做。对raw-ptr的操作要放在unsafe里，这是不安全的。但最主要的是——不要有现成的工具不用而跑去当猴子。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>例如用raw-ptr迭代一个C风格个字符串。</p>
<pre><code class="rust">static c_string: [u8; 8] = [97,98,99,100,101,102,103,b&#39;\0&#39;];
fn main() &#123;
    let mut curr = &amp;c_string as *const u8;
    unsafe &#123;
        while *curr != b&#39;\0&#39; &#123;
            print!(&quot;&#123;&#125; &quot;,*curr as char);
            curr = curr.add(1);
        &#125;
    &#125;
&#125;
</code></pre>
<p>rust对于裸指针的+操作，并没有直接用加号。而是提供了一个add()方法。类似的，还提供了一个名为sub()方法，代替-。</p>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><p>给定一个String，判断这个String是否是回文。假定String中的字符全为英文字母。</p>
<pre><code class="rust">fn main() &#123;
    let s = String::from(&quot;helloolleh&quot;);
    println!(&quot;&#123;&#125;&quot;,is_palindrome(&amp;s));
&#125;

//判断一个s: &amp;str是否是回文
fn is_palindrome(s: &amp;str) -&gt; bool &#123;
    let mut first = s.as_ptr();
    unsafe &#123;
        let mut last = s.as_ptr().add(s.len()-1);
        while first &lt; last &#123;
            if *first != *last &#123;
                return false;
            &#125;
            first = first.add(1);
            last = last.sub(1);
        &#125;
    &#125;
    true
&#125;
</code></pre>
<h1 id="unsafe链表"><a href="#unsafe链表" class="headerlink" title="unsafe链表"></a>unsafe链表</h1>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #ffa2c4">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Unsafe-Rust/" style="color: #ffa2c4">
                Unsafe Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Effective-Rust/" style="color: #ffa2c4">
                Effective Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/02/Rust指针/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/01/区别-mut-mut-mut-mut/">
        <h2 class="post-title">区别&amp; Mut; Mut &amp;; Mut &amp; Mut</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/1
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>这里讨论的问题就像C++中的<code>const *</code>,<code>* const</code>,<code>const * const</code>一样，你完全可以类比。</p>
<pre><code class="rust">#[allow(unused)]
fn work_2() &#123;
    let mut a = 10;
    &#123;
        let b = 20;
        let ref_a = &amp;a; // -&gt; &amp;i32
        ref_a = &amp;b;            //将引用指向b不可以
        let mut mut_ref_a = &amp;a; //mut &amp;i32
        *mut_ref_a = 20;       //更改变量本身，不可以
        mut_ref_a = &amp;b;        //将引用指向b，可以
    &#125;
    let ref_mut_a = &amp;mut a; // -&gt; &amp;mut i32
    *ref_mut_a = 20;  //更改变量本身的值，可以
&#125;
</code></pre>
<ul>
<li>&amp; mut代表着对一个变量的可变引用，引用的变量是可变的，但是引用本身是不可变的，也就是说当我确定引用一个变量的时候，就不能再引用其他变量了。</li>
<li>mut &amp;代表着引用本身是可变的，即这个引用既可以引用a，又可以引用b，但是引用的变量是不可变的。</li>
<li>&amp; mut &amp; 即代表着上述两者的结合，引用本身是可变的，并且引用的变量也是可变的。</li>
</ul>
<pre><code class="error">jan@jan:~/code/rust/option_$ cargo run
   Compiling option_ v0.1.0 (/home/jan/code/rust/option_)
error[E0384]: cannot assign twice to immutable variable `ref_a`
  --&gt; src/main.rs:24:9
   |
23 |         let ref_a = &amp;a; // -&gt; &amp;i32
   |             -----
   |             |
   |             first assignment to `ref_a`
   |             help: consider making this binding mutable: `mut ref_a`
24 |         ref_a = &amp;b;            //将引用指向b不可以
   |         ^^^^^^^^^^ cannot assign twice to immutable variable
 
error[E0594]: cannot assign to `*mut_ref_a`, which is behind a `&amp;` reference
  --&gt; src/main.rs:26:9
   |
25 |         let mut mut_ref_a = &amp;a; //mut &amp;i32
   |                             -- help: consider changing this to be a mutable reference: `&amp;mut a`
26 |         *mut_ref_a = 20;       //更改变量本身，不可以
   |         ^^^^^^^^^^^^^^^ `mut_ref_a` is a `&amp;` reference, so the data it refers to cannot be written
 
Some errors have detailed explanations: E0384, E0594.
For more information about an error, try `rustc --explain E0384`.
error: could not compile `option_` due to 2 previous errors
</code></pre>
<p>mut &amp;可以用来充当指针的位置，例如输出一个Box+Option的链表。</p>
<p>为了简便，不实现Display Trait,而是用一个方法</p>
<pre><code class="rust">impl &lt;T:Display&gt; LinkedList&lt;T&gt; &#123;
    pub fn display(&amp;self) &#123;
        let mut curr = &amp;self.head; //curr: mut &amp;Link
        while let Some(node) = curr &#123;
            println!(&quot;&#123;&#125;&quot;,node.data);
            curr = &amp;node.next;
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #00a596">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Effective-Rust/" style="color: #ff7d73">
                Effective Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/01/区别-mut-mut-mut-mut/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <i class="fa-solid fa-caret-right fa-fw"></i>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4 " alt="avatar">
        </div>
        <div class="name">
            Jan6055
        </div>
        <div class="descriptions">
            
            <div class="description">
                兴趣：
            </div>
            
            <div class="description">
                C++
            </div>
            
            <div class="description">
                Rust
            </div>
            
            <div class="description">
                Haskell
            </div>
            
            <div class="description">
                这是我的个人博客，用于记录学习到的技能
            </div>
            
            <div class="description">
                我希望我的博客会帮到你
            </div>
            
            <div class="description">
                如果你对博客中的内容有疑问，请联系
            </div>
            
            <div class="description">
                QQ: 1796728809
            </div>
            
            <div class="description">
                email: 1796728809@qq.com
            </div>
            
            <div class="description">
                wangq6055@outlook.com
            </div>
            
            <div class="description">
                目前:
            </div>
            
            <div class="description">
                在校大二学生
            </div>
            
            <div class="description">
                在学习Modern C++ &amp;&amp; 各种计算机基础
            </div>
            
            <div class="description">
                时不时摆烂，很爽
            </div>
            
            <div class="description">
                But I love coding!
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/jan6055">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hello @you
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Jan6055
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>