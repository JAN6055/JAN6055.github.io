
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hello @You</title>
        <meta name="author" content="Jan6055">
        <meta name="description" content="">
        <meta name="keywords" content="C++,Rust,Jan6055">
        <link rel="icon" href="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hello @you</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hello @you</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(http://p6.qhimg.com/bdr/__85/t015c7bbab0a42e2cf9.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Hello @you</h1>
                <h3>enjoy coding</h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/10/14/x64-asm浮点数操作/">
        <h2 class="post-title">X64-Asm浮点数操作</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/14
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="XMM寄存器"><a href="#XMM寄存器" class="headerlink" title="XMM寄存器"></a>XMM寄存器</h1><p>xmm寄存器一共有个，每个xmm寄存器128位。他们的编号分别是xmm0-xmm15.可用于浮点数的操作。</p>
<h1 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h1><p>计算机中浮点数使用IEEE编码。单精度为32位，双精度位64位。</p>
<h1 id="浮点数编程"><a href="#浮点数编程" class="headerlink" title="浮点数编程"></a>浮点数编程</h1><p>对于浮点数使用移动指令，不能使用mov，要使用movsd——表示移动一个单精度浮点数。类似的add等操作也需要做出相应的改变。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>movsd</td>
<td>移动一个双精度浮点数</td>
</tr>
<tr>
<td>movss</td>
<td>移动一个单精度浮点数</td>
</tr>
<tr>
<td>addsd</td>
<td>将两个双精度浮点数相加</td>
</tr>
<tr>
<td>addss</td>
<td>将单个双精度浮点数相加</td>
</tr>
<tr>
<td>subsd</td>
<td>将两个双精度浮点数相减</td>
</tr>
<tr>
<td>subss</td>
<td>将单个双精度浮点数相减</td>
</tr>
<tr>
<td>mulsd</td>
<td>将两个双精度浮点数相乘</td>
</tr>
<tr>
<td>mulss</td>
<td>将两个单精度浮点数相乘</td>
</tr>
<tr>
<td>divsd</td>
<td>将两个双精度浮点数相除</td>
</tr>
<tr>
<td>divss</td>
<td>将单个双精度浮点数相除</td>
</tr>
<tr>
<td>sqrtsd</td>
<td>对双精度浮点数求平方根</td>
</tr>
<tr>
<td>sqrtss</td>
<td>对单精度浮点数求平方根</td>
</tr>
</tbody></table>
<p>下满的代码时对浮点数进行+-*&#x2F;和平方根运算。</p>
<pre><code class="asm">;fcalc.asm

extern printf
section .data
        number1         dq 9.0
        number2         dq 73.0
        fmt                     db &quot;The numbers are %f and %f&quot;,10,0

        fmtfloat        db &quot;%s %f&quot;,10,0
        f_sum           db &quot;The float sum of %f and %f is %f&quot;,10,0
        f_dif           db &quot;The float difference of %f and %f is %f&quot;,10,0
        f_mul           db &quot;The float product of %f and %f is %f&quot;,10,0
        f_div           db &quot;The float division of %f and %f is %f&quot;,10,0
        f_sqrt          db &quot;The float squareroot of %f is %f&quot;,10,0
section .bss
section .text
        global main
main:
        push rbp
        mov rbp, rsp

        ;打印数字
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, fmt
        mov rax, 2 ;用到两个xmm寄存器
        call printf

        ;sum
        movsd xmm2, [number1]
        addsd xmm2, [number2] ;number1+number2结果放在xmm2中

        mov rdi, f_sum
        mov rax, 3
        call printf

        ;difference
        movsd xmm2, [number1]
        subsd xmm2, [number2]
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, f_dif
        mov rax, 3
        call printf

        ;mul
        movsd xmm2, [number1]
        mulsd xmm2, [number2]
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, f_mul
        mov rax, 3
        call printf

        ;division
        movsd xmm2, [number1]
        divsd xmm2, [number2]
        movsd xmm0, [number1] ;movsd表示移动一个双精度浮点数,8位
        movsd xmm1, [number2]
        mov rdi, f_div
        mov rax, 3
        call printf

        ;squareroot
        sqrtsd xmm1, [number1]
        movsd xmm0, [number1]
        mov rdi, f_sqrt
        mov rax, 2
        call printf
        ;exit

        mov rsp, rbp
        pop rbp
        ret
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #03a9f4">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ffa2c4">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/14/x64-asm浮点数操作/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/13/x64-asm调用printf/">
        <h2 class="post-title">X64-Asm调用printf</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>使用extent来导入c函数</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #00a596">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ff7d73">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/13/x64-asm调用printf/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/13/x64-asm整数的运算/">
        <h2 class="post-title">X64-Asm整数的运算</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <table>
<thead>
<tr>
<th>操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>用于加法，会设置CF,OF,SF,ZF。可用于无符号和有符号</td>
</tr>
<tr>
<td>sub</td>
<td>用于减法，会设置CF,OF,SF,ZF。可用于无符号和有符号</td>
</tr>
<tr>
<td>inc</td>
<td>自增1，不会影响标志寄存器</td>
</tr>
<tr>
<td>dec</td>
<td>自减1，不会影响标志寄存器</td>
</tr>
<tr>
<td>sal</td>
<td>左移</td>
</tr>
<tr>
<td>sar</td>
<td>算数右移</td>
</tr>
<tr>
<td>imul</td>
<td>有符号数相乘。得到的结果需要用两个寄存器来保存（qword x qword），地位放在rax中，高位放在rdx中。</td>
</tr>
<tr>
<td>idiv</td>
<td>无符号除法。得到的结果放在rax中，余数放在rdx中。</td>
</tr>
</tbody></table>
<pre><code class="asm">extern printf
section .data
        number1         dq 128
        number2         dq 19
        neg_num         dq -12
        fmt                     db &quot;The numbers are %ld and %ld&quot;,10,0
        fmtint          db &quot;%s %ld&quot;,10,0
        sumi            db &quot;The sum is&quot;,0
        difi            db &quot;The differrnce is&quot;,0
        inci            db &quot;Number 1 Incremented:&quot;,0
        deci            db &quot;Number 1 decremented:&quot;,0
        sali            db &quot;Number 1 Shift left 2(x4):&quot;,0
        sari            db &quot;Number 1 Shift right 2(/4):&quot;,0
        sariex          db &quot;Number 1 Shift right 2(/4) with &quot;
                                db &quot;sing extension:&quot;,0
        multi           db &quot;The productz is&quot;,0
        divi            db &quot;The integer quotient is&quot;,0
        remi            db &quot;The modulo is&quot;,0
section .bss
        resulti resq 1
        modulo  resq 1
section .text
        global main
main:
        push rbp
        mov rbp, rsp

        ;显示数字
        mov rdi, fmt
        mov rsi, [number1]
        mov rdx, [number2]
        mov rax, 0
        call printf

        ;加法
        mov rax, [number1]
        add rax, [number2]
        mov [resulti], rax

        ;显示结果
        mov rdi, fmtint
        mov rsi, sumi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;减法
        mov rax, [number1]
        sub rax, [number2]
        mov [resulti], rax

        ;显示结果
        mov rdi, fmtint
        mov rsi, difi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;++
        mov rax, [number1]
        inc rax
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, inci
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;--
        mov rax, [number1]
        dec rax
        mov [resulti], rax

        ;显示结果
        mov rdi, fmtint
        mov rsi, deci
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;左移运算
        mov rax, [number1]
        sal rax, 2 ;x4
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, sali
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;右移运算
        mov rax, [resulti]
        sar rax, 2 ; /4
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, sari
        mov rdx, [resulti]
        mov rax, 0
        call printf

        mov rax, [neg_num]
        sar rax, 2
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, sariex
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;乘法
        mov rax, [number1]
        imul qword [number2]
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, multi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        ;除法
        mov rax, [number1]
        mov rdx, 0
        idiv qword [number2]
        mov [resulti], rax
        ;显示结果
        mov rdi, fmtint
        mov rsi, divi
        mov rdx, [resulti]
        mov rax, 0
        call printf

        mov rdi, fmtint
        mov rsi, remi
        mov rdx, [modulo]
        mov rax, 0
        call printf

        mov rsp, rbp
        pop rbp
        ret
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/x64-asm/" style="color: #00bcd4">
                x64_asm
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/asm/" style="color: #ffa2c4">
                asm
            </a>
        </span>
        
    </div>
    <a href="/2022/10/13/x64-asm整数的运算/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/02/Rust指针/">
        <h2 class="post-title">Rust Raw-Ptr</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>提到指针，就一定避免不了谈到引用。因为引用时指针的封装。引用总能指向一个有效的对象，并在指向一个动态对象的时候有着大小的保证。引用的好处有如下几点</p>
<ul>
<li>总能保证引用有效数据</li>
<li>引用与usize大小的倍数对其</li>
<li>引用可以为动态类型大小提供上述保障</li>
</ul>
<p>我们可以使用{:p}的格式来表示要打印指针</p>
<pre><code class="rust">    let a = 10;
    println!(&quot;&#123;:p&#125;&quot;,&amp;a);
</code></pre>
<p>可以看见&amp;a这里被当作了一个指针。</p>
<p>同样的，还能取得数组的首地址。</p>
<pre><code class="rust">    let nums = [10; 5];
    println!(&quot;&#123;:p&#125;&quot;,&amp;nums);
</code></pre>
<p>本应是引用，却有了取地址的意思。一定程度上，把引用和指针一视同仁，把引用看作封装后的指针。</p>
<p>现在再来看解引用操作。</p>
<pre><code class="rust">    let a = 10;
    let ra = &amp;10;
    println!(&quot;&#123;&#125;&quot;,*ra);
</code></pre>
<p>恍然大悟了！虽然ra可以自动解引用，也可以手动解引用。这不就是C吗？取地址和解引用。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>rust更倾向于把指针封装起来，毕竟为了安全嘛。原始指针我们叫做<code>raw-ptr</code>。</p>
<p>什么时<code>raw-ptr</code>呢？就是一个引用呗。那肯定也支持指针算数操作。比如加法运算。</p>
<pre><code class="rust">    let a = 10;
    let ra = &amp;10;
    let b = ra + 1;
    println!(&quot;&#123;b&#125;&quot;);
</code></pre>
<p>很不幸，b是11。因为标准库为我们实现了&amp;i32 i32的Add trait。这样操作就相当于两个i32相加。</p>
<h2 id="raw指针类型"><a href="#raw指针类型" class="headerlink" title="raw指针类型"></a>raw指针类型</h2><p>众所周知C&#x2F;C++中有<code>T*</code>类型，例如<code>int *; double *</code>等。Rust同样的也提供了这样的类型。写法和C&#x2F;C++颇有不同。</p>
<pre><code class="rust">    let a = 10;
    let pa: * const i32 = &amp;a;
    println!(&quot;&#123;:p&#125;&quot;,pa);
    let pa = &amp;a as * const i32;
    println!(&quot;&#123;:p&#125;&quot;,pa);
</code></pre>
<p>Rust中的raw-ptr分为<code>const</code>, <code>mut</code>两种性质。意思为指向的对象不可变，指向的对象可变。</p>
<p>对raw-ptr执行解引用操作需要在unsafe中进行。</p>
<pre><code class="rust">    let a = 10;
    let pa: * const i32 = &amp;a;
    unsafe &#123;
        // *pa = 20; //error
    &#125;
    println!(&quot;&#123;:p&#125;&quot;,pa);
    let pa = &amp;a as * const i32 as * mut i32;
    unsafe &#123;
        *pa = 20;
    &#125;
    assert_eq!(20, a);
    println!(&quot;&#123;:p&#125;&quot;,pa);
</code></pre>
<p>从一个&amp;T来到*mut T需要额外的转换，要先转换为<code>*const</code>,再转换为<code>*mut</code>。但是可以从&amp;mut T直接转换为一个<code>*mut</code>指针。</p>
<pre><code class="rust">    let mut a = 10;
    let pa = &amp;mut a as *mut i32;
</code></pre>
<h2 id="raw指针会破坏rust的借用和所有权规则"><a href="#raw指针会破坏rust的借用和所有权规则" class="headerlink" title="raw指针会破坏rust的借用和所有权规则"></a>raw指针会破坏rust的借用和所有权规则</h2><p>你可能看见了a是一个非mut的变量，却经过*mut指针之手改变为20，使用的时候要注意。rust的不可变性，也不是那么的不可变啊。</p>
<p>这样太容易带来歧义了。按照rust的说法，非mut的，就是不可变，维度指针打破了这种规则。如果指针操作的一个变量可能改变，请生命为mut避免带来歧义。</p>
<h2 id="mut隐式的转换为-const"><a href="#mut隐式的转换为-const" class="headerlink" title="*mut隐式的转换为*const"></a>*mut隐式的转换为*const</h2><pre><code class="rust">   let p: *mut i32 = ptr::null_mut();
   let q: *const i32 = p; //隐式转换
</code></pre>
<h1 id="空指针null"><a href="#空指针null" class="headerlink" title="空指针null"></a>空指针null</h1><p>大多数的C&#x2F;C++错误，空指针是罪魁祸首。rust在safe中没有提供空指针。而是使用Option的None枚举来代表空语义。</p>
<p>现在设计到的raw-ptr,讨论空指针是不可避免的。</p>
<h2 id="ptr-null"><a href="#ptr-null" class="headerlink" title="ptr::null()"></a>ptr::null()</h2><p>但是null这个关键字并没有被rust引入。如果你想获得一个空指针，可以用<code>ptr::null()</code></p>
<pre><code class="rust">let p: * const i32 = ptr::null();
</code></pre>
<p>单纯的对空指针解引用则是一个未定义的行为。在windows上可能会得到一个error,在linux上可能会段错误。</p>
<pre><code class="rust">    unsafe &#123;
        println!(&quot;&#123;&#125;&quot;,*p);
    &#125;
</code></pre>
<p>用<code>ptr_null()</code>获得的指针是不可变的(指向的对象)。</p>
<pre><code class="rust">    let mut p: * const i32 = ptr::null();
    let a = 10;
    p = &amp;a as *const i32;
    unsafe &#123;
        *p = 20; //error
    &#125;
</code></pre>
<h2 id="ptr-mut-null"><a href="#ptr-mut-null" class="headerlink" title="ptr::mut_null()"></a>ptr::mut_null()</h2><p>同样是获得指针，但是是可变的(指向的对象)</p>
<pre><code class="rust">    let mut p: * mut i32 = ptr::null_mut();
    let mut a = 10;
    p = &amp;a as *const i32 as *mut i32;
    unsafe &#123;
        *p = 20; //ok
    &#125;
</code></pre>
<h2 id="is-null"><a href="#is-null" class="headerlink" title="is_null()"></a>is_null()</h2><p>你可以使用is_null来判断一个指针是否为空。</p>
<pre><code class="rust">    let p: * const i32 = ptr::null();
    assert!(p.is_null());
</code></pre>
<h1 id="使用raw-ptr迭代容器"><a href="#使用raw-ptr迭代容器" class="headerlink" title="使用raw-ptr迭代容器"></a>使用raw-ptr迭代容器</h1><p>rust肯定不推荐使用raw-ptr来迭代容器。毕竟标准库已经为我们提供了那么多用于迭代的方法。rust也内置了<code>for in</code>来进行迭代。如果不是为学习&#x2F;系统编程。没人会这样做。对raw-ptr的操作要放在unsafe里，这是不安全的。但最主要的是——不要有现成的工具不用而跑去当猴子。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>例如用raw-ptr迭代一个C风格个字符串。</p>
<pre><code class="rust">static c_string: [u8; 8] = [97,98,99,100,101,102,103,b&#39;\0&#39;];
fn main() &#123;
    let mut curr = &amp;c_string as *const u8;
    unsafe &#123;
        while *curr != b&#39;\0&#39; &#123;
            print!(&quot;&#123;&#125; &quot;,*curr as char);
            curr = curr.add(1);
        &#125;
    &#125;
&#125;
</code></pre>
<p>rust对于裸指针的+操作，并没有直接用加号。而是提供了一个add()方法。类似的，还提供了一个名为sub()方法，代替-。</p>
<h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><p>给定一个String，判断这个String是否是回文。假定String中的字符全为英文字母。</p>
<pre><code class="rust">fn main() &#123;
    let s = String::from(&quot;helloolleh&quot;);
    println!(&quot;&#123;&#125;&quot;,is_palindrome(&amp;s));
&#125;

//判断一个s: &amp;str是否是回文
fn is_palindrome(s: &amp;str) -&gt; bool &#123;
    let mut first = s.as_ptr();
    unsafe &#123;
        let mut last = s.as_ptr().add(s.len()-1);
        while first &lt; last &#123;
            if *first != *last &#123;
                return false;
            &#125;
            first = first.add(1);
            last = last.sub(1);
        &#125;
    &#125;
    true
&#125;
</code></pre>
<h1 id="unsafe链表"><a href="#unsafe链表" class="headerlink" title="unsafe链表"></a>unsafe链表</h1>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #ffa2c4">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Unsafe-Rust/" style="color: #ff7d73">
                Unsafe Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Effective-Rust/" style="color: #03a9f4">
                Effective Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/02/Rust指针/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/01/区别-mut-mut-mut-mut/">
        <h2 class="post-title">区别&amp; Mut; Mut &amp;; Mut &amp; Mut</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/1
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>这里讨论的问题就像C++中的<code>const *</code>,<code>* const</code>,<code>const * const</code>一样，你完全可以类比。</p>
<pre><code class="rust">#[allow(unused)]
fn work_2() &#123;
    let mut a = 10;
    &#123;
        let b = 20;
        let ref_a = &amp;a; // -&gt; &amp;i32
        ref_a = &amp;b;            //将引用指向b不可以
        let mut mut_ref_a = &amp;a; //mut &amp;i32
        *mut_ref_a = 20;       //更改变量本身，不可以
        mut_ref_a = &amp;b;        //将引用指向b，可以
    &#125;
    let ref_mut_a = &amp;mut a; // -&gt; &amp;mut i32
    *ref_mut_a = 20;  //更改变量本身的值，可以
&#125;
</code></pre>
<ul>
<li>&amp; mut代表着对一个变量的可变引用，引用的变量是可变的，但是引用本身是不可变的，也就是说当我确定引用一个变量的时候，就不能再引用其他变量了。</li>
<li>mut &amp;代表着引用本身是可变的，即这个引用既可以引用a，又可以引用b，但是引用的变量是不可变的。</li>
<li>&amp; mut &amp; 即代表着上述两者的结合，引用本身是可变的，并且引用的变量也是可变的。</li>
</ul>
<pre><code class="error">jan@jan:~/code/rust/option_$ cargo run
   Compiling option_ v0.1.0 (/home/jan/code/rust/option_)
error[E0384]: cannot assign twice to immutable variable `ref_a`
  --&gt; src/main.rs:24:9
   |
23 |         let ref_a = &amp;a; // -&gt; &amp;i32
   |             -----
   |             |
   |             first assignment to `ref_a`
   |             help: consider making this binding mutable: `mut ref_a`
24 |         ref_a = &amp;b;            //将引用指向b不可以
   |         ^^^^^^^^^^ cannot assign twice to immutable variable
 
error[E0594]: cannot assign to `*mut_ref_a`, which is behind a `&amp;` reference
  --&gt; src/main.rs:26:9
   |
25 |         let mut mut_ref_a = &amp;a; //mut &amp;i32
   |                             -- help: consider changing this to be a mutable reference: `&amp;mut a`
26 |         *mut_ref_a = 20;       //更改变量本身，不可以
   |         ^^^^^^^^^^^^^^^ `mut_ref_a` is a `&amp;` reference, so the data it refers to cannot be written
 
Some errors have detailed explanations: E0384, E0594.
For more information about an error, try `rustc --explain E0384`.
error: could not compile `option_` due to 2 previous errors
</code></pre>
<p>mut &amp;可以用来充当指针的位置，例如输出一个Box+Option的链表。</p>
<p>为了简便，不实现Display Trait,而是用一个方法</p>
<pre><code class="rust">impl &lt;T:Display&gt; LinkedList&lt;T&gt; &#123;
    pub fn display(&amp;self) &#123;
        let mut curr = &amp;self.head; //curr: mut &amp;Link
        while let Some(node) = curr &#123;
            println!(&quot;&#123;&#125;&quot;,node.data);
            curr = &amp;node.next;
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #03a9f4">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Effective-Rust/" style="color: #ffa2c4">
                Effective Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/01/区别-mut-mut-mut-mut/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/01/Rust通过Box方式实现LinkedList/">
        <h2 class="post-title">Rust通过Box方式实现LinkedList</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/1
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="链表在rust中"><a href="#链表在rust中" class="headerlink" title="链表在rust中"></a>链表在rust中</h1><p>别的语言，学习的差不多了。写个链表试试？</p>
<p>Rust，学习的差不多的，写个链表，逝世！</p>
<p>虽然rust是系统及编程语言，但那和safe代码没有什么关系，在safe代码中，你依旧不能灵活的操纵内存。</p>
<p>代替的可以使用Box来当作指针，但是由于所有权和借用的规则，使得Option+Box这种形式写出的LinkedList既复杂，又低效。但是对于学习来说还是很有帮助的。所以，本篇文章将编码一个支持基础操作的LinkedList，并解释说明那些烦人的细节。</p>
<p>希望本篇文章能对你对Rust的理解有帮助。本文章基于《通过链表学rust》。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们要写一个泛型的链表。使用<code>Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;</code>这样的形式，来组织一个最基本的链式结构。</p>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>使用类型别名是由必要的。Link是如下的别名</p>
<pre><code class="rust">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</code></pre>
<p>这样可以避免冗长且不易阅读的代码。然后请你记住一个重要的，Link不是一个指针类型，你很可能基于C风格语言的习惯将Link看作一个指针——在我们这个例子中不是这样的。但可以做到这样，那是unsafe的事情了。在我们例子中，<strong>Link是一个Option。</strong>使用<code>Option&lt;Box&lt;&gt;&gt;</code>可以模拟出类似指针的东西。但是你在处理LinkedList的时候大可将其当作一个指针来看待。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>我们需要一个T类型的数据，和一个next来“指向”下一个Node。</p>
<pre><code class="C++">struct Node&lt;T&gt; &#123;
    data: T,
    next: Link&lt;T&gt;,
&#125;
</code></pre>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>只需要一个头指针，就可以找到整个LinkedList。这个head类似于C++中的<code>Node*</code>,在构造的时候<code>head = nullptr</code>,就是说，头指针不默认指向一个节点。</p>
<pre><code class="C++">pub struct LinkedList&lt;T&gt; &#123;
    head: Link&lt;T&gt;,
&#125;
</code></pre>
<p>为什么没有提供size？</p>
<p>对于单向链表的size相关操作，需要额外的维护成本。如果使用单项链表，不要求size操作。否则使用双向链表。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new关联方法，返回一个初始化的LinkedList，只需要将head初始化为None即可。</p>
<pre><code class="rust">    pub fn new() -&gt; Self &#123;
        LinkedList &#123;
            head: None,
        &#125;
    &#125;
</code></pre>
<h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><p>头插入一个节点。</p>
<p>在编码之前，我们需要想想如何进行节点的额移动。</p>
<ul>
<li><p>首先，这个操作会改变链表，所以需要&amp;mut self做参数。</p>
</li>
<li><p>在方法体中，新建一个节点，并赋予初值。</p>
</li>
<li><p>让新建节点的next指向头</p>
</li>
<li><p>头指向新建节点</p>
</li>
</ul>
<p>这些操作，你在数据结构中已经看见过了，而且身经百战的你，在经历各种语言的摧残之后，心想：这还不简单？但是rust却给了你当头一棒。你试尽了你能想到的所有办法，却只写出一段自己都不愿意阅读的，撇脚的代码。这就是作者的真实经历。</p>
<p>“独学而无友，则孤陋而寡闻”。是时候看一看别人是怎样写的了。</p>
<pre><code class="rust">    pub fn push_front(&amp;mut self, val: T) &#123;
        let new_node = Box::new(Node &#123;
            data: val,
            next: self.head.take(),
        &#125;);
        self.head = Some(new_node)
    &#125;
</code></pre>
<p>我们来一点点分析</p>
<p>创建一个新的节点</p>
<pre><code class="rust">        let new_node = Box::new(Node &#123;
            data: val,
            next: self.head.take(),
        &#125;);
</code></pre>
<p>其中take方法会将Option设置为None，并返回原先的值。</p>
<p>这几行代码新建了一个节点，还有将head滞空(赋值为None)。</p>
<p>将head指向新建节点，这步只需要将被some新建节点赋值给head即可。</p>
<pre><code class="rust">self.head = Some(new_node)
</code></pre>
<p>因为self是&amp;mut, 所以这里直接使用&#x3D;就可以完成。</p>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>peek方法返回<code>Option&lt;&amp;T&gt;</code>。</p>
<ul>
<li>如果head是一个None，返回None</li>
<li>否则返回Some&lt;&amp;T&gt;</li>
</ul>
<p>你可能会想到match匹配。可以这样做。</p>
<pre><code class="rust">    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; &#123;
        match &amp;self.head &#123;
            None =&gt; None,
            Some(node) =&gt; Some(&amp;node.data)
        &#125;
    &#125;
</code></pre>
<p>&amp;具有最低的优先级,即<code>&amp;(self.head)</code></p>
<p><code>&amp;self.head</code>是必要的。match不会消费对象，但是结构Some<code>Some(node)</code>会转移所有权。就会得到一个编译错误。那是因为我们移动一个已经被借用的值<code>Box obj</code>。这个值已经被self借用了，你却要把它移动给node。</p>
<h3 id="peek-mut"><a href="#peek-mut" class="headerlink" title="peek_mut"></a>peek_mut</h3><p>与peek相同，但是返回可变引用</p>
<pre><code class="rust">    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; &#123;
        match &amp;mut self.head &#123;
            None =&gt; None,
            Some(node) =&gt; Some(&amp; mut node.data)
        &#125;
    &#125;
</code></pre>
<p>同理的，<code>match</code>应当匹配<code>&amp;mut self.head</code>。</p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop究竟该如何操作，我想你在学数据结构的时候都已经快听的耳朵起茧子了额。但是在这里，还是要复述一遍。</p>
<ul>
<li>如果head为空，什么也不做，返回一个具有空语义的对象</li>
<li>获取头的next名为node</li>
<li>头指向node</li>
<li>返回node中的值&#x2F;进行其他的操作</li>
</ul>
<p>用Rust语言来描述，可以用match来匹配head是否为None,如果是返回None,如果不是，会匹配出原来的head叫做node，然后更新head,返回node中的数据即可。</p>
<p>我们可以改变以下实现手法，使用take方法，取得head的所有权。然后再重新赋值head。</p>
<pre><code class="rust">    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; &#123;
        match self.head.take() &#123;
            None =&gt; None,
            Some(node) =&gt; &#123; //node 为原来的head
                self.head = node.next;	//node.next: Link&lt;T&gt; 变为新头
                Some(node.data)	
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><p>我们可以不实现drop，用编译器为我们实现的——调用head的drop。于是drop Box中的对象，然后Box中的对象是一个Node，Node中又含有Link，这会是一个尾递归？不是的，编译器生成的drop会含有其他的操作。这不是一个尾递归。</p>
<p>我们需要手动的为LinkedList实现drop这个trait。具体的做法是</p>
<p>把递归改为迭代，每次获得一个节点的所有权，让后让其离开作用域自动drop，因为是一个循环，所以不会出现栈溢出这种情况。</p>
<pre><code class="rust">impl &lt;T&gt; Drop for LinkedList&lt;T&gt; &#123;
    fn drop(&amp;mut self) &#123;
        let mut curr = self.head.take(); //获得head的所有权
        while let Some (node) = curr &#123;	//让node绑定的对象离开作用域自动drop
            curr = node.next;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>为LinkedList提供迭代器。他们分别是<code>Iter</code>,<code>IntoIter</code>,<code>IterMut</code>。其中<code>Iter</code>,<code>IterMut</code>需要额外注意生命周期。</p>
<h3 id="IntoIter"><a href="#IntoIter" class="headerlink" title="IntoIter"></a>IntoIter</h3><p>IntoIter是最好实现的。因为其再迭代的时候会消耗容器，所以只需要每次pop以下就好了。</p>
<pre><code class="rust">struct IntoIter&lt;T&gt; &#123;
    list: LinkedList&lt;T&gt;,
&#125;

impl &lt;T&gt; Iterator for IntoIter&lt;T&gt; &#123;
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        self.list.pop()
    &#125;
&#125;
</code></pre>
<h3 id="Iter"><a href="#Iter" class="headerlink" title="Iter"></a>Iter</h3><p>Iter就相对比较难一点，我们需要获取容器的不可变引用。并迭代。如何指向链表的下一个节点，是一个问题。</p>
<p>Iter中定义一个<code>curr: Option&lt;T&gt;</code>，指向当前的节点，每次调用next，就返回curr的值，然后更新curr。</p>
<p>还是可以使用match来匹配。</p>
<pre><code class="rust">pub struct Iter &lt;&#39;a, T&gt; &#123;
    curr: Option&lt;&amp;&#39;a Node&lt;T&gt;&gt;,
&#125;

impl &lt;&#39;a, T&gt; Iterator for Iter&lt;&#39;a, T&gt; &#123;
    type Item = &amp;&#39;a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        match self.curr &#123;
            None =&gt; None,
            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref();
                Some(&amp;node.data)
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>由于self中的curr为Option包裹的引用类型，所以match匹配出来的值也是一个&amp;类型，不用再额外添加引用。、</p>
<p>Some的部分值得拿出来好好说说。</p>
<pre><code class="rust">            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref();
                Some(&amp;node.data)
            &#125;
</code></pre>
<p>先搞清楚类型,<code>curr: Option&lt;Node&lt;T&gt;&gt;</code>,<code>node.next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;</code>。我们直接使用<code> self.curr = node.next</code>来赋值，类型不对。<code>Some(&amp;Node) &lt;- Some(Box&lt;Node&lt;T&gt;&gt;)</code>,要是给Box解引用就好了。使用<code>as_deref</code>方法来返回一个解引用(被Some包裹的)。正好合适。</p>
<p>然后返回node中的data即可，别忘了添加&amp;。</p>
<h3 id="IterMut"><a href="#IterMut" class="headerlink" title="IterMut"></a>IterMut</h3><p>IterMut又设计到了可变性。编码要考虑的因素就更多了。</p>
<p>老样子，我们对Iter使用的方法，故技重施看看。</p>
<pre><code class="rust">pub struct IterMut&lt;&#39;a, T&gt; &#123;
    curr: Option&lt;&amp;&#39;a mut Node&lt;T&gt;&gt;
&#125;

impl &lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; &#123;
    type Item = &amp;&#39;a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        match self.curr &#123;
            None =&gt; None,
            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref_mut();
                Some(&amp;mut node.data)
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>会得到这样的编译错误。</p>
<pre><code class="error">error[E0507]: cannot move out of `self.curr.0` which is behind a mutable reference
  --&gt; src\first.rs:88:15
   |
88 |         match self.curr &#123;
   |               ^^^^^^^^^ help: consider borrowing here: `&amp;self.curr`
89 |             None =&gt; None,
90 |             Some(node) =&gt; &#123;
   |                  ----
   |                  |
   |                  data moved here
   |                  move occurs because `node` has type `&amp;mut Node&lt;T&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>编译器说我们移动了以已经绑定可变引用的变量。</p>
<p>奇怪，为什么Iter可以而IterMut不可以呢？原因是不能对<code>&amp;mut &amp; T</code>进行copy，就是没有实现<code>Copy trait</code>,那怎么办？。那就又回到了peek的情况——移动了一个已经被借用的变量。只不过这个变量是一个可变引用<code>&amp;mut</code>。</p>
<p>按照编译器的方法改。你大可试试，会有更多的错误。换一种方法吧。</p>
<p>还是take方法。</p>
<pre><code class="rust">pub struct IterMut&lt;&#39;a, T&gt; &#123;
    curr: Option&lt;&amp;&#39;a mut Node&lt;T&gt;&gt;
&#125;

impl &lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; &#123;
    type Item = &amp;&#39;a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;
        match self.curr.take() &#123;
            None =&gt; None,
            Some(node) =&gt; &#123;
                self.curr = node.next.as_deref_mut();
                Some(&amp;mut node.data)
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="iter-into-iter-iter-mut"><a href="#iter-into-iter-iter-mut" class="headerlink" title="iter into_iter iter_mut"></a>iter into_iter iter_mut</h3><p>LinkedList的这三个方法如下定义。</p>
<pre><code class="rust">    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; &#123;
        Iter &#123;
            curr: self.head.as_deref(),
        &#125;
    &#125;

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; &#123;
        IterMut &#123;
            curr: self.head.as_deref_mut()
        &#125;
    &#125;

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; &#123;
        IntoIter &#123;
            list: self
        &#125;
    &#125;
</code></pre>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code class="rust">fn main() &#123;
    let mut ls = LinkedList::new();
    ls.push_front(12);
    ls.push_front(14);
    ls.push_front(100);
    ls.push_front(222);
    ls.pop();
    assert_eq!(ls.peek(), Some(&amp;100));
    assert_eq!(ls.peek_mut(), Some(&amp;mut 100));
    for val in ls.iter() &#123;
        println!(&quot;&#123;&#125;&quot;,val);
    &#125;
    for val in ls.iter_mut() &#123;
        *val += 1;
        println!(&quot;&#123;&#125;&quot;,val);
    &#125;
    for val in ls.into_iter() &#123;
        println!(&quot;&#123;&#125;&quot;,val);
    &#125;
&#125;
</code></pre>
<p>很好的工作了起来！</p>
<p>再来看看数据量大的时候，会不会栈溢出。</p>
<pre><code class="rust">fn main() &#123;
    let mut ls = LinkedList::new();
    let n: usize = 10000000;
    for i in 0..n &#123;
        ls.push_front(i);
    &#125;
&#125;
</code></pre>
<p>很好，栈没有溢出。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果谁犯下了大罪。我一定让他试试在不看资料的情况下手写一个Option+Box的链表。</p>
<p>玩笑归玩笑，好好的看清楚上面的实现，还是能对所有权和借用和声明周期的理解更上一层楼的。</p>
<p>对于peek,peek_mut等函数，你也可以使用map来实现，但是使用map会获得所所有权，又需要额外的处理。本文保留了match方法。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #ffa2c4">
                Rust
            </a>
        </span>
        
    </div>
    <a href="/2022/10/01/Rust通过Box方式实现LinkedList/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/29/Rust字符串处理/">
        <h2 class="post-title">Rust字符串处理</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/29
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Rust中的字符串"><a href="#Rust中的字符串" class="headerlink" title="Rust中的字符串"></a>Rust中的字符串</h1><p>rust中的字符串是一个 UTF-8 编码的可增长字符串。</p>
<p>String 类型是最常见的字符串类型，拥有对该字符串内容的所有权。它与其借用的对应物，原始的 str 有着密切的关系。</p>
<p>rust中的字符串对新手非常的不友好。由于String是基于utf_8编码的，导致很多操作需要额外的中间层。文篇文章的目的在于理清String的各种处理法。</p>
<h1 id="String的数据结构"><a href="#String的数据结构" class="headerlink" title="String的数据结构"></a>String的数据结构</h1><p>String内含一个Vec<u8>,所以String和Vec的结构完全相同。Vec的实现用了多层的嵌套。这里将String的数据结构直接抽象出来</p>
<p>你可以将String理解为这样的数据结构</p>
<ul>
<li>一个ptr 指向u8数组</li>
<li>len为String的长度</li>
<li>capacity为String的容量。</li>
</ul>
<h1 id="如何处理string"><a href="#如何处理string" class="headerlink" title="如何处理string"></a>如何处理string</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>String提供了很多可以直接更新字符串的方法，例如<code>push</code>、<code>push_str</code>、<code>clean</code>、<code>pop</code>等。</p>
<p>还有一些处理字符串的宏。</p>
<p>这些方法和宏标准库文档都已经写的够好的了，或者你也可以看看rust程序语言设计这本书。我不相信我能比标准库撰写人员有着对标准库更好的解释。这一部分，可以直接阅标准库提供的文档或者书籍。</p>
<p>这里列举出一些常用方法的函数原型</p>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.trim">trim</a>(&amp;self) -&gt; &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a></p>
<p>返回除去前导空格的字符串切片</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.split">split</a>&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/struct.Split.html">Split</a>&lt;’a, P&gt; where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>在此字符串切片的子字符串上进行迭代的迭代器，该子字符串由模式匹配的字符分隔</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.split_at">split_at</a>(&amp;self, mid: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.usize.html">usize</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.tuple.html">(</a>&amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a>, &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.tuple.html">)</a> </p>
<p>在索引处将一个字符串切片分成两个</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.parse">parse</a><F>(&amp;self) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/result/enum.Result.html">Result</a>&lt;F, &lt;F as <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html">FromStr</a>&gt;::<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html#associatedtype.Err">Err</a>&gt;where   F: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html">FromStr</a> </p>
<p>将此字符串切片解析为另一种类型</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.repeat">repeat</a>(&amp;self, n: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.usize.html">usize</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String </a>  </p>
<p>通过重复字符串 <code>n</code> 次来创建新的 <a href="%5Chttps://rustwiki.org/zh-CN/std/string/struct.String.html"><code>String</code></a></p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.lines">lines</a>(&amp;self) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/struct.Lines.html">Lines</a>&lt;’_&gt; </p>
<p>在字符串的各行上进行迭代的迭代器，作为字符串切片。</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.replace">replace</a>&lt;’a, P&gt;(&amp;’a self, from: P, to: &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String</a>where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>用另一个字符串替换模式的所有匹配项。</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.replacen">replacen</a>&lt;’a, P&gt;(&amp;’a self, pat: P, to: &amp;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.str.html">str</a>, count: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.usize.html">usize</a>) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String</a>where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>用另一个字符串替换模式的前 N 个匹配项</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.find">find</a>&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/option/enum.Option.html">Option</a>&lt;usize&gt;where   P: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/str/pattern/trait.Pattern.html">Pattern</a>&lt;’a&gt; </p>
<p>返回此字符串切片中与模式匹配的第一个字符的字节索引</p>
</blockquote>
<blockquote>
<p>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.get">get</a><I>(&amp;self, i: I) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/option/enum.Option.html">Option</a>&lt;&amp;&lt;I as <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/slice/trait.SliceIndex.html">SliceIndex</a>&lt;str&gt;&gt;::<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/slice/trait.SliceIndex.html#associatedtype.Output">Output</a>&gt;  where I: SliceIndex&lt;str&gt; </p>
<p>返回 <code>str</code> 的子切片</p>
</blockquote>
<p>还有他们的变体等等。例如<code>rfind</code>,<code>get_mut</code>,<code>rsplit</code>等。</p>
<h2 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h2><p>由于String不能像C++中的std::string直接进行下标运算符，很多操作都需要将其转为vec来进行处理。我们需要这两个方法</p>
<ul>
<li><h4 id="pub-fn-into-bytes-self-gt-Vec-lt-u8-Global-gt"><a href="#pub-fn-into-bytes-self-gt-Vec-lt-u8-Global-gt" class="headerlink" title="pub fn into_bytes(self) -&gt; Vec&lt;u8, Global&gt;"></a>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.into_bytes">into_bytes</a>(self) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/vec/struct.Vec.html">Vec</a>&lt;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.u8.html">u8</a>, <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/alloc/struct.Global.html">Global</a>&gt;</h4></li>
<li><h4 id="pub-fn-from-utf8-vec-Vec-lt-u8-Global-gt-gt-Result-lt-String-FromUtf8Error-gt"><a href="#pub-fn-from-utf8-vec-Vec-lt-u8-Global-gt-gt-Result-lt-String-FromUtf8Error-gt" class="headerlink" title="pub fn from_utf8(vec: Vec&lt;u8, Global&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;"></a>pub fn <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html#method.from_utf8">from_utf8</a>(vec: <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/vec/struct.Vec.html">Vec</a>&lt;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/primitive.u8.html">u8</a>, <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/alloc/struct.Global.html">Global</a>&gt;) -&gt; <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/result/enum.Result.html">Result</a>&lt;<a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.String.html">String</a>, <a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/string/struct.FromUtf8Error.html">FromUtf8Error</a>&gt;</h4></li>
</ul>
<p>你可以点击链接看看标准库的文档。</p>
<p>例如，我们要对输入的字符串只去回车，可以将String转为Vec&#x2F;u8数组，然后对Vec&#x2F;u8数组操作再转为String。</p>
<pre><code class="rust">    let s = String::from(&quot;我爱你rust\n&quot;);
    let mut vec: Vec&lt;u8&gt; = s.into_bytes();
    if vec[vec.len()-1] == b&#39;\n&#39; &#123;
        vec.remove(vec.len()-1);
    &#125;
    let s = String::from_utf8(vec).unwrap();
    println!(&quot;&#123;:#?&#125;&quot;,s);
</code></pre>
<p>转换来转换去不会影响性能吗？不会的，你看这两个方法的函数签名。是所有权在转移而已，并没有复制内部的数据结构。</p>
<p>对每个字符串中的字符之间插入空格</p>
<pre><code class="rust">    let s = String::from(&quot;helloworld&quot;);
    let mut vec: Vec&lt;u8&gt; = s.into_bytes();
    let mut i = 1;
    let mut n = vec.len()-1;
    while n != 0 &#123;
        vec.insert(i,b&#39; &#39;);
        i += 2;
        n -= 1;
    &#125;
    let s = String::from_utf8(vec).unwrap();
    println!(&quot;&#123;:#?&#125;&quot;,s);
</code></pre>
<p>把字符串拆分为不同的单词</p>
<pre><code class="rust">    let s = String::from(&quot;hello world hello rust&quot;);
    let vec: Vec&lt;u8&gt; = s.into_bytes();
    let mut words = vec![];
    let mut f = 0;
    let mut p = false;
    for i in 0..vec.len() &#123;
        if (b&#39;a&#39;..=b&#39;z&#39;).contains(&amp;vec[i]) &amp;&amp; !p &#123;
            p = true;
            f = i;
        &#125; else if vec[i] == b&#39; &#39;&#123;
            p = false;
            words.push(String::from_utf8(Vec::from(&amp;vec[f..i])).unwrap());
        &#125; else if i == vec.len()-1 &#123;
            words.push(String::from_utf8(Vec::from(&amp;vec[f..=i])).unwrap());
        &#125;
    &#125;
    for word in words &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>好家伙，就是为了这点醋才包的饺子。</p>
<h2 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h2><p>rust使用迭代器+闭包的形式来支持函数式编程。还是上述拆分字符串为单词的问题。我们使用函数式会很好的解决。</p>
<pre><code class="rust">    let s = String::from(&quot;hello word hello rust&quot;);
    let words = s.split(&#39; &#39;)
        .map(|s| s.to_string())
        .collect::&lt;Vec&lt;String&gt;&gt;();
    for word in words &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>就是两个字，优雅！</p>
<p>类似的，还有<code>filter</code>,<code>folder</code>,<code>take_while</code>等很多的FP方法。</p>
<p>删除字符串中的所有回车+空格，我们可以使用retain方法。</p>
<pre><code class="rust">    let mut s = String::from(&quot;hello _world \n \n _hello _rust &quot;);
    s.retain(|ch| ![&#39;\n&#39;,&#39; &#39;].contains(&amp;ch));
    println!(&quot;&#123;&#125;&quot;,s);
</code></pre>
<p>还是TM的优雅。如果是用C写相同的功能需要多少倍的代码和时间。</p>
<p>可以看出，函数式编程是一个很好的处理问题的方式，不单单是在处理String中。</p>
<h2 id="结构化-函数式"><a href="#结构化-函数式" class="headerlink" title="结构化+函数式"></a>结构化+函数式</h2><p>你可以将结构化编程和函数式编程组合起来。也是一个不错的选择。还是上述的问题。我们可以这样解决。</p>
<pre><code class="rust">    let s = String::from(&quot;hello word hello rust&quot;);
    let mut words = vec![];
    for word in s.split(&#39; &#39;) &#123;
        words.push(word.to_string());
    &#125;
    for word in words &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>也是同样的优雅。</p>
<h2 id="处理字"><a href="#处理字" class="headerlink" title="处理字"></a>处理字</h2><p>我们里的字，并不是指的计算机系统中的字。而是日常生活中的字。比如’中’是一个字。</p>
<p>可以使用chars这个迭代器来迭代字。</p>
<pre><code class="rust">    let s = String::from(&quot;春江潮水连海平&quot;);
    for word in s.chars() &#123;
        println!(&quot;&#123;&#125;&quot;,word);
    &#125;
</code></pre>
<p>注意用chars处理英文字母的时候，得到的是字符。有或者是处理其他像英文那样的语言。得到的都是单个字符。</p>
<h2 id="处理原始字节"><a href="#处理原始字节" class="headerlink" title="处理原始字节"></a>处理原始字节</h2><p>可以使用bytes来迭代String内部的字节数组</p>
<pre><code class="rust">let s = String::from(&quot;hello _world \n \n _hello _rust &quot;);
for byte in s.bytes() &#123;
    print!(&quot;&#123;&#125; &quot;,byte);
&#125;
</code></pre>
<p>输出：</p>
<blockquote>
<p>104 101 108 108 111 32 95 119 111 114 108 100 32 10 32 10 32 95 104 101 108 108 111 32 95 114 117 115 116 32 </p>
</blockquote>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>一提到字符串的拼接，你第一印象是怎么处理。直接使用+？你可能是一个C++程序员。调用方法？那你可能是一个java程序员。</p>
<p>rust对于上述的两种方式都有提供。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用+"></a>使用+</h3><p>我们看一看std::ops::Add这个trait的定义</p>
<pre><code class="rust">pub trait Add&lt;Rhs = Self&gt; &#123;
    /// The resulting type after applying the `+` operator.
    type Output;	//关联类型
    fn add(self, rhs: Rhs) -&gt; Self::Output; //必须定义的add方法，zhu
&#125;
</code></pre>
<p>标准库为String实现了类似这样的Add trait<code>fn add(self, s: &amp;str) -&gt; String</code>。</p>
<p>我们不能直接将两个String类型的对象相加，但是可以String+字符串面量。并且消耗self。</p>
<p>也就是说，我们进行连+的时候，应当这样写。</p>
<pre><code class="rust">    let hello = String::from(&quot;hello&quot;);
    let world = String::from(&quot;world&quot;);
    let rust = String::from(&quot;rust&quot;);
    // let s = hello + world; error
    //整个表达式从左向右求值。
    let s = hello + &quot; &quot; + &amp;world + &quot; hello &quot; + &amp;rust;		//&amp;String -&gt; &amp;str,隐式的解引用类型转换
    println!(&quot;&#123;s&#125;&quot;);
</code></pre>
<p>这语法也是没谁了。怎么会有这样的不一致性。对String进行+操作左右类型还不一样。所有权还会丢失。</p>
<p>但实际想想标准库这样做是有依据的。</p>
<ul>
<li>左值转移所有权给返回值，这样做可以避免拷贝。</li>
<li>提供了更加统一的接口</li>
</ul>
<h3 id="使用宏"><a href="#使用宏" class="headerlink" title="使用宏"></a>使用宏</h3><p>format！可以拼接String</p>
<pre><code class="rust">    let hello = String::from(&quot;hello&quot;);
    let world = String::from(&quot;world&quot;);
    let rust = String::from(&quot;rust&quot;);
    let s = format!(&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;,hello,world,&quot;hello&quot;,rust);
    println!(&quot;&#123;s&#125;&quot;);
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总而言之，字符串还是很复杂的。不同的语言选择了不同的向开发者展示其复杂性的方式。Rust 选择了以准确的方式处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着开发者们必须更多的思考如何预先处理 UTF-8 数据。这种权衡取舍相比其他语言更多的暴露出了字符串的复杂性，不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。	————rust程序语言设计</p>
<p>其实学习如何处理字符串，就是在学习如何使用标准库。如果你对标准库中的一些宏和函数了如指掌。处理字符串对你来说也应当是小菜一碟。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #00a596">
                Rust
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Rust-Library/" style="color: #00a596">
                Rust Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/29/Rust字符串处理/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/28/type-traits源码分析-三/">
        <h2 class="post-title">Type-Traits源码分析(三)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/28
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>在第三章中，会有一些新的东西，不同于一二章，TMP开始加速了！你将会看见额外的一些元函数实现手法，你肯定会惊讶它的巧妙，特别是void_t类型。总之，做好准备，这章的难度可不同于以往了！</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="is-one-of"><a href="#is-one-of" class="headerlink" title="__is_one_of"></a>__is_one_of</h2><p>传入一个类型T和一个参数包Ts，返回其T是不是Ts其中的一个类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>有了这个type_traits，可以更加轻松的实现其他type_traits。</p>
<p>这个type_traits的实现方式也是比较的有意思。我们可以有很多种方式来实现<code>__is_one_of</code>这个元函数，包括使用模板递归继承的方式来实现。gcc则是采用的参数包模式展开的方式。</p>
<pre><code class="C++">  template&lt;typename _Tp, typename... _Types&gt;
    using __is_one_of = __or_&lt;is_same&lt;_Tp, _Types&gt;...&gt;; //用is_same这个模式来对参数包展开，相当于每个类型都和_Tp应用于is_same,再用作于__or_，即可获得结果。
</code></pre>
<h2 id="is-signed-x2F-unsinged-integer"><a href="#is-signed-x2F-unsinged-integer" class="headerlink" title="__is_signed&#x2F;unsinged_integer"></a>__is_signed&#x2F;unsinged_integer</h2><p>入一个类型，返回其是不是，如一个有符号&#x2F;无符号的整数果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<pre><code class="C++">  // Check if a type is one of the signed integer types.
  template&lt;typename _Tp&gt;
    using __is_signed_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;, //继承__is_one_of&lt;符合要求的类型参数包&gt;
      signed char, signed short, signed int, signed long,
      signed long long
#if defined(__GLIBCXX_TYPE_INT_N_0)			//条件编译大可忽略
      , signed __GLIBCXX_TYPE_INT_N_0
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
      , signed __GLIBCXX_TYPE_INT_N_1
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
      , signed __GLIBCXX_TYPE_INT_N_2
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
      , signed __GLIBCXX_TYPE_INT_N_3
#endif
      &gt;;		
</code></pre>
<p>实现方式大同小异</p>
<pre><code class="C++">  // Check if a type is one of the unsigned integer types.
  template&lt;typename _Tp&gt;
    using __is_unsigned_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;,
      unsigned char, unsigned short, unsigned int, unsigned long,
      unsigned long long
#if defined(__GLIBCXX_TYPE_INT_N_0)
      , unsigned __GLIBCXX_TYPE_INT_N_0
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
      , unsigned __GLIBCXX_TYPE_INT_N_1
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
      , unsigned __GLIBCXX_TYPE_INT_N_2
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
      , unsigned __GLIBCXX_TYPE_INT_N_3
#endif
      &gt;;
</code></pre>
<h2 id="is-standard-integer"><a href="#is-standard-integer" class="headerlink" title="__is_standard_integer"></a>__is_standard_integer</h2><p>传入一个类型，返回其是不是标准定义的整数，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>这个type_traits是其他type_traits组合起来的一个别名。这也是元函数的一个实现手法。</p>
<pre><code class="C++">  // Check if a type is one of the signed or unsigned integer types.
  template&lt;typename _Tp&gt;
    using __is_standard_integer
      = __or_&lt;__is_signed_integer&lt;_Tp&gt;, __is_unsigned_integer&lt;_Tp&gt;&gt;;
</code></pre>
<h2 id="void-t"><a href="#void-t" class="headerlink" title="void_t"></a>void_t</h2><p>void_t，就是一个void的别名，但是带有类型参数。你会说：这不是脱裤子放屁吗？有什么用，我直接写void不好吗？</p>
<p>实际上void_t是为TMP服务的，并不是让你当作返回值&#x2F;类型声明的。我们可以通过SFINE+void_t这种TMP的手法来实现看似不可能的元函数。你马上就会看到</p>
<p>至于你说为什么叫void_t而不是叫其他类型，那你去问问C++委员会吧，顺便告诉我，我也想知道。</p>
<pre><code class="C++">  // __void_t (std::void_t for C++11)
  template&lt;typename...&gt; using __void_t = void;
</code></pre>
<h2 id="is-referenceable"><a href="#is-referenceable" class="headerlink" title="__is_referenceable"></a>__is_referenceable</h2><p>传入一个类型，返回其是不是可引用的，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>需要注意：一个类型T，如果已经是一个引用，无论是左值还是右值，均不可再添加&amp;，就是说没有<code>(int &amp;) &amp;</code>这样的语法，即引用的引用。但是在模板中，有引用的折叠，别把这件事情忘了。</p>
<p>拿什么是不可引用的呢？</p>
<ul>
<li>void</li>
<li>例如<code>int () const</code>这样的函数</li>
</ul>
<pre><code class="C++">  // Utility to detect referenceable types ([defns.referenceable]).

  template&lt;typename _Tp, typename = void&gt; //第二个类型参数用于辅助，不需要有名字。
    struct __is_referenceable
    : public false_type
    &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct __is_referenceable&lt;_Tp, __void_t&lt;_Tp&amp;&gt;&gt; //如果是一个不可引用的类型，匹配这个特例化失败，转而匹配主模板
    : public true_type
    &#123; &#125;;
</code></pre>
<h2 id="一些特殊的类型"><a href="#一些特殊的类型" class="headerlink" title="一些特殊的类型"></a>一些特殊的类型</h2><p>C++中有一些类型，具有独特的语义。例如 无其他动作的构造。内存布局方式是标准的。无其他动作的拷贝。一个抽象基类，一个被final修饰的类,等等deng’den。想对这些类型实现type_traits不是不行，但是编译器为我们内置这样的功能可能会更好，编译速度也会更加快速。</p>
<h3 id="trivial"><a href="#trivial" class="headerlink" title="trivial"></a>trivial</h3><p>一个trivial需要具有一下的性质</p>
<ul>
<li>有默认构造函数，编译器生成的，或者是显示的&#x3D;default，只能是这两种情况。</li>
<li>内存空间是连续的</li>
<li>不能包含虚函数和虚基类。</li>
<li>成员可以具有不同的访问权限</li>
<li>拥有平凡的拷贝构造函数和移动构造函数。默认的意思同上，也可以使用&#x3D;default。</li>
<li>拥有平凡的拷贝赋值运算符和移动赋值运算符。</li>
</ul>
<h3 id="stand-layout"><a href="#stand-layout" class="headerlink" title="stand_layout"></a>stand_layout</h3><p>一个stand_layout的对象，需要满足以下几种性质</p>
<ul>
<li>所有非静态成员拥有相同的访问级别</li>
<li>类中第一个非静态类型与基类不是同一个类型</li>
<li>所有非静态数据成员都符合标准布局的要求</li>
<li>没有虚类和虚基类</li>
<li>继承时需要满足以下两个情况之一<ol>
<li>派生类中有非静态类，那么这个派生类只能有且只有一个仅包含了静态成员的基类。</li>
<li>基类有非静态成员，那么派生类中不允许有非静态成员。</li>
</ol>
</li>
</ul>
<p>ps：这里涉及到C++对象模型，感兴趣的可以自行学习。</p>
<h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>pod类型需要满足两个要求</p>
<ul>
<li>是一个人trivial类型</li>
<li>是一个stand_layout类型</li>
</ul>
<p>pod类型的一些优势&#x2F;特点</p>
<ul>
<li>POD类型兼容C内存布局，C++可以直接使用C库函数操作POD数据类型，POD类型在C和C++间的操作总是安全的</li>
<li>POD类型可以直接使用字节赋值，使用C语言库函数进行二进制形式的数据交换，包括但不限于如下操作<code>memmove</code>,<code>memcpy</code>等</li>
<li>静态初始化在很多时候可以提高程序性能，而POD类型的静态初始化非常简单（放入目标文件的<code>.bss</code>段，在初始化时直接赋0）</li>
<li>虽然与C完全兼容，但是仍然可以有成员函数</li>
<li>有更长的生命周期（从资源获取到资源释放），非POD类型的生命周期从构造函数结束到析构函数结束</li>
<li>POD类型对象的前部没有填充字节，因此对象指针等于对象第一个成员的指针</li>
</ul>
<p>ps：还是涉及到C++对象模型，有点头秃，大伙看看就好，毕竟术业有专攻。编写应用层C++&#x2F;非底层库看看就好。</p>
<blockquote>
<p>STL的一些算法为了优化性能就会使用is_pod+标签分派的手法来优化性能。在一些很老的标准库中，你会看见对is_pod的手动实现</p>
</blockquote>
<h3 id="literal-type"><a href="#literal-type" class="headerlink" title="literal_type"></a>literal_type</h3><p>简单的说，就可以在用于编译期运算的对象。注意其和字面量的区别。</p>
<h2 id="还有一些编译器为我们内置的type-traits"><a href="#还有一些编译器为我们内置的type-traits" class="headerlink" title="还有一些编译器为我们内置的type_traits"></a>还有一些编译器为我们内置的type_traits</h2><p>这些type_traits的共呢个正如他们的名字所言，你唯一搞不懂的，应当是什么是POD类型？什么又是trivially_copyable性质？</p>
<pre><code class="C++"> /// is_trivial
//普通类型是其存储是连续的普通可复制的，并且仅支持静态默认初始化，无论是否为 cv 限定。它包括标量类型，平凡类和任何此类类型的数组。其实现也是编译器内置的。
  template&lt;typename _Tp&gt;
    struct is_trivial 
    : public integral_constant&lt;bool, __is_trivial(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;), //这里的静态断言，我们在前面说过了，不再解释，下同。
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  // is_trivially_copyable
  template&lt;typename _Tp&gt;
    struct is_trivially_copyable 	//是否具有平凡的拷贝
    : public integral_constant&lt;bool, __is_trivially_copyable(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_standard_layout
  template&lt;typename _Tp&gt;
    struct is_standard_layout	//是否是一个标准布局
    : public integral_constant&lt;bool, __is_standard_layout(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_pod (deprecated in C++20) C++20中已经废弃
  // Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.
  template&lt;typename _Tp&gt;	
    struct
    _GLIBCXX20_DEPRECATED(&quot;use is_standard_layout &amp;&amp; is_trivial instead&quot;)
    is_pod
    : public integral_constant&lt;bool, __is_pod(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_literal_type
  //17开始 20弃用
  template&lt;typename _Tp&gt;
    struct
    _GLIBCXX17_DEPRECATED
    is_literal_type 		//是否是一个字面类型
    : public integral_constant&lt;bool, __is_literal_type(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_empty
  template&lt;typename _Tp&gt;
    struct is_empty			//是否是一个空类型，即类中为空实现
    : public integral_constant&lt;bool, __is_empty(_Tp)&gt;
    &#123; &#125;;

  /// is_polymorphic
  template&lt;typename _Tp&gt;
    struct is_polymorphic		// 是否是一个多态类
    : public integral_constant&lt;bool, __is_polymorphic(_Tp)&gt;
    &#123; &#125;;

#if __cplusplus &gt;= 201402L
#define __cpp_lib_is_final 201402L
  /// is_final
  template&lt;typename _Tp&gt;
    struct is_final		
    : public integral_constant&lt;bool, __is_final(_Tp)&gt;
    &#123; &#125;;
#endif

  /// is_abstract
  template&lt;typename _Tp&gt;
    struct is_abstract
    : public integral_constant&lt;bool, __is_abstract(_Tp)&gt;
    &#123; &#125;;
</code></pre>
<h2 id="is-signed"><a href="#is-signed" class="headerlink" title="is_signed"></a>is_signed</h2><pre><code class="C++">template&lt;typename _Tp,
  bool = is_arithmetic&lt;_Tp&gt;::value&gt; //默认参数是一个bool值,来判断书不是算数类型
  struct __is_signed_helper
  : public false_type &#123; &#125;;

template&lt;typename _Tp&gt;
  struct __is_signed_helper&lt;_Tp, true&gt;	//蕴含着是一个符号类型应当先是算数类型
  : public integral_constant&lt;bool, _Tp(-1) &lt; _Tp(0)&gt;	//如果是一个有符号类型，那么_Tp(-1) &lt; _Tp(0)得到的结果将会是false，是一个无符号类型，-1，会下溢结果为true。
  &#123; &#125;;

/// is_signed
template&lt;typename _Tp&gt;
  struct is_signed
  : public __is_signed_helper&lt;_Tp&gt;::type
  &#123; &#125;
</code></pre>
<h2 id="is-unsigned"><a href="#is-unsigned" class="headerlink" title="is_unsigned"></a>is_unsigned</h2><pre><code class="C++">  /// is_unsigned
  template&lt;typename _Tp&gt;
    struct is_unsigned
    : public __and_&lt;is_arithmetic&lt;_Tp&gt;/*也可以不加这个元函数，is_singed中有*/, __not_&lt;is_signed&lt;_Tp&gt;&gt;&gt; //算数类型的同时对is_singed取反
    &#123; &#125;;
</code></pre>
<h2 id="decltype手法"><a href="#decltype手法" class="headerlink" title="decltype手法"></a>decltype手法</h2><p>C++11中新增了decltype关键字，目的就是解决TMP中的一些问题。decltype会对表达式求值，只会根据表达式来推导类型，这点牢记。我不打算说明decltype的所有细节，你可以查阅资料来了解相关知识。decltype为TMP的实现提供了更多的可能性。decltype+SFINAE也是TMP中的一种很巧妙的手法。</p>
<h2 id="declval"><a href="#declval" class="headerlink" title="declval"></a>declval</h2><p>declval是一个函数，只有声明，没有实现，目的很简单，服务于TMP。因此，关于declval的所有操作，均在编译时期发生。</p>
<pre><code class="C++">  /**
   *  @brief  Utility to simplify expressions used in unevaluated operands
   *  @ingroup utilities
   */
//提供了两个的重载版本
  template&lt;typename _Tp, typename _Up = _Tp&amp;&amp;&gt;
    _Up
    __declval(int);

  template&lt;typename _Tp&gt;
    _Tp
    __declval(long);

  template&lt;typename _Tp&gt;
    auto declval() noexcept -&gt; decltype(__declval&lt;_Tp&gt;(0)); //尾置返回类型
</code></pre>
<h2 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h2><p>如果T是数组类型，则提供成员常量等于数组第nth维的元素数。或者T是其他类型，或者数组的第0维数为无界的并且nth&#x3D;0，则值为0。</p>
<p>你可能会疑惑为什么第0维是无界的时候值为0，第1，2，…维不行吗？别忘了C的语法——要确定数组的列数。</p>
<pre><code class="C++">  /// extent
  template&lt;typename, unsigned _Uint&gt;	
    struct extent
    : public integral_constant&lt;std::size_t, 0&gt; &#123; &#125;;	  //T不是数组类型，值为0

  template&lt;typename _Tp, unsigned _Uint, std::size_t _Size&gt;
    struct extent&lt;_Tp[_Size], _Uint&gt;
    : public integral_constant&lt;std::size_t,
                   _Uint == 0 ? _Size : extent&lt;_Tp,   //三目运算符
                               _Uint - 1&gt;::value&gt;	//递归条件_Uint == 0，在_Uint==0的时候，编译器推断的size正好是nth的长度，实现很巧妙，多看几眼慢慢搞清顺序。
    &#123; &#125;;

  template&lt;typename _Tp, unsigned _Uint&gt;
    struct extent&lt;_Tp[], _Uint&gt;				//如果是一个无界数组
    : public integral_constant&lt;std::size_t,
                   _Uint == 0 ? 0 : extent&lt;_Tp,	//如果是第0维，那么值就是0，否则就递归的继承，回到了上述的情况
                               _Uint - 1&gt;::value&gt; 
    &#123; &#125;;
</code></pre>
<p>用法：</p>
<pre><code class="C++">int main() &#123;
    int arr [][3][2] = &#123;&#125;;
    cout &lt;&lt; std::extent&lt;int[][3][5],0&gt;::value &lt;&lt; endl;  //0
    cout &lt;&lt; std::extent&lt;int[][3][5],1&gt;::value &lt;&lt; endl;  //3
    cout &lt;&lt; std::extent&lt;int[][3][5],2&gt;::value &lt;&lt; endl;  //5
    int arr1[1][2];
    cout &lt;&lt; std::extent&lt;decltype(arr1),0&gt;::value &lt;&lt; endl;   //1
    cout &lt;&lt; std::extent&lt;decltype(arr1),1&gt;::value &lt;&lt; endl;   //2
    
    //decltype(arr)的结果为什么超出我么的预期？gcc出bug了吗？
    cout &lt;&lt; std::extent&lt;decltype(arr),0&gt;::value &lt;&lt; endl;    //0
    cout &lt;&lt; std::extent&lt;decltype(arr),1&gt;::value &lt;&lt; endl;    //0
    cout &lt;&lt; std::extent&lt;decltype(arr),2&gt;::value &lt;&lt; endl;    //0
    return 0;
&#125;
</code></pre>
<p>其实decltype的推导arr的结果为<code>[0][3][2]</code>。是不同于直接传递<code>int[][3][5]</code>的。decltype的推断出一个有界数组，而直接传递arr，arr被当作一个无界数组。</p>
<h2 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h2><p>传入一个类型，返回其数组的维数。</p>
<p>同样是使用递归+继承的方式来实现。</p>
<pre><code class="C++">  /// rank
  template&lt;typename&gt;
    struct rank
    : public integral_constant&lt;std::size_t, 0&gt; &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct rank&lt;_Tp[_Size]&gt;
    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct rank&lt;_Tp[]&gt;
    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; &#123; &#125;;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章更加深入的了解了type_traits的更加高阶的实现技巧。但这还只是TMP的冰山一角而已。无论难度如何，总之，还能够接受。介绍了一些维TMP服务的基本元函数，例如declval等，虽然定义很短，但是很复杂也巧妙。</p>
<p>下一章，会更加深入的分析type_traits,前三章分析的type_traits的耦合度很低，很多的tyep_traits都相对独立。而后些章节。那些type_traits都需要很多的元函数做支撑。并且还会有更加复杂的TMP实现手法等着你。</p>
<p>至此，type_traits的源码差不多分析的近900行，还有剩下的2000多行等待我们探索。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #03a9f4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #03a9f4">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/28/type-traits源码分析-三/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/type-traits源码分析-二-/">
        <h2 class="post-title">Type-Traits源码分析(二)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>在一中，介绍了一些type_trait的基本设施, 很轻松，唯一比较复杂的就是is_pointer。在二中，将继续探索tyep_traits中的基本设施——这些设施在TMP中，撰写库的时候经常用到。这篇文章不会涉及到一些高级的技巧。这些技巧放在后面分析。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="元函数的实现技巧"><a href="#元函数的实现技巧" class="headerlink" title="元函数的实现技巧"></a>元函数的实现技巧</h2><p>在标准库中，或者自己想要撰写元函数，可以使用这样一种手法。例如想实现一个名为XXX的元函数。</p>
<p>可以另外定义一个元函数叫做XXX_helper&#x2F;XXX_impl(随你的喜好，叫什么猫猫狗狗也没有问题)来解决核心的部分。</p>
<p>而XXX这个元函数，做一些辅助性的操作，例如移除const，volatile。让后让XXX继承XXX_helper来实现功能。</p>
<h2 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h2><p>传入一个类型，返回其是不是void，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>真正的实现是<code>__is_void_helper</code>，而<code>is_void</code>做一些辅助性的操作。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_void_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_void_helper&lt;void&gt;
    : public true_type &#123; &#125;;

  /// is_void
  template&lt;typename _Tp&gt;
    struct is_void
    : public __is_void_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //移除const volatile
    &#123; &#125;;
</code></pre>
<h2 id="is-integral"><a href="#is-integral" class="headerlink" title="is_integral"></a>is_integral</h2><p>传入一个类型，返回其是不是integral，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p><code>integral</code>可以理解为整形，包括无符号类型。或者随你怎么理解都行，只要你看到了实现，你就知道了他是什么意思。</p>
<p>同样的<code>__is_integral_helper</code>做的具体的操作，有很多个特例化模板。你会说编写一个宏更方便不是吗？也许是的！</p>
<pre><code class="C++"> template&lt;typename&gt;
    struct __is_integral_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;bool&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;char&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;signed char&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned char&gt;
    : public true_type &#123; &#125;;

  // We want is_integral&lt;wchar_t&gt; to be true (and make_signed/unsigned to work)
  // even when libc doesn&#39;t provide working &lt;wchar.h&gt; and related functions,
  // so check __WCHAR_TYPE__ instead of _GLIBCXX_USE_WCHAR_T.
#ifdef __WCHAR_TYPE__
  template&lt;&gt;
    struct __is_integral_helper&lt;wchar_t&gt;
    : public true_type &#123; &#125;;
#endif

#ifdef _GLIBCXX_USE_CHAR8_T
  template&lt;&gt;
    struct __is_integral_helper&lt;char8_t&gt;
    : public true_type &#123; &#125;;
#endif

  template&lt;&gt;
    struct __is_integral_helper&lt;char16_t&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;char32_t&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;short&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned short&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;int&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned int&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;long long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned long long&gt;
    : public true_type &#123; &#125;;

  // Conditionalizing on __STRICT_ANSI__ here will break any port that
  // uses one of these types for size_t.
#if defined(__GLIBCXX_TYPE_INT_N_0) //这些条件编译你大可忽略掉，有兴趣也可以看看。
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_0&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_0&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_1&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_1&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_2&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_2&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_3&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_3&gt;
    : public true_type &#123; &#125;;
#endif

  /// is_integral
  template&lt;typename _Tp&gt;
    struct is_integral
    : public __is_integral_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //与is_void使用相同的手法
    &#123; &#125;;
</code></pre>
<h2 id="is-floating-point"><a href="#is-floating-point" class="headerlink" title="is_floating_point"></a>is_floating_point</h2><p>传入一个类型，返回其是不是浮点类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>如果你会了is_integral,那么is_floating_point也无需多言了。</p>
<pre><code class="C++"> template&lt;typename&gt;
    struct __is_floating_point_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;float&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;double&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;long double&gt;
    : public true_type &#123; &#125;;

#if !defined(__STRICT_ANSI__) &amp;&amp; defined(_GLIBCXX_USE_FLOAT128) //同样是条件编译，可忽略
  template&lt;&gt;
    struct __is_floating_point_helper&lt;__float128&gt;
    : public true_type &#123; &#125;;
#endif

  /// is_floating_point
  template&lt;typename _Tp&gt;
    struct is_floating_point
    : public __is_floating_point_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-array"><a href="#is-array" class="headerlink" title="is_array"></a>is_array</h2><p>传入一个类型，返回其是不是数组(有界的&#x2F;无界的)，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>老方法了，主模板+偏特化。值得注意的是，T*不同于T[]和T[N]。例如</p>
<pre><code class="C++">int main() &#123;
    int nums[10] = &#123;1,2,3,4&#125;;
    cout &lt;&lt; std::is_array&lt;decltype(nums)&gt;::value &lt;&lt; endl; //true
    int * const p = nums;
    cout &lt;&lt; std::is_array&lt;decltype(p)&gt;::value &lt;&lt; endl;	//false
    return 0;
&#125;
</code></pre>
<pre><code class="C++">    /// is_array
    // 区别T *, T[], T[N]的不同
  template&lt;typename&gt;
    struct is_array
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct is_array&lt;_Tp[_Size]&gt;	//有界数组
    : public true_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_array&lt;_Tp[]&gt; //无界数组
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-pointer"><a href="#is-pointer" class="headerlink" title="is_pointer"></a>is_pointer</h2><p>传入一个类型，返回其是不是指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>注意<code>const *</code>,<code>* const</code>的不同，前者不是指针具有常量性质，后者才是。</p>
<pre><code class="C++">template&lt;typename&gt;
    struct __is_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct __is_pointer_helper&lt;_Tp*&gt;
    : public true_type &#123; &#125;;

  /// is_pointer
  template&lt;typename _Tp&gt;
    struct is_pointer
    : public __is_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //remove_cv
    &#123; &#125;;
</code></pre>
<h2 id="is-complete-or-unbounded"><a href="#is-complete-or-unbounded" class="headerlink" title="__is_complete_or_unbounded"></a>__is_complete_or_unbounded</h2><p>传入一个类型，返回其是不是完整的或者无界的，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>因为这不是一个最终对外提供的接口。所以可以使用constexpr函数的方式来实现。</p>
<p>首先我们应当知道的一个前置知识：如果是一个类型是非完整类型，或者无界类型，sizeof 会无法应用。例如</p>
<pre><code class="C++">template&lt;typename T&gt;
struct size_is &#123;
    static constexpr size_t value = sizeof(T);
&#125;;
class A; //A仅有声明，是一个非完整类型
int main() &#123;
    cout &lt;&lt; size_is&lt;int&gt;::value &lt;&lt; endl; 	//ok
    cout &lt;&lt; size_is&lt;int[]&gt;::value &lt;&lt; endl;	//error
    cout &lt;&lt; size_is&lt;A&gt;::value &lt;&lt; endl;		//error
    return 0;
&#125;
</code></pre>
<p>一个无界&#x2F;不完整类型还包括</p>
<ul>
<li>引用</li>
<li>函数</li>
<li>void</li>
<li>无界数组</li>
</ul>
<pre><code class="C++">// Helper functions that return false_type for incomplete classes,
  // incomplete unions and arrays of known bound from those.
//为不完整的类、不完整的联合和已知边界数组返回 false_type 的辅助函数。
template &lt;typename _Tp, size_t = sizeof(_Tp)&gt; //如果是非完整类型，或者无界类型，sizeof 会无法应用
    constexpr true_type __is_complete_or_unbounded(__type_identity&lt;_Tp&gt;) //由于我们只关心返回类型，所以不用返回值
                    //或者说返回类型种隐含了返回值true_type::value==true;
    &#123; return &#123;&#125;; &#125;

  template &lt;typename _TypeIdentity,	
      typename _NestedType = typename _TypeIdentity::type&gt;	//上面的模板匹配失败，转而匹配这个模板
    constexpr typename __or_&lt; //是其中一个
      is_reference&lt;_NestedType&gt;,
      is_function&lt;_NestedType&gt;,
      is_void&lt;_NestedType&gt;,
      __is_array_unknown_bounds&lt;_NestedType&gt;	//这个tyep_traits还没有分析，仅仅知道如何用也不妨
    &gt;::type __is_complete_or_unbounded(_TypeIdentity) //如果__or_种的元函数的返回类型皆为false_type，也就是说参数类型不是上面那些类型其中之一，最终结果就是false_type
    &#123; return &#123;&#125;; &#125;
</code></pre>
<h2 id="is-enum-x2F-class-x2F-union"><a href="#is-enum-x2F-class-x2F-union" class="headerlink" title="is_enum&#x2F;class&#x2F;union"></a>is_enum&#x2F;class&#x2F;union</h2><p>传入一个类型，返回其是不是enum&#x2F;class&#x2F;union，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>编译器为我们内置了这三种type_traits。你只需要知道这是内置的就好。</p>
<pre><code class="C++">  /// is_enum
  template&lt;typename _Tp&gt;
    struct is_enum
    : public integral_constant&lt;bool, __is_enum(_Tp)&gt; //无法查看__is_enum的具体实现，下同
    &#123; &#125;;

  /// is_union
  template&lt;typename _Tp&gt;
    struct is_union
    : public integral_constant&lt;bool, __is_union(_Tp)&gt;
    &#123; &#125;;

  /// is_class
  template&lt;typename _Tp&gt;
    struct is_class
    : public integral_constant&lt;bool, __is_class(_Tp)&gt;
    &#123; &#125;;
</code></pre>
<h2 id="is-null-pointer"><a href="#is-null-pointer" class="headerlink" title="is_null_pointer"></a>is_null_pointer</h2><p>传入一个类型，返回其是不是空指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>空指针该如何做特例化。C++11有nullptr,是nullptr_t类型(nullptr_t是decltype(nullptr)的一个别名), 由于任何型别的指针类型都可以转换为nullptr_t，所以，对nullptr_t类型做特例化即可。</p>
<p>关于以后的type_traits，如果还是老生常谈的设计手法。就不会再说了，就像这个type_traits一样。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_null_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_null_pointer_helper&lt;std::nullptr_t&gt;
    : public true_type &#123; &#125;;

  /// is_null_pointer (LWG 2247).
  template&lt;typename _Tp&gt;
    struct is_null_pointer
    : public __is_null_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<p>GCC还提供了一个不推荐使用的拓展。</p>
<pre><code class="C++">  /// __is_nullptr_t (deprecated extension).
  template&lt;typename _Tp&gt;
    struct __is_nullptr_t
    : public is_null_pointer&lt;_Tp&gt;
    &#123; &#125; _GLIBCXX_DEPRECATED_SUGGEST(&quot;std::is_null_pointer&quot;); //这些宏实在是不想深究到底，令人厌烦的宏！
</code></pre>
<h2 id="is-arithmetic"><a href="#is-arithmetic" class="headerlink" title="is_arithmetic"></a>is_arithmetic</h2><p>传入一个类型，返回其是不是可运算的类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>整形类型和浮点类型被视作是可运算的类型，无论是否具有const性质。</p>
<blockquote>
<p>你可能会想到，如果自定义类型也支持+ - * &#x2F;等运算，是不是这个type_traits就不好使了呢？难道有bug吗？</p>
<p>你可以将这个type_traits看作一个规定。并且，不要为任何自定义类型做任何的type_traits的特例化。永远不要，因为这是一个未定义的行为。有关更多， 请看<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/is_arithmetic">std::is_arithmetic - cppreference.com</a></p>
</blockquote>
<pre><code class="C++">  /// is_arithmetic
  template&lt;typename _Tp&gt;
    struct is_arithmetic
    : public __or_&lt;is_integral&lt;_Tp&gt;, is_floating_point&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-fundamental"><a href="#is-fundamental" class="headerlink" title="is_fundamental"></a>is_fundamental</h2><p>传入一个类型，返回其是不是基本类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>可运算类型，void, nullptr_t被视作为基本类型，理由和注意事项同上。</p>
<pre><code class="C++">  /// is_fundamental
  template&lt;typename _Tp&gt;
    struct is_fundamental
    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_void&lt;_Tp&gt;,
           is_null_pointer&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-compound"><a href="#is-compound" class="headerlink" title="is_compound"></a>is_compound</h2><p>传入一个类型，返回其是不是复合类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>只需要对is_fundamental的结果取反，也就是应用__not_即可</p>
<pre><code class="C++">  /// is_compound
  template&lt;typename _Tp&gt;
    struct is_compound
    : public __not_&lt;is_fundamental&lt;_Tp&gt;&gt;::type &#123; &#125;;
</code></pre>
<h2 id="is-object"><a href="#is-object" class="headerlink" title="is_object"></a>is_object</h2><p>传入一个类型，返回其是不是一个对象，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>这里的object指的是广义上的对象。例如int,double类型的实例皆算对象。例如但函数，引用，void类型不算在内。</p>
<pre><code class="C++">struct A &#123;
    int m_data = 0;
&#125;;
int main() &#123;
    cout &lt;&lt; std::is_object&lt;int&gt;::value &lt;&lt; endl;			//true
    cout &lt;&lt; std::is_object&lt;double&gt;::value &lt;&lt; endl;		//true
    cout &lt;&lt; std::is_object&lt;int&amp;&gt;::value &lt;&lt; endl; 		//false
    cout &lt;&lt; std::is_object&lt;A&gt;::value &lt;&lt; endl;			//true
    cout &lt;&lt; std::is_object&lt;void(int,int)&gt;::value &lt;&lt; endl;//false
    return 0;
&#125;
</code></pre>
<p>实现</p>
<pre><code class="C++">/// is_object
template&lt;typename _Tp&gt;
  struct is_object
  : public __not_&lt;__or_&lt;is_function&lt;_Tp&gt;, is_reference&lt;_Tp&gt;,
                        is_void&lt;_Tp&gt;&gt;&gt;::type
  &#123; &#125;;
</code></pre>
<h2 id="is-scalar"><a href="#is-scalar" class="headerlink" title="is_scalar"></a>is_scalar</h2><p>传入一个类型，返回其是不是一个标量类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<blockquote>
<p>标量类型包括算数类型，枚举类型，指针，成员指针，空指针.将在那些元函数应用于__or_即可</p>
</blockquote>
<pre><code class="C++">  /// is_scalar
  template&lt;typename _Tp&gt;
    struct is_scalar
    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_enum&lt;_Tp&gt;, is_pointer&lt;_Tp&gt;, 
                   is_member_pointer&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-compound-1"><a href="#is-compound-1" class="headerlink" title="is_compound"></a>is_compound</h2><p>传入一个类型，返回其是不是一个复合类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<pre><code class="C++">  /// is_compound
  template&lt;typename _Tp&gt;
    struct is_compound // 对is_fundamental取否定即可
    : public __not_&lt;is_fundamental&lt;_Tp&gt;&gt;::type &#123; &#125;; 
</code></pre>
<h2 id="is-same"><a href="#is-same" class="headerlink" title="is_same"></a>is_same</h2><p>传入两个类型，返回其是不是相同类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>对&lt;_Tp, _Tp&gt;做特例化即可。</p>
<pre><code class="C++">  /// is_same
 //下面省略了一些条件编译
  template&lt;typename _Tp, typename _Up&gt; //不同类型的时候
    struct is_same
    : public false_type
    &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_same&lt;_Tp, _Tp&gt; //相同类型的时候
    : public true_type
    &#123; &#125;;
</code></pre>
<h2 id="is-member-object-x2F-function-pointer"><a href="#is-member-object-x2F-function-pointer" class="headerlink" title="is_member_object&#x2F;function_pointer"></a>is_member_object&#x2F;function_pointer</h2><p>传入一个类型，返回其是不是指向类内非静态数据成员&#x2F;成员函数的指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>在文章的最后，我准备了一些更加酷的东西，当然，也更加的复杂。首先，我们应当了解一下基本的原理：</p>
<p>如果A是一个类，那么可以有这样的一种指针<code>type A::*</code> 指向A中类型为type的数据成员(非静态的，下文省略)。类似的，还有成员函数指针。例如</p>
<pre><code class="C++">struct A &#123;
    int a = 10;
    void inc_and_print() &#123;
        ++a;
        cout &lt;&lt; a &lt;&lt; endl;
    &#125;
&#125;;
int main() &#123;
    int A::* p = &amp;A::a;
    //使用
    A x;
    x.*p = 10; //固定的语法形式
    cout &lt;&lt; x.*p &lt;&lt; endl;   //10
    cout &lt;&lt; x.a &lt;&lt; endl;    //10

    using Fun = void (A::*)();
//    void(A::*fun)();
    Fun fun = &amp;A::inc_and_print;
    (x.*fun)(); //such as call A::inc_and_print //a is 11
    return 0;
&#125;
</code></pre>
<p>C++还有这种语法？你会疑问，这是肯定的！但这无关紧要，在什么情况下才能用上这样的语法？貌似真的没有，除了TMP。</p>
<p>你知道了解一点，如果T是一个类，则可以有<code>type T::*</code>这样的形式指向数据成员&#x2F;成员函数，不是类则没有。</p>
<p>并且还要说明的是，不要纠结在这些语法的琐碎上，<strong>Bjarne Stroustrup</strong>也不会对所有的C++语法细节和标准全部一清二楚。不要陷入语法细节的深渊——C++在承受着巨大的历史包袱的同时，还要添加现代的语法特性，想学完C++————下辈子说不定可以！</p>
<p>关于具体的实现，请看源代码，我会一点点说明。</p>
<pre><code class="C++">template&lt;typename&gt;
    struct __is_member_object_pointer_helper //主模板继承false_type
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; //注意这里没有逗号，模板匹配的时候会将一个类型拆分成两个了类型的组合，好复杂的语法，可恶
      //匹配到这个特例化模板可以是数据成员指针，也可以是成员函数指针。如果不是成员函数指针，就是数据成员指针了
    : public __not_&lt;is_function&lt;_Tp&gt;&gt;::type &#123; &#125;; 

  /// is_member_object_pointer
  template&lt;typename _Tp&gt;
    struct is_member_object_pointer 
    : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<p>太复杂了！你可能还是对上述代码中的哪个特例化有疑问，好吧！让我们一探究竟。我们对上述的代码改造一下。对于那个特例化，我们在其内部定义两个类型T1, T2为 _Tp, _Cp的别名，_Tp,_Cp到底被推断为什么类型。</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
namespace jan &#123;
    using std::__not_;
    using std::true_type;
      using std::false_type;
      using std::is_function;
     using std::__remove_cv_t;
    template&lt;typename&gt;
    struct __is_member_object_pointer_helper
    : public false_type &#123; &#125;;

     template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; 
    : public __not_&lt;is_function&lt;_Tp&gt;&gt;::type &#123; 
        using T1 = _Tp;	//这里是我们添加的
        using T2 = _Cp;
    &#125;;

  /// is_member_object_pointer
  template&lt;typename _Tp&gt;
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
&#125;

class A &#123; &#125;;
int main() &#123;
     jan::is_member_object_pointer&lt;int A::*&gt;::type t;
      return 0;
&#125;
</code></pre>
<p>编译器会为我们生成这样的代码。</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
namespace jan
&#123;
  using std::__not_;
  template&lt;typename _Pp&gt;
  
  using std::true_type;
  using std::false_type;
  using std::is_function;
  template&lt;typename _Tp&gt;
  
  using std::__remove_cv_t;
  template&lt;typename std::_Tp&gt;
  using std::__remove_cv_t = typename remove_cv&lt;_Tp&gt;::type;
  
  template&lt;typename type_parameter_0_0&gt;
  struct __is_member_object_pointer_helper : public std::false_type
  &#123;
  &#125;;
  /****************************************注意看这里******************************************/
  /* First instantiated from: insights.cpp:23 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template&lt;&gt;
  struct __is_member_object_pointer_helper&lt;int A::*&gt; : public std::integral_constant&lt;bool, true&gt;
  &#123;
    using T1 = int; //_Tp is int
    using T2 = A;   //_Cp is A
  &#125;;
  /******************************************************************************************/
  #endif
  template&lt;typename _Tp, typename _Cp&gt;
  struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; : public __not_&lt;is_function&lt;_Tp&gt; &gt;::type
  &#123;
    using T1 = _Tp;
    using T2 = _Cp;
  &#125;;
  
  template&lt;typename _Tp&gt; //在这个例子中， _Tp us int A::*
  struct is_member_object_pointer : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt; &gt;::type
  &#123;
  &#125;;
  
  /* First instantiated from: insights.cpp:30 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template&lt;&gt;
  struct is_member_object_pointer&lt;int A::*&gt; : public std::integral_constant&lt;bool, true&gt;
  &#123;
  &#125;;
  #endif 
&#125;
class A&#123; &#125;;
int main()
&#123;
    std::integral_constant&lt;bool, true&gt; t = std::integral_constant&lt;bool, true&gt;(); //这里无关紧要
     return 0;
&#125;
</code></pre>
<p>恍然大悟了吧！</p>
<p>类似的<code>is_member_function_pointer</code>有这样的实现。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_member_function_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_function_pointer_helper&lt;_Tp _Cp::*&gt;
//匹配到这个特例化模板可以是数据成员指针，也可以是成员函数指针。那就用is_function这个type_traits是不是一个函数即可
    : public is_function&lt;_Tp&gt;::type &#123; &#125;; 

  /// is_member_function_pointer
  template&lt;typename _Tp&gt;
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇大部分的源码分析还是轻松的，除了个别的刺头。</p>
<p>你听说过brainfuck这个语言吗？相比于brainfuck这个语言，C++才是真正的brainfunk! </p>
<p>我的🧠要爆炸了！！！</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ff7d73">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #00a596">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/type-traits源码分析-二-/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/type-traits源码分析-一-/">
        <h2 class="post-title">Type_traits源码分析(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="type-traits概述"><a href="#type-traits概述" class="headerlink" title="type_traits概述"></a>type_traits概述</h1><p>tyep_traits是C++TMP中不可缺少的一部分，也是Modern C++不可缺少的一部分。任何一位C++程序员，如果想学习Modern C++，想学号Modern C++，肯定不能避免学习type_traits。</p>
<h2 id="什么是type-traits"><a href="#什么是type-traits" class="headerlink" title="什么是type_traits?"></a>什么是type_traits?</h2><p>type_traits，顾名思义，为类型萃取器&#x2F;类型特征。type_traits是一系列的元函数。在普通函数中，我们传入数据，返回数据。但是在元函数中，我们传入类型&#x2F;常量，返回类型&#x2F;常量。</p>
<p>C++ type_traits的实现,也就是元函数的一般形式, 使用结构体+模板(模式匹配+模板偏特化)的方式。</p>
<p>使用&lt;&gt;来传入类型(语法层面的), 使用::value&#x2F;::type来获得返回值&#x2F;返回类型(约定俗成的)。<br>例如<code>std::true_type::value == true</code>,<code>std::false_type::value == false</code>,<code>std::remove_const&lt;const int&gt;::value</code></p>
<p>所有的type_traits操作均发生在编译时期。</p>
<h2 id="type-trait能够干什么"><a href="#type-trait能够干什么" class="headerlink" title="type_trait能够干什么?"></a>type_trait能够干什么?</h2><p>type_traits不仅是标准库的重要组成部分，也是模板元编程中的基本技能。</p>
<p>标准库中的类型安全也多亏了type_traits，在各种C++库中也总是能看到type_traits的身影。</p>
<h1 id="type-traits中的约定"><a href="#type-traits中的约定" class="headerlink" title="type_traits中的约定"></a>type_traits中的约定</h1><p>type_traits发展了很长的时间，C++标准演化出来了一套规定<br>通用的规定</p>
<ul>
<li>使用::value来表示返回值(值元函数)</li>
<li>使用::type来表示返回类型(类型元函数)</li>
<li>每个元函数只能返回一个类型或者一个值</li>
<li>元函数可以同时是值元函数和类型元函数</li>
<li>元函数必须是一个模板类</li>
<li>对于一个type_traits,形如XXX_t的形式是一个类型应用XXX后的返回类型</li>
<li>对于一个type_traits,形如XXX_v的形式是一个类型应用XXX后的返回值(C++17)</li>
</ul>
<p>对于一元type_traits的规定</p>
<ul>
<li>接受一个类型参数 + 可选的辅助附加参数</li>
<li>必须可以默认构造</li>
<li>必须可以拷贝构造</li>
<li>必须公开且无歧义</li>
<li>所有的一元元函数都必须从std::integral_constant继承</li>
<li>基本的特征成员不应该被隐藏，而且明确可用</li>
</ul>
<p>对于二元元函数的规定</p>
<ul>
<li>接受有两个类型参数 + 可选的辅助附加参数</li>
<li>必须可以默认构造</li>
<li>必须可以拷贝构造</li>
<li>必须公开且无歧义</li>
<li>所有的一元元函数都必须从std::integral_constant的特例化继承</li>
<li>基本的特征成员不应该被隐藏，而且明确可用</li>
</ul>
<p>对于transformation-traits的规定</p>
<ul>
<li>接受一个类型参数 + 可选的辅助附加参数</li>
<li>定义一个public的名为type的嵌套类型</li>
<li>没有默认&#x2F;拷贝构造的要求(可以有，也可以没有)</li>
</ul>
<blockquote>
<p>你会发现标准库的有些地方没有遵守这个标准——那些代码是在这个标准没有成型之前，例如迭代器有关的类型萃取</p>
</blockquote>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>本篇文章使用gcc编译器，会提到17,20中的type_traits,请确保你所用的编译器支持17，20</p>
<p>对于有些条件编译，不列出源码并且不分析</p>
<p>我会将元函数和type_traits等价起来，如果文中说元函数，你可以联系上下文把其当作type_traits。反之亦然。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>标准库对于type_traits的实现，放在了type_traits中</p>
<h2 id="integral-constant"><a href="#integral-constant" class="headerlink" title="integral_constant"></a>integral_constant</h2><pre><code class="C++"> template&lt;typename _Tp, _Tp __v&gt;
    struct integral_constant
    &#123;
      static constexpr _Tp                  value = __v;
      typedef _Tp                           value_type;
      typedef integral_constant&lt;_Tp, __v&gt;   type;
      constexpr operator value_type() const noexcept &#123; return value; &#125;
    //有constexpr性质，可以编译时期求值
      constexpr value_type operator()() const noexcept &#123; return value; &#125;
    &#125;;
</code></pre>
<p>我们可以看见integral_constant定义的很简单，记得unix的哲学吗? less is more! 几乎所有的type_traits都会直接的或者间接的继承integral_constant</p>
<h2 id="true-type-false-type"><a href="#true-type-false-type" class="headerlink" title="true_type false_type"></a>true_type false_type</h2><p><code>true_type</code>,<code>false_type</code>仅仅是integral_constant的别名，定义如下</p>
<pre><code class="C++">  /// The type used as a compile-time boolean with true value.
  typedef integral_constant&lt;bool, true&gt;     true_type;

  /// The type used as a compile-time boolean with false value.
  typedef integral_constant&lt;bool, false&gt;    false_type;
</code></pre>
<p>很多的元函数都继承这两个类型，例如is_XXX等元函数。</p>
<h2 id="bool-constant"><a href="#bool-constant" class="headerlink" title="bool_constant"></a>bool_constant</h2><p>很好理解</p>
<pre><code class="C++">  /// The type used as a compile-time boolean with true value.
  typedef integral_constant&lt;bool, true&gt;     true_type;

  /// The type used as a compile-time boolean with false value.
  typedef integral_constant&lt;bool, false&gt;    false_type;
</code></pre>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>conditional接受三个参数，一个bool值，两个类型参数，作用相当于编译时期的if，可以这样描述</p>
<p><code>&lt;bool p, T1, T2&gt; p ? T1 : T2</code></p>
<pre><code class="C++">//前置声明
template&lt;bool, typename, typename&gt;
    struct conditional;  
...
/// Define a member typedef @c type to one of two argument types.
  template&lt;bool _Cond, typename _Iftrue, typename _Iffalse&gt; //主模板
    struct conditional
    &#123; typedef _Iftrue type; &#125;;

  // Partial specialization for false.
  template&lt;typename _Iftrue, typename _Iffalse&gt;		//特化模板
    struct conditional&lt;false, _Iftrue, _Iffalse&gt;
    &#123; typedef _Iffalse type; &#125;;
</code></pre>
<h2 id="type-identity"><a href="#type-identity" class="headerlink" title="__type_identity"></a>__type_identity</h2><p>关于个元函数，没有明确的规定，可以教type_is,或者其他的东西。每个标准库的实现都有所不同。作用就是给定一个T类型，返回一个T类型，用于被其他元函数继承。</p>
<pre><code class="C++">  template &lt;typename _Type&gt;
    struct __type_identity
    &#123; using type = _Type; &#125;;

  template&lt;typename _Tp&gt;
    using __type_identity_t = typename __type_identity&lt;_Tp&gt;::type;
</code></pre>
<h2 id="logic-traits"><a href="#logic-traits" class="headerlink" title="logic traits"></a>logic traits</h2><p>合取，析取，否定 traits。其中<code>conjunction</code>、<code>disjunction</code>、<code>negation</code>在定义了宏<code>__cpp_lib_logical_traits 201510</code>才启用</p>
<h3 id="or"><a href="#or" class="headerlink" title="__or_"></a><strong>__or_</strong></h3><p>类似or关键字，__or_元函数接受一个参数包，对这些类型的返回值求析取</p>
<pre><code class="C++">template&lt;typename...&gt;
    struct __or_; //主模板永远不能被匹配匹配到，所以不用定义

  template&lt;&gt;
    struct __or_&lt;&gt;	//如果没有类型，继承true_type
    : public false_type
    &#123; &#125;;

  template&lt;typename _B1&gt;
    struct __or_&lt;_B1&gt; //有一个类型继承哪个类型
    : public _B1
    &#123; &#125;;

  template&lt;typename _B1, typename _B2&gt; //如果时两个类型，递归的继承
    struct __or_&lt;_B1, _B2&gt;
    : public conditional&lt;_B1::value, _B1, _B2&gt;::type 
    //if _B1::value==true，那么不再判断，继承_B1即可，我们关心的是::value的这个返回值。
    //if _B1::value==false, 则继承_B2，此时_B2匹配到接受一个参数的特例化
    &#123; &#125;;

  template&lt;typename _B1, typename _B2, typename _B3, typename... _Bn&gt; //接受多个类型
    struct __or_&lt;_B1, _B2, _B3, _Bn...&gt;
    : public conditional&lt;_B1::value, _B1, __or_&lt;_B2, _B3, _Bn...&gt;&gt;::type
    //if _B1::value==true同理
    //if _B1::value==false, 递归的继承__or_&lt;_B2, _B3, _Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">//这种语法是C++17添加进来的，也很有效的简化了模板元编程的复杂性
template&lt;typename... _Bn&gt;
    inline constexpr bool __or_v = __or_&lt;_Bn...&gt;::value; //__or_v即是类型用用于__or_v后的返回
//__and_v同
</code></pre>
<h3 id="and"><a href="#and" class="headerlink" title="__and_"></a><strong>__and_</strong></h3><p>__and_的功能和实现与__or_的功能和实现大同小异</p>
<pre><code class="C++">  template&lt;typename...&gt;
    struct __and_;

  template&lt;&gt;
    struct __and_&lt;&gt;
    : public true_type //这里继承true_type
    &#123; &#125;;

  template&lt;typename _B1&gt;
    struct __and_&lt;_B1&gt;
    : public _B1
    &#123; &#125;;

  template&lt;typename _B1, typename _B2&gt;
    struct __and_&lt;_B1, _B2&gt;
    : public conditional&lt;_B1::value, _B2, _B1&gt;::type //这里的类型排列相较于__or_是反的
    &#123; &#125;;

  template&lt;typename _B1, typename _B2, typename _B3, typename... _Bn&gt;
    struct __and_&lt;_B1, _B2, _B3, _Bn...&gt;
    : public conditional&lt;_B1::value, __and_&lt;_B2, _B3, _Bn...&gt;, _B1&gt;::type //类型排列同上
    &#123; &#125;;
</code></pre>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    inline constexpr bool __and_v = __and_&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="not"><a href="#not" class="headerlink" title="__not_"></a><strong>__not_</strong></h3><p>__not_对给定类型的::value返回值取反,实现非常的简单</p>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    struct __not_
    : public __bool_constant&lt;!bool(_Pp::value)&gt; //这里有一个强转
    &#123; &#125;;
</code></pre>
<h3 id="conjunction"><a href="#conjunction" class="headerlink" title="conjunction"></a><strong>conjunction</strong></h3><p>合取，功能和__or_一样，通过继承其实现。</p>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    struct conjunction
    : __and_&lt;_Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">template&lt;typename... _Bn&gt;
    inline constexpr bool conjunction_v = conjunction&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="disjunction"><a href="#disjunction" class="headerlink" title="disjunction"></a><strong>disjunction</strong></h3><p>析取，同上</p>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    struct disjunction
    : __or_&lt;_Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">   template&lt;typename... _Bn&gt;
    inline constexpr bool disjunction_v = disjunction&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="negation"><a href="#negation" class="headerlink" title="negation"></a><strong>negation</strong></h3><p>否定，同上</p>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    struct negation
    : __not_&lt;_Pp&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    inline constexpr bool negation_v = negation&lt;_Pp&gt;::value;
</code></pre>
<h2 id="is-l-x2F-r-reference"><a href="#is-l-x2F-r-reference" class="headerlink" title="is_l&#x2F;r reference"></a>is_l&#x2F;r reference</h2><p>传入一个类型，返回其是不是一个左值&#x2F;右值引用类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type</p>
<pre><code class="C++">  /// is_lvalue_reference
  template&lt;typename&gt;		//主模板继承false_type
    struct is_lvalue_reference
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_lvalue_reference&lt;_Tp&amp;&gt; //对于左值引用的特例化，继承true_type
    : public true_type &#123; &#125;;

  /// is_rvalue_reference
  template&lt;typename&gt;			//同上
    struct is_rvalue_reference
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;		//同上
    struct is_rvalue_reference&lt;_Tp&amp;&amp;&gt;
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-reference"><a href="#is-reference" class="headerlink" title="is_reference"></a>is_reference</h2><p>传入一个类型，返回其是不是一个引用类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type</p>
<pre><code class="C++">template&lt;typename&gt;
struct is_reference; //声明

template&lt;typename _Tp&gt;
struct is_reference 		//左值引用/右值引用
    : public __or_&lt;is_lvalue_reference&lt;_Tp&gt;, 这里用__or_来实现
                   is_rvalue_reference&lt;_Tp&gt;&gt;::type
&#123; &#125;;
</code></pre>
<h2 id="is-const"><a href="#is-const" class="headerlink" title="is_const"></a>is_const</h2><p>传入一个类型，返回其是否具有const性质，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>通过普通的模板特化就可以实现</p>
<pre><code class="C++">  /// is_const
  template&lt;typename&gt;
    struct is_const
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_const&lt;_Tp const&gt; //对于const的特化
    : public true_type &#123; &#125;;
</code></pre>
<p>注意，对于&amp;&#x2F;&amp;&amp;is_const的返回类型是一个::false_type,就是所<code>std::is_const&lt;const int &amp;&gt;::value==false</code></p>
<p>类似的，还有<code>const int *</code>也是一样。因为这样的语义表示的指向的对象是常量性质的，而不是引用&#x2F;指针本身是常量性质的。</p>
<h2 id="is-volatile"><a href="#is-volatile" class="headerlink" title="is_volatile"></a>is_volatile</h2><p>传入一个类型，返回其是否具有volatile性质，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>实现方式和is_const大同小异。注意的事项也和is_const是一样的。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct is_volatile
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_volatile&lt;_Tp volatile&gt;
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-function"><a href="#is-function" class="headerlink" title="is_function"></a>is_function</h2><p>传入一个类型，返回其是不是一个函数类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>C++还有这样的功能！这是黑魔法吗？</p>
<p>这不是什么黑魔法，但确实够酷。在你惊叹他的时候，应当了解一下原理。</p>
<p>对于一个T类型，如果其是一个函数&#x2F;&amp;，对其添加const不会发成任何类型上的变化。例如</p>
<pre><code class="C++">void fun() &#123; &#125;
template &lt;typename T&gt;
struct add_const &#123;
  using type = const T;
&#125;;
int main() &#123;
    typename add_const&lt;decltype(fun)&gt;::type c;
  return 0;
&#125;
</code></pre>
<p>编译器会生成这样的代码</p>
<pre><code class="C++">void fun()
&#123;
&#125;

template&lt;typename T&gt;
struct add_const
&#123;
  using type = const T;
&#125;;

/* First instantiated from: insights.cpp:10 */
#ifdef INSIGHTS_USE_TEMPLATE
template&lt;&gt;
struct add_const&lt;void ()&gt; 
&#123;
  using type = void (); //类型上没有发生任何变化
&#125;;

#endif

int main()
&#123;
  void c();
  return 0;
&#125;
</code></pre>
<p>基于这个原理，我们可以轻松实现这个元函数。考虑到对于<code>const T &amp;</code>,<code>const T &amp;&amp;</code>(T不是一个函数类型) 应用is_const:value&#x3D;&#x3D;false &amp;&#x2F;&amp;&amp;继承false_type,主模板添加const性质之后判断得到的类型是不是具有const性质。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct is_function;
  /// is_function
  template&lt;typename _Tp&gt;
    struct is_function
    : public __bool_constant&lt;!is_const&lt;const _Tp&gt;::value&gt; &#123; &#125;;
    
//对引用考虑即可，对指针添加const变为*const
  template&lt;typename _Tp&gt;
    struct is_function&lt;_Tp&amp;&gt; 
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_function&lt;_Tp&amp;&amp;&gt;
    : public false_type &#123; &#125;;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ffa2c4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #03a9f4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #ffa2c4">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/type-traits源码分析-一-/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <i class="fa-solid fa-caret-right fa-fw"></i>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4 " alt="avatar">
        </div>
        <div class="name">
            Jan6055
        </div>
        <div class="descriptions">
            
            <div class="description">
                兴趣：
            </div>
            
            <div class="description">
                C++
            </div>
            
            <div class="description">
                Rust
            </div>
            
            <div class="description">
                Haskell
            </div>
            
            <div class="description">
                这是我的个人博客，用于记录学习到的技能
            </div>
            
            <div class="description">
                我希望我的博客会帮到你
            </div>
            
            <div class="description">
                如果你对博客中的内容有疑问，请联系
            </div>
            
            <div class="description">
                QQ: 1796728809
            </div>
            
            <div class="description">
                email: 1796728809@qq.com
            </div>
            
            <div class="description">
                wangq6055@outlook.com
            </div>
            
            <div class="description">
                目前:
            </div>
            
            <div class="description">
                在校大二学生
            </div>
            
            <div class="description">
                在学习Modern C++ &amp;&amp; 各种计算机基础
            </div>
            
            <div class="description">
                时不时摆烂，很爽
            </div>
            
            <div class="description">
                But I love coding!
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/jan6055">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hello @you
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Jan6055
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>