
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hello @You</title>
        <meta name="author" content="Jan6055">
        <meta name="description" content="">
        <meta name="keywords" content="C++,Rust,Jan6055">
        <link rel="icon" href="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hello @you</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hello @you</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(http://p6.qhimg.com/bdr/__85/t015c7bbab0a42e2cf9.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Hello @you</h1>
                <h3>enjoy coding</h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/09/28/type-traits源码分析-三/">
        <h2 class="post-title">Type-Traits源码分析(三)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/28
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>在第三章中，会有一些新的东西，不同于一二章，这章TMP开始加速了！你将会看见额外的一些元函数实现手法，你肯定会惊讶它的巧妙，特别是void_t类型。总之，做好准备，这章的难度可不同于以往了！</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="is-one-of"><a href="#is-one-of" class="headerlink" title="__is_one_of"></a>__is_one_of</h2><p>传入一个类型T和一个参数包Ts，返回其T是不是Ts其中的一个类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>有了这个type_traits，可以更加轻松的实现其他type_traits。</p>
<p>这个type_traits的实现方式也是比较的有意思。我们可以有很多种方式来实现<code>__is_one_of</code>这个元函数，包括使用模板递归继承的方式来实现。gcc则是采用的参数包模式展开的方式。</p>
<pre><code class="C++">  template&lt;typename _Tp, typename... _Types&gt;
    using __is_one_of = __or_&lt;is_same&lt;_Tp, _Types&gt;...&gt;; //用is_same这个模式来对参数包展开，相当于每个类型都和_Tp应用于is_same,再用作于__or_，即可获得结果。
</code></pre>
<h2 id="is-signed-x2F-unsinged-integer"><a href="#is-signed-x2F-unsinged-integer" class="headerlink" title="__is_signed&#x2F;unsinged_integer"></a>__is_signed&#x2F;unsinged_integer</h2><p>入一个类型，返回其是不是，如一个有符号&#x2F;无符号的整数果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<pre><code class="C++">  // Check if a type is one of the signed integer types.
  template&lt;typename _Tp&gt;
    using __is_signed_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;, //继承__is_one_of&lt;符合要求的类型参数包&gt;
      signed char, signed short, signed int, signed long,
      signed long long
#if defined(__GLIBCXX_TYPE_INT_N_0)			//条件编译大可忽略
      , signed __GLIBCXX_TYPE_INT_N_0
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
      , signed __GLIBCXX_TYPE_INT_N_1
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
      , signed __GLIBCXX_TYPE_INT_N_2
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
      , signed __GLIBCXX_TYPE_INT_N_3
#endif
      &gt;;		
</code></pre>
<p>实现方式大同小异</p>
<pre><code class="C++">  // Check if a type is one of the unsigned integer types.
  template&lt;typename _Tp&gt;
    using __is_unsigned_integer = __is_one_of&lt;__remove_cv_t&lt;_Tp&gt;,
      unsigned char, unsigned short, unsigned int, unsigned long,
      unsigned long long
#if defined(__GLIBCXX_TYPE_INT_N_0)
      , unsigned __GLIBCXX_TYPE_INT_N_0
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
      , unsigned __GLIBCXX_TYPE_INT_N_1
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
      , unsigned __GLIBCXX_TYPE_INT_N_2
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
      , unsigned __GLIBCXX_TYPE_INT_N_3
#endif
      &gt;;
</code></pre>
<h2 id="is-standard-integer"><a href="#is-standard-integer" class="headerlink" title="__is_standard_integer"></a>__is_standard_integer</h2><p>传入一个类型，返回其是不是标准定义的整数，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>这个type_traits是其他type_traits组合起来的一个别名。这也是元函数的一个实现手法。</p>
<pre><code class="C++">  // Check if a type is one of the signed or unsigned integer types.
  template&lt;typename _Tp&gt;
    using __is_standard_integer
      = __or_&lt;__is_signed_integer&lt;_Tp&gt;, __is_unsigned_integer&lt;_Tp&gt;&gt;;
</code></pre>
<h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>我并不打算详细的解释什么是SFINAE,你应当自己去寻找一些资料。我主要想说的是，一下的type_traits,皆基于SFINAE,虽然之前的文章中也说到过SFINE,但那更像是开胃小菜。</p>
<h2 id="void-t"><a href="#void-t" class="headerlink" title="void_t"></a>void_t</h2><p>void_t，就是一个void的别名，但是带有类型参数。你会说：这不是脱裤子放屁吗？有什么用，我直接写void不好吗？</p>
<p>实际上void_t是为TMP服务的，并不是让你当作返回值&#x2F;类型声明的。我们可以通过SFINE+void_t这种TMP的手法来实现看似不可能的元函数。你马上就会看到</p>
<p>至于你说为什么叫void_t而不是叫其他类型，那你去问问C++委员会吧，顺便告诉我，我也想知道。</p>
<pre><code class="C++">  // __void_t (std::void_t for C++11)
  template&lt;typename...&gt; using __void_t = void;
</code></pre>
<h2 id="is-referenceable"><a href="#is-referenceable" class="headerlink" title="__is_referenceable"></a>__is_referenceable</h2><p>传入一个类型，返回其是不是可引用的，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>需要注意：一个类型T，如果已经是一个引用，无论是左值还是右值，均不可再添加&amp;，就是说没有<code>(int &amp;) &amp;</code>这样的语法，即引用的引用。但是在模板中，有引用的折叠，别把这件事情忘了。</p>
<p>拿什么是不可引用的呢？</p>
<ul>
<li>void</li>
<li>例如<code>int () const</code>这样的函数</li>
</ul>
<pre><code class="C++">  // Utility to detect referenceable types ([defns.referenceable]).

  template&lt;typename _Tp, typename = void&gt; //第二个类型参数用于辅助，不需要有名字。
    struct __is_referenceable
    : public false_type
    &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct __is_referenceable&lt;_Tp, __void_t&lt;_Tp&amp;&gt;&gt; //如果是一个不可引用的类型，匹配这个特例化失败，转而匹配主模板
    : public true_type
    &#123; &#125;;
</code></pre>
<h2 id="一些特殊的类型"><a href="#一些特殊的类型" class="headerlink" title="一些特殊的类型"></a>一些特殊的类型</h2><p>C++中有一些类型，具有独特的语义。例如 无其他动作的构造。内存布局方式是标准的。无其他动作的拷贝。一个抽象基类，一个被final修饰的类,等等deng’den。想对这些类型实现type_traits不是不行，但是编译器为我们内置这样的功能可能会更好，编译速度也会更加快速。</p>
<h3 id="trivial"><a href="#trivial" class="headerlink" title="trivial"></a>trivial</h3><p>一个trivial需要具有一下的性质</p>
<ul>
<li>有默认构造函数，编译器生成的，或者是显示的&#x3D;default，只能是这两种情况。</li>
<li>内存空间是连续的</li>
<li>不能包含虚函数和虚基类。</li>
<li>成员可以具有不同的访问权限</li>
<li>拥有平凡的拷贝构造函数和移动构造函数。默认的意思同上，也可以使用&#x3D;default。</li>
<li>拥有平凡的拷贝赋值运算符和移动赋值运算符。</li>
</ul>
<h3 id="stand-layout"><a href="#stand-layout" class="headerlink" title="stand_layout"></a>stand_layout</h3><p>一个stand_layout的对象，需要满足以下几种性质</p>
<ul>
<li>所有非静态成员拥有相同的访问级别</li>
<li>类中第一个非静态类型与基类不是同一个类型</li>
<li>所有非静态数据成员都符合标准布局的要求</li>
<li>没有虚类和虚基类</li>
<li>继承时需要满足以下两个情况之一<ol>
<li>派生类中有非静态类，那么这个派生类只能有且只有一个仅包含了静态成员的基类。</li>
<li>基类有非静态成员，那么派生类中不允许有非静态成员。</li>
</ol>
</li>
</ul>
<p>ps：这里涉及到C++对象模型，感兴趣的可以自行学习。</p>
<h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>pod类型需要满足两个要求</p>
<ul>
<li>是一个人trivial类型</li>
<li>是一个stand_layout类型</li>
</ul>
<p>pod类型的一些优势&#x2F;特点</p>
<ul>
<li>POD类型兼容C内存布局，C++可以直接使用C库函数操作POD数据类型，POD类型在C和C++间的操作总是安全的</li>
<li>POD类型可以直接使用字节赋值，使用C语言库函数进行二进制形式的数据交换，包括但不限于如下操作<code>memmove</code>,<code>memcpy</code>等</li>
<li>静态初始化在很多时候可以提高程序性能，而POD类型的静态初始化非常简单（放入目标文件的<code>.bss</code>段，在初始化时直接赋0）</li>
<li>虽然与C完全兼容，但是仍然可以有成员函数</li>
<li>有更长的生命周期（从资源获取到资源释放），非POD类型的生命周期从构造函数结束到析构函数结束</li>
<li>POD类型对象的前部没有填充字节，因此对象指针等于对象第一个成员的指针</li>
</ul>
<p>ps：还是涉及到C++对象模型，有点头秃，大伙看看就好，毕竟术业有专攻。编写应用层C++&#x2F;非底层库看看就好。</p>
<blockquote>
<p>STL的一些算法为了优化性能就会使用is_pod+标签分派的手法来优化性能。在一些很老的标准库中，你会看见对is_pod的手动实现</p>
</blockquote>
<h3 id="literal-type"><a href="#literal-type" class="headerlink" title="literal_type"></a>literal_type</h3><p>简单的说，就可以在用于编译期运算的对象。注意其和字面量的区别。</p>
<h2 id="还有一些编译器为我们内置的type-traits"><a href="#还有一些编译器为我们内置的type-traits" class="headerlink" title="还有一些编译器为我们内置的type_traits"></a>还有一些编译器为我们内置的type_traits</h2><p>这些type_traits的共呢个正如他们的名字所言，你唯一搞不懂的，应当是什么是POD类型？什么又是trivially_copyable性质？</p>
<pre><code class="C++"> /// is_trivial
//普通类型是其存储是连续的普通可复制的，并且仅支持静态默认初始化，无论是否为 cv 限定。它包括标量类型，平凡类和任何此类类型的数组。其实现也是编译器内置的。
  template&lt;typename _Tp&gt;
    struct is_trivial 
    : public integral_constant&lt;bool, __is_trivial(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;), //这里的静态断言，我们在前面说过了，不再解释，下同。
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  // is_trivially_copyable
  template&lt;typename _Tp&gt;
    struct is_trivially_copyable 	//是否具有平凡的拷贝
    : public integral_constant&lt;bool, __is_trivially_copyable(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_standard_layout
  template&lt;typename _Tp&gt;
    struct is_standard_layout	//是否是一个标准布局
    : public integral_constant&lt;bool, __is_standard_layout(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_pod (deprecated in C++20) C++20中已经废弃
  // Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.
  template&lt;typename _Tp&gt;	
    struct
    _GLIBCXX20_DEPRECATED(&quot;use is_standard_layout &amp;&amp; is_trivial instead&quot;)
    is_pod
    : public integral_constant&lt;bool, __is_pod(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_literal_type
  //17开始 20弃用
  template&lt;typename _Tp&gt;
    struct
    _GLIBCXX17_DEPRECATED
    is_literal_type 		//是否是一个字面类型
    : public integral_constant&lt;bool, __is_literal_type(_Tp)&gt;
    &#123;
      static_assert(std::__is_complete_or_unbounded(__type_identity&lt;_Tp&gt;&#123;&#125;),
    &quot;template argument must be a complete class or an unbounded array&quot;);
    &#125;;

  /// is_empty
  template&lt;typename _Tp&gt;
    struct is_empty			//是否是一个空类型，即类中为空实现
    : public integral_constant&lt;bool, __is_empty(_Tp)&gt;
    &#123; &#125;;

  /// is_polymorphic
  template&lt;typename _Tp&gt;
    struct is_polymorphic		// 是否是一个多态类
    : public integral_constant&lt;bool, __is_polymorphic(_Tp)&gt;
    &#123; &#125;;

#if __cplusplus &gt;= 201402L
#define __cpp_lib_is_final 201402L
  /// is_final
  template&lt;typename _Tp&gt;
    struct is_final		
    : public integral_constant&lt;bool, __is_final(_Tp)&gt;
    &#123; &#125;;
#endif

  /// is_abstract
  template&lt;typename _Tp&gt;
    struct is_abstract
    : public integral_constant&lt;bool, __is_abstract(_Tp)&gt;
    &#123; &#125;;
</code></pre>
<h2 id="is-signed"><a href="#is-signed" class="headerlink" title="is_signed"></a>is_signed</h2><pre><code class="C++">template&lt;typename _Tp,
  bool = is_arithmetic&lt;_Tp&gt;::value&gt; //默认参数是一个bool值,来判断书不是算数类型
  struct __is_signed_helper
  : public false_type &#123; &#125;;

template&lt;typename _Tp&gt;
  struct __is_signed_helper&lt;_Tp, true&gt;	//蕴含着是一个符号类型应当先是算数类型
  : public integral_constant&lt;bool, _Tp(-1) &lt; _Tp(0)&gt;	//如果是一个有符号类型，那么_Tp(-1) &lt; _Tp(0)得到的结果将会是false，是一个无符号类型，-1，会下溢结果为true。
  &#123; &#125;;

/// is_signed
template&lt;typename _Tp&gt;
  struct is_signed
  : public __is_signed_helper&lt;_Tp&gt;::type
  &#123; &#125;
</code></pre>
<h2 id="is-unsigned"><a href="#is-unsigned" class="headerlink" title="is_unsigned"></a>is_unsigned</h2><pre><code class="C++">  /// is_unsigned
  template&lt;typename _Tp&gt;
    struct is_unsigned
    : public __and_&lt;is_arithmetic&lt;_Tp&gt;/*也可以不加这个元函数，is_singed中有*/, __not_&lt;is_signed&lt;_Tp&gt;&gt;&gt; //算数类型的同时对is_singed取反
    &#123; &#125;;
</code></pre>
<h2 id="decltype手法"><a href="#decltype手法" class="headerlink" title="decltype手法"></a>decltype手法</h2><p>C++11中新增了decltype关键字，目的就是解决TMP中的一些问题。decltype会对表达式求值，只会根据表达式来推导类型，这点牢记。我不打算说明decltype的所有细节，你可以查阅资料来了解相关知识。decltype为TMP的实现提供了更多的可能性。decltype+SFINAE也是TMP中的一种很巧妙的手法。</p>
<h2 id="declval"><a href="#declval" class="headerlink" title="declval"></a>declval</h2><p>declval是一个函数，只有声明，没有实现，目的很简单，服务于TMP。因此，关于declval的所有操作，均在编译时期发生。</p>
<pre><code class="C++">  /**
   *  @brief  Utility to simplify expressions used in unevaluated operands
   *  @ingroup utilities
   */
//提供了两个的重载版本
  template&lt;typename _Tp, typename _Up = _Tp&amp;&amp;&gt;
    _Up
    __declval(int);

  template&lt;typename _Tp&gt;
    _Tp
    __declval(long);

  template&lt;typename _Tp&gt;
    auto declval() noexcept -&gt; decltype(__declval&lt;_Tp&gt;(0)); //尾置返回类型
</code></pre>
<h2 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h2><p>如果T是数组类型，则提供成员常量等于数组第nth维的元素数。或者T是其他类型，或者数组的第0维数为无界的并且nth&#x3D;0，则值为0。</p>
<p>你可能会疑惑为什么第0维是无界的时候值为0，第1，2，…维不行吗？别忘了C的语法——要确定数组的列数。</p>
<pre><code class="C++">  /// extent
  template&lt;typename, unsigned _Uint&gt;	
    struct extent
    : public integral_constant&lt;std::size_t, 0&gt; &#123; &#125;;	  //T不是数组类型，值为0

  template&lt;typename _Tp, unsigned _Uint, std::size_t _Size&gt;
    struct extent&lt;_Tp[_Size], _Uint&gt;
    : public integral_constant&lt;std::size_t,
                   _Uint == 0 ? _Size : extent&lt;_Tp,   //三目运算符
                               _Uint - 1&gt;::value&gt;	//递归条件_Uint == 0，在_Uint==0的时候，编译器推断的size正好是nth的长度，实现很巧妙，多看几眼慢慢搞清顺序。
    &#123; &#125;;

  template&lt;typename _Tp, unsigned _Uint&gt;
    struct extent&lt;_Tp[], _Uint&gt;				//如果是一个无界数组
    : public integral_constant&lt;std::size_t,
                   _Uint == 0 ? 0 : extent&lt;_Tp,	//如果是第0维，那么值就是0，否则就递归的继承，回到了上述的情况
                               _Uint - 1&gt;::value&gt; 
    &#123; &#125;;
</code></pre>
<p>用法：</p>
<pre><code class="C++">int main() &#123;
    int arr [][3][2] = &#123;&#125;;
    cout &lt;&lt; std::extent&lt;int[][3][5],0&gt;::value &lt;&lt; endl;  //0
    cout &lt;&lt; std::extent&lt;int[][3][5],1&gt;::value &lt;&lt; endl;  //3
    cout &lt;&lt; std::extent&lt;int[][3][5],2&gt;::value &lt;&lt; endl;  //5
    int arr1[1][2];
    cout &lt;&lt; std::extent&lt;decltype(arr1),0&gt;::value &lt;&lt; endl;   //1
    cout &lt;&lt; std::extent&lt;decltype(arr1),1&gt;::value &lt;&lt; endl;   //2
    
    //decltype(arr)的结果为什么超出我么的预期？gcc出bug了吗？
    cout &lt;&lt; std::extent&lt;decltype(arr),0&gt;::value &lt;&lt; endl;    //0
    cout &lt;&lt; std::extent&lt;decltype(arr),1&gt;::value &lt;&lt; endl;    //0
    cout &lt;&lt; std::extent&lt;decltype(arr),2&gt;::value &lt;&lt; endl;    //0
    return 0;
&#125;
</code></pre>
<p>其实decltype的推导arr的结果为<code>[0][3][2]</code>。是不同于直接传递<code>int[][3][5]</code>的。decltype的推断出一个有界数组，而直接传递arr，arr被当作一个无界数组。</p>
<h2 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h2><p>传入一个类型，返回其数组的维数。</p>
<p>同样是使用递归+继承的方式来实现。</p>
<pre><code class="C++">  /// rank
  template&lt;typename&gt;
    struct rank
    : public integral_constant&lt;std::size_t, 0&gt; &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct rank&lt;_Tp[_Size]&gt;
    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct rank&lt;_Tp[]&gt;
    : public integral_constant&lt;std::size_t, 1 + rank&lt;_Tp&gt;::value&gt; &#123; &#125;;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00bcd4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #ffa2c4">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/28/type-traits源码分析-三/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/type-traits源码分析-二-/">
        <h2 class="post-title">Type-Traits源码分析(二)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>在一中，介绍了一些type_trait的基本设施, 很轻松，唯一比较复杂的就是is_pointer。在二中，将继续探索tyep_traits中的基本设施——这些设施在TMP中，撰写库的时候经常用到。这篇文章不会涉及到一些高级的技巧。这些技巧放在后面分析。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="元函数的实现技巧"><a href="#元函数的实现技巧" class="headerlink" title="元函数的实现技巧"></a>元函数的实现技巧</h2><p>在标准库中，或者自己想要撰写元函数，可以使用这样一种手法。例如想实现一个名为XXX的元函数。</p>
<p>可以另外定义一个元函数叫做XXX_helper&#x2F;XXX_impl(随你的喜好，叫什么猫猫狗狗也没有问题)来解决核心的部分。</p>
<p>而XXX这个元函数，做一些辅助性的操作，例如移除const，volatile。让后让XXX继承XXX_helper来实现功能。</p>
<h2 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h2><p>传入一个类型，返回其是不是void，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>真正的实现是<code>__is_void_helper</code>，而<code>is_void</code>做一些辅助性的操作。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_void_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_void_helper&lt;void&gt;
    : public true_type &#123; &#125;;

  /// is_void
  template&lt;typename _Tp&gt;
    struct is_void
    : public __is_void_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //移除const volatile
    &#123; &#125;;
</code></pre>
<h2 id="is-integral"><a href="#is-integral" class="headerlink" title="is_integral"></a>is_integral</h2><p>传入一个类型，返回其是不是integral，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p><code>integral</code>可以理解为整形，包括无符号类型。或者随你怎么理解都行，只要你看到了实现，你就知道了他是什么意思。</p>
<p>同样的<code>__is_integral_helper</code>做的具体的操作，有很多个特例化模板。你会说编写一个宏更方便不是吗？也许是的！</p>
<pre><code class="C++"> template&lt;typename&gt;
    struct __is_integral_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;bool&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;char&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;signed char&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned char&gt;
    : public true_type &#123; &#125;;

  // We want is_integral&lt;wchar_t&gt; to be true (and make_signed/unsigned to work)
  // even when libc doesn&#39;t provide working &lt;wchar.h&gt; and related functions,
  // so check __WCHAR_TYPE__ instead of _GLIBCXX_USE_WCHAR_T.
#ifdef __WCHAR_TYPE__
  template&lt;&gt;
    struct __is_integral_helper&lt;wchar_t&gt;
    : public true_type &#123; &#125;;
#endif

#ifdef _GLIBCXX_USE_CHAR8_T
  template&lt;&gt;
    struct __is_integral_helper&lt;char8_t&gt;
    : public true_type &#123; &#125;;
#endif

  template&lt;&gt;
    struct __is_integral_helper&lt;char16_t&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;char32_t&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;short&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned short&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;int&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned int&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;long long&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned long long&gt;
    : public true_type &#123; &#125;;

  // Conditionalizing on __STRICT_ANSI__ here will break any port that
  // uses one of these types for size_t.
#if defined(__GLIBCXX_TYPE_INT_N_0) //这些条件编译你大可忽略掉，有兴趣也可以看看。
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_0&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_0&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_1)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_1&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_1&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_2)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_2&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_2&gt;
    : public true_type &#123; &#125;;
#endif
#if defined(__GLIBCXX_TYPE_INT_N_3)
  template&lt;&gt;
    struct __is_integral_helper&lt;__GLIBCXX_TYPE_INT_N_3&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_integral_helper&lt;unsigned __GLIBCXX_TYPE_INT_N_3&gt;
    : public true_type &#123; &#125;;
#endif

  /// is_integral
  template&lt;typename _Tp&gt;
    struct is_integral
    : public __is_integral_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //与is_void使用相同的手法
    &#123; &#125;;
</code></pre>
<h2 id="is-floating-point"><a href="#is-floating-point" class="headerlink" title="is_floating_point"></a>is_floating_point</h2><p>传入一个类型，返回其是不是浮点类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>如果你会了is_integral,那么is_floating_point也无需多言了。</p>
<pre><code class="C++"> template&lt;typename&gt;
    struct __is_floating_point_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;float&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;double&gt;
    : public true_type &#123; &#125;;

  template&lt;&gt;
    struct __is_floating_point_helper&lt;long double&gt;
    : public true_type &#123; &#125;;

#if !defined(__STRICT_ANSI__) &amp;&amp; defined(_GLIBCXX_USE_FLOAT128) //同样是条件编译，可忽略
  template&lt;&gt;
    struct __is_floating_point_helper&lt;__float128&gt;
    : public true_type &#123; &#125;;
#endif

  /// is_floating_point
  template&lt;typename _Tp&gt;
    struct is_floating_point
    : public __is_floating_point_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-array"><a href="#is-array" class="headerlink" title="is_array"></a>is_array</h2><p>传入一个类型，返回其是不是数组(有界的&#x2F;无界的)，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>老方法了，主模板+偏特化。值得注意的是，T*不同于T[]和T[N]。例如</p>
<pre><code class="C++">int main() &#123;
    int nums[10] = &#123;1,2,3,4&#125;;
    cout &lt;&lt; std::is_array&lt;decltype(nums)&gt;::value &lt;&lt; endl; //true
    int * const p = nums;
    cout &lt;&lt; std::is_array&lt;decltype(p)&gt;::value &lt;&lt; endl;	//false
    return 0;
&#125;
</code></pre>
<pre><code class="C++">    /// is_array
    // 区别T *, T[], T[N]的不同
  template&lt;typename&gt;
    struct is_array
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct is_array&lt;_Tp[_Size]&gt;	//有界数组
    : public true_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_array&lt;_Tp[]&gt; //无界数组
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-pointer"><a href="#is-pointer" class="headerlink" title="is_pointer"></a>is_pointer</h2><p>传入一个类型，返回其是不是指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>注意<code>const *</code>,<code>* const</code>的不同，前者不是指针具有常量性质，后者才是。</p>
<pre><code class="C++">template&lt;typename&gt;
    struct __is_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct __is_pointer_helper&lt;_Tp*&gt;
    : public true_type &#123; &#125;;

  /// is_pointer
  template&lt;typename _Tp&gt;
    struct is_pointer
    : public __is_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type //remove_cv
    &#123; &#125;;
</code></pre>
<h2 id="is-complete-or-unbounded"><a href="#is-complete-or-unbounded" class="headerlink" title="__is_complete_or_unbounded"></a>__is_complete_or_unbounded</h2><p>传入一个类型，返回其是不是完整的或者无界的，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>因为这不是一个最终对外提供的接口。所以可以使用constexpr函数的方式来实现。</p>
<p>首先我们应当知道的一个前置知识：如果是一个类型是非完整类型，或者无界类型，sizeof 会无法应用。例如</p>
<pre><code class="C++">template&lt;typename T&gt;
struct size_is &#123;
    static constexpr size_t value = sizeof(T);
&#125;;
class A; //A仅有声明，是一个非完整类型
int main() &#123;
    cout &lt;&lt; size_is&lt;int&gt;::value &lt;&lt; endl; 	//ok
    cout &lt;&lt; size_is&lt;int[]&gt;::value &lt;&lt; endl;	//error
    cout &lt;&lt; size_is&lt;A&gt;::value &lt;&lt; endl;		//error
    return 0;
&#125;
</code></pre>
<p>一个无界&#x2F;不完整类型还包括</p>
<ul>
<li>引用</li>
<li>函数</li>
<li>void</li>
<li>无界数组</li>
</ul>
<pre><code class="C++">// Helper functions that return false_type for incomplete classes,
  // incomplete unions and arrays of known bound from those.
//为不完整的类、不完整的联合和已知边界数组返回 false_type 的辅助函数。
template &lt;typename _Tp, size_t = sizeof(_Tp)&gt; //如果是非完整类型，或者无界类型，sizeof 会无法应用
    constexpr true_type __is_complete_or_unbounded(__type_identity&lt;_Tp&gt;) //由于我们只关心返回类型，所以不用返回值
                    //或者说返回类型种隐含了返回值true_type::value==true;
    &#123; return &#123;&#125;; &#125;

  template &lt;typename _TypeIdentity,	
      typename _NestedType = typename _TypeIdentity::type&gt;	//上面的模板匹配失败，转而匹配这个模板
    constexpr typename __or_&lt; //是其中一个
      is_reference&lt;_NestedType&gt;,
      is_function&lt;_NestedType&gt;,
      is_void&lt;_NestedType&gt;,
      __is_array_unknown_bounds&lt;_NestedType&gt;	//这个tyep_traits还没有分析，仅仅知道如何用也不妨
    &gt;::type __is_complete_or_unbounded(_TypeIdentity) //如果__or_种的元函数的返回类型皆为false_type，也就是说参数类型不是上面那些类型其中之一，最终结果就是false_type
    &#123; return &#123;&#125;; &#125;
</code></pre>
<h2 id="is-enum-x2F-class-x2F-union"><a href="#is-enum-x2F-class-x2F-union" class="headerlink" title="is_enum&#x2F;class&#x2F;union"></a>is_enum&#x2F;class&#x2F;union</h2><p>传入一个类型，返回其是不是enum&#x2F;class&#x2F;union，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>编译器为我们内置了这三种type_traits。你只需要知道这是内置的就好。</p>
<pre><code class="C++">  /// is_enum
  template&lt;typename _Tp&gt;
    struct is_enum
    : public integral_constant&lt;bool, __is_enum(_Tp)&gt; //无法查看__is_enum的具体实现，下同
    &#123; &#125;;

  /// is_union
  template&lt;typename _Tp&gt;
    struct is_union
    : public integral_constant&lt;bool, __is_union(_Tp)&gt;
    &#123; &#125;;

  /// is_class
  template&lt;typename _Tp&gt;
    struct is_class
    : public integral_constant&lt;bool, __is_class(_Tp)&gt;
    &#123; &#125;;
</code></pre>
<h2 id="is-null-pointer"><a href="#is-null-pointer" class="headerlink" title="is_null_pointer"></a>is_null_pointer</h2><p>传入一个类型，返回其是不是空指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>空指针该如何做特例化。C++11有nullptr,是nullptr_t类型(nullptr_t是decltype(nullptr)的一个别名), 由于任何型别的指针类型都可以转换为nullptr_t，所以，对nullptr_t类型做特例化即可。</p>
<p>关于以后的type_traits，如果还是老生常谈的设计手法。就不会再说了，就像这个type_traits一样。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_null_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;&gt;
    struct __is_null_pointer_helper&lt;std::nullptr_t&gt;
    : public true_type &#123; &#125;;

  /// is_null_pointer (LWG 2247).
  template&lt;typename _Tp&gt;
    struct is_null_pointer
    : public __is_null_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<p>GCC还提供了一个不推荐使用的拓展。</p>
<pre><code class="C++">  /// __is_nullptr_t (deprecated extension).
  template&lt;typename _Tp&gt;
    struct __is_nullptr_t
    : public is_null_pointer&lt;_Tp&gt;
    &#123; &#125; _GLIBCXX_DEPRECATED_SUGGEST(&quot;std::is_null_pointer&quot;); //这些宏实在是不想深究到底，令人厌烦的宏！
</code></pre>
<h2 id="is-arithmetic"><a href="#is-arithmetic" class="headerlink" title="is_arithmetic"></a>is_arithmetic</h2><p>传入一个类型，返回其是不是可运算的类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>整形类型和浮点类型被视作是可运算的类型，无论是否具有const性质。</p>
<blockquote>
<p>你可能会想到，如果自定义类型也支持+ - * &#x2F;等运算，是不是这个type_traits就不好使了呢？难道有bug吗？</p>
<p>你可以将这个type_traits看作一个规定。并且，不要为任何自定义类型做任何的type_traits的特例化。永远不要，因为这是一个未定义的行为。有关更多， 请看<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/is_arithmetic">std::is_arithmetic - cppreference.com</a></p>
</blockquote>
<pre><code class="C++">  /// is_arithmetic
  template&lt;typename _Tp&gt;
    struct is_arithmetic
    : public __or_&lt;is_integral&lt;_Tp&gt;, is_floating_point&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-fundamental"><a href="#is-fundamental" class="headerlink" title="is_fundamental"></a>is_fundamental</h2><p>传入一个类型，返回其是不是基本类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>可运算类型，void, nullptr_t被视作为基本类型，理由和注意事项同上。</p>
<pre><code class="C++">  /// is_fundamental
  template&lt;typename _Tp&gt;
    struct is_fundamental
    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_void&lt;_Tp&gt;,
           is_null_pointer&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-compound"><a href="#is-compound" class="headerlink" title="is_compound"></a>is_compound</h2><p>传入一个类型，返回其是不是复合类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>只需要对is_fundamental的结果取反，也就是应用__not_即可</p>
<pre><code class="C++">  /// is_compound
  template&lt;typename _Tp&gt;
    struct is_compound
    : public __not_&lt;is_fundamental&lt;_Tp&gt;&gt;::type &#123; &#125;;
</code></pre>
<h2 id="is-object"><a href="#is-object" class="headerlink" title="is_object"></a>is_object</h2><p>传入一个类型，返回其是不是一个对象，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>这里的object指的是广义上的对象。例如int,double类型的实例皆算对象。例如但函数，引用，void类型不算在内。</p>
<pre><code class="C++">struct A &#123;
    int m_data = 0;
&#125;;
int main() &#123;
    cout &lt;&lt; std::is_object&lt;int&gt;::value &lt;&lt; endl;			//true
    cout &lt;&lt; std::is_object&lt;double&gt;::value &lt;&lt; endl;		//true
    cout &lt;&lt; std::is_object&lt;int&amp;&gt;::value &lt;&lt; endl; 		//false
    cout &lt;&lt; std::is_object&lt;A&gt;::value &lt;&lt; endl;			//true
    cout &lt;&lt; std::is_object&lt;void(int,int)&gt;::value &lt;&lt; endl;//false
    return 0;
&#125;
</code></pre>
<p>实现</p>
<pre><code class="C++">/// is_object
template&lt;typename _Tp&gt;
  struct is_object
  : public __not_&lt;__or_&lt;is_function&lt;_Tp&gt;, is_reference&lt;_Tp&gt;,
                        is_void&lt;_Tp&gt;&gt;&gt;::type
  &#123; &#125;;
</code></pre>
<h2 id="is-scalar"><a href="#is-scalar" class="headerlink" title="is_scalar"></a>is_scalar</h2><p>传入一个类型，返回其是不是一个标量类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<blockquote>
<p>标量类型包括算数类型，枚举类型，指针，成员指针，空指针.将在那些元函数应用于__or_即可</p>
</blockquote>
<pre><code class="C++">  /// is_scalar
  template&lt;typename _Tp&gt;
    struct is_scalar
    : public __or_&lt;is_arithmetic&lt;_Tp&gt;, is_enum&lt;_Tp&gt;, is_pointer&lt;_Tp&gt;, 
                   is_member_pointer&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h2 id="is-compound-1"><a href="#is-compound-1" class="headerlink" title="is_compound"></a>is_compound</h2><p>传入一个类型，返回其是不是一个复合类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<pre><code class="C++">  /// is_compound
  template&lt;typename _Tp&gt;
    struct is_compound // 对is_fundamental取否定即可
    : public __not_&lt;is_fundamental&lt;_Tp&gt;&gt;::type &#123; &#125;; 
</code></pre>
<h2 id="is-same"><a href="#is-same" class="headerlink" title="is_same"></a>is_same</h2><p>传入两个类型，返回其是不是相同类型，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>对&lt;_Tp, _Tp&gt;做特例化即可。</p>
<pre><code class="C++">  /// is_same
 //下面省略了一些条件编译
  template&lt;typename _Tp, typename _Up&gt; //不同类型的时候
    struct is_same
    : public false_type
    &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_same&lt;_Tp, _Tp&gt; //相同类型的时候
    : public true_type
    &#123; &#125;;
</code></pre>
<h2 id="is-member-object-x2F-function-pointer"><a href="#is-member-object-x2F-function-pointer" class="headerlink" title="is_member_object&#x2F;function_pointer"></a>is_member_object&#x2F;function_pointer</h2><p>传入一个类型，返回其是不是指向类内非静态数据成员&#x2F;成员函数的指针，如果是，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>在文章的最后，我准备了一些更加酷的东西，当然，也更加的复杂。首先，我们应当了解一下基本的原理：</p>
<p>如果A是一个类，那么可以有这样的一种指针<code>type A::*</code> 指向A中类型为type的数据成员(非静态的，下文省略)。类似的，还有成员函数指针。例如</p>
<pre><code class="C++">struct A &#123;
    int a = 10;
    void inc_and_print() &#123;
        ++a;
        cout &lt;&lt; a &lt;&lt; endl;
    &#125;
&#125;;
int main() &#123;
    int A::* p = &amp;A::a;
    //使用
    A x;
    x.*p = 10; //固定的语法形式
    cout &lt;&lt; x.*p &lt;&lt; endl;   //10
    cout &lt;&lt; x.a &lt;&lt; endl;    //10

    using Fun = void (A::*)();
//    void(A::*fun)();
    Fun fun = &amp;A::inc_and_print;
    (x.*fun)(); //such as call A::inc_and_print //a is 11
    return 0;
&#125;
</code></pre>
<p>C++还有这种语法？你会疑问，这是肯定的！但这无关紧要，在什么情况下才能用上这样的语法？貌似真的没有，除了TMP。</p>
<p>你知道了解一点，如果T是一个类，则可以有<code>type T::*</code>这样的形式指向数据成员&#x2F;成员函数，不是类则没有。</p>
<p>并且还要说明的是，不要纠结在这些语法的琐碎上，<strong>Bjarne Stroustrup</strong>也不会对所有的C++语法细节和标准全部一清二楚。不要陷入语法细节的深渊——C++在承受着巨大的历史包袱的同时，还要添加现代的语法特性，想学完C++————下辈子说不定可以！</p>
<p>关于具体的实现，请看源代码，我会一点点说明。</p>
<pre><code class="C++">template&lt;typename&gt;
    struct __is_member_object_pointer_helper //主模板继承false_type
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; //注意这里没有逗号，模板匹配的时候会将一个类型拆分成两个了类型的组合，好复杂的语法，可恶
      //匹配到这个特例化模板可以是数据成员指针，也可以是成员函数指针。如果不是成员函数指针，就是数据成员指针了
    : public __not_&lt;is_function&lt;_Tp&gt;&gt;::type &#123; &#125;; 

  /// is_member_object_pointer
  template&lt;typename _Tp&gt;
    struct is_member_object_pointer 
    : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<p>太复杂了！你可能还是对上述代码中的哪个特例化有疑问，好吧！让我们一探究竟。我们对上述的代码改造一下。对于那个特例化，我们在其内部定义两个类型T1, T2为 _Tp, _Cp的别名，_Tp,_Cp到底被推断为什么类型。</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
namespace jan &#123;
    using std::__not_;
    using std::true_type;
      using std::false_type;
      using std::is_function;
     using std::__remove_cv_t;
    template&lt;typename&gt;
    struct __is_member_object_pointer_helper
    : public false_type &#123; &#125;;

     template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; 
    : public __not_&lt;is_function&lt;_Tp&gt;&gt;::type &#123; 
        using T1 = _Tp;	//这里是我们添加的
        using T2 = _Cp;
    &#125;;

  /// is_member_object_pointer
  template&lt;typename _Tp&gt;
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
&#125;

class A &#123; &#125;;
int main() &#123;
     jan::is_member_object_pointer&lt;int A::*&gt;::type t;
      return 0;
&#125;
</code></pre>
<p>编译器会为我们生成这样的代码。</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
namespace jan
&#123;
  using std::__not_;
  template&lt;typename _Pp&gt;
  
  using std::true_type;
  using std::false_type;
  using std::is_function;
  template&lt;typename _Tp&gt;
  
  using std::__remove_cv_t;
  template&lt;typename std::_Tp&gt;
  using std::__remove_cv_t = typename remove_cv&lt;_Tp&gt;::type;
  
  template&lt;typename type_parameter_0_0&gt;
  struct __is_member_object_pointer_helper : public std::false_type
  &#123;
  &#125;;
  /****************************************注意看这里******************************************/
  /* First instantiated from: insights.cpp:23 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template&lt;&gt;
  struct __is_member_object_pointer_helper&lt;int A::*&gt; : public std::integral_constant&lt;bool, true&gt;
  &#123;
    using T1 = int; //_Tp is int
    using T2 = A;   //_Cp is A
  &#125;;
  /******************************************************************************************/
  #endif
  template&lt;typename _Tp, typename _Cp&gt;
  struct __is_member_object_pointer_helper&lt;_Tp _Cp::*&gt; : public __not_&lt;is_function&lt;_Tp&gt; &gt;::type
  &#123;
    using T1 = _Tp;
    using T2 = _Cp;
  &#125;;
  
  template&lt;typename _Tp&gt; //在这个例子中， _Tp us int A::*
  struct is_member_object_pointer : public __is_member_object_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt; &gt;::type
  &#123;
  &#125;;
  
  /* First instantiated from: insights.cpp:30 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template&lt;&gt;
  struct is_member_object_pointer&lt;int A::*&gt; : public std::integral_constant&lt;bool, true&gt;
  &#123;
  &#125;;
  #endif 
&#125;
class A&#123; &#125;;
int main()
&#123;
    std::integral_constant&lt;bool, true&gt; t = std::integral_constant&lt;bool, true&gt;(); //这里无关紧要
     return 0;
&#125;
</code></pre>
<p>恍然大悟了吧！</p>
<p>类似的<code>is_member_function_pointer</code>有这样的实现。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct __is_member_function_pointer_helper
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, typename _Cp&gt;
    struct __is_member_function_pointer_helper&lt;_Tp _Cp::*&gt;
//匹配到这个特例化模板可以是数据成员指针，也可以是成员函数指针。那就用is_function这个type_traits是不是一个函数即可
    : public is_function&lt;_Tp&gt;::type &#123; &#125;; 

  /// is_member_function_pointer
  template&lt;typename _Tp&gt;
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type
    &#123; &#125;;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇大部分的源码分析还是轻松的，除了个别的刺头。</p>
<p>你听说过brainfuck这个语言吗？相比于brainfuck这个语言，C++才是真正的brainfunk! </p>
<p>我的🧠要爆炸了！！！</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00a596">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #00a596">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/type-traits源码分析-二-/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/type-traits源码分析-一-/">
        <h2 class="post-title">Type_traits源码分析(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="type-traits概述"><a href="#type-traits概述" class="headerlink" title="type_traits概述"></a>type_traits概述</h1><p>tyep_traits是C++TMP中不可缺少的一部分，也是Modern C++不可缺少的一部分。任何一位C++程序员，如果想学习Modern C++，想学号Modern C++，肯定不能避免学习type_traits。</p>
<h2 id="什么是type-traits"><a href="#什么是type-traits" class="headerlink" title="什么是type_traits?"></a>什么是type_traits?</h2><p>type_traits，顾名思义，为类型萃取器&#x2F;类型特征。type_traits是一系列的元函数。在普通函数中，我们传入数据，返回数据。但是在元函数中，我们传入类型&#x2F;常量，返回类型&#x2F;常量。</p>
<p>C++ type_traits的实现,也就是元函数的一般形式, 使用结构体+模板(模式匹配+模板偏特化)的方式。</p>
<p>使用&lt;&gt;来传入类型(语法层面的), 使用::value&#x2F;::type来获得返回值&#x2F;返回类型(约定俗成的)。<br>例如<code>std::true_type::value == true</code>,<code>std::false_type::value == false</code>,<code>std::remove_const&lt;const int&gt;::value</code></p>
<p>所有的type_traits操作均发生在编译时期。</p>
<h2 id="type-trait能够干什么"><a href="#type-trait能够干什么" class="headerlink" title="type_trait能够干什么?"></a>type_trait能够干什么?</h2><p>type_traits不仅是标准库的重要组成部分，也是模板元编程中的基本技能。</p>
<p>标准库中的类型安全也多亏了type_traits，在各种C++库中也总是能看到type_traits的身影。</p>
<h1 id="type-traits中的约定"><a href="#type-traits中的约定" class="headerlink" title="type_traits中的约定"></a>type_traits中的约定</h1><p>type_traits发展了很长的时间，C++标准演化出来了一套规定<br>通用的规定</p>
<ul>
<li>使用::value来表示返回值(值元函数)</li>
<li>使用::type来表示返回类型(类型元函数)</li>
<li>每个元函数只能返回一个类型或者一个值</li>
<li>元函数可以同时是值元函数和类型元函数</li>
<li>元函数必须是一个模板类</li>
<li>对于一个type_traits,形如XXX_t的形式是一个类型应用XXX后的返回类型</li>
<li>对于一个type_traits,形如XXX_v的形式是一个类型应用XXX后的返回值(C++17)</li>
</ul>
<p>对于一元type_traits的规定</p>
<ul>
<li>接受一个类型参数 + 可选的辅助附加参数</li>
<li>必须可以默认构造</li>
<li>必须可以拷贝构造</li>
<li>必须公开且无歧义</li>
<li>所有的一元元函数都必须从std::integral_constant继承</li>
<li>基本的特征成员不应该被隐藏，而且明确可用</li>
</ul>
<p>对于二元元函数的规定</p>
<ul>
<li>接受有两个类型参数 + 可选的辅助附加参数</li>
<li>必须可以默认构造</li>
<li>必须可以拷贝构造</li>
<li>必须公开且无歧义</li>
<li>所有的一元元函数都必须从std::integral_constant的特例化继承</li>
<li>基本的特征成员不应该被隐藏，而且明确可用</li>
</ul>
<p>对于transformation-traits的规定</p>
<ul>
<li>接受一个类型参数 + 可选的辅助附加参数</li>
<li>定义一个public的名为type的嵌套类型</li>
<li>没有默认&#x2F;拷贝构造的要求(可以有，也可以没有)</li>
</ul>
<blockquote>
<p>你会发现标准库的有些地方没有遵守这个标准——那些代码是在这个标准没有成型之前，例如迭代器有关的类型萃取</p>
</blockquote>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>本篇文章使用gcc编译器，会提到17,20中的type_traits,请确保你所用的编译器支持17，20</p>
<p>对于有些条件编译，不列出源码并且不分析</p>
<p>我会将元函数和type_traits等价起来，如果文中说元函数，你可以联系上下文把其当作type_traits。反之亦然。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>标准库对于type_traits的实现，放在了type_traits中</p>
<h2 id="integral-constant"><a href="#integral-constant" class="headerlink" title="integral_constant"></a>integral_constant</h2><pre><code class="C++"> template&lt;typename _Tp, _Tp __v&gt;
    struct integral_constant
    &#123;
      static constexpr _Tp                  value = __v;
      typedef _Tp                           value_type;
      typedef integral_constant&lt;_Tp, __v&gt;   type;
      constexpr operator value_type() const noexcept &#123; return value; &#125;
    //有constexpr性质，可以编译时期求值
      constexpr value_type operator()() const noexcept &#123; return value; &#125;
    &#125;;
</code></pre>
<p>我们可以看见integral_constant定义的很简单，记得unix的哲学吗? less is more! 几乎所有的type_traits都会直接的或者间接的继承integral_constant</p>
<h2 id="true-type-false-type"><a href="#true-type-false-type" class="headerlink" title="true_type false_type"></a>true_type false_type</h2><p><code>true_type</code>,<code>false_type</code>仅仅是integral_constant的别名，定义如下</p>
<pre><code class="C++">  /// The type used as a compile-time boolean with true value.
  typedef integral_constant&lt;bool, true&gt;     true_type;

  /// The type used as a compile-time boolean with false value.
  typedef integral_constant&lt;bool, false&gt;    false_type;
</code></pre>
<p>很多的元函数都继承这两个类型，例如is_XXX等元函数。</p>
<h2 id="bool-constant"><a href="#bool-constant" class="headerlink" title="bool_constant"></a>bool_constant</h2><p>很好理解</p>
<pre><code class="C++">  /// The type used as a compile-time boolean with true value.
  typedef integral_constant&lt;bool, true&gt;     true_type;

  /// The type used as a compile-time boolean with false value.
  typedef integral_constant&lt;bool, false&gt;    false_type;
</code></pre>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>conditional接受三个参数，一个bool值，两个类型参数，作用相当于编译时期的if，可以这样描述</p>
<p><code>&lt;bool p, T1, T2&gt; p ? T1 : T2</code></p>
<pre><code class="C++">//前置声明
template&lt;bool, typename, typename&gt;
    struct conditional;  
...
/// Define a member typedef @c type to one of two argument types.
  template&lt;bool _Cond, typename _Iftrue, typename _Iffalse&gt; //主模板
    struct conditional
    &#123; typedef _Iftrue type; &#125;;

  // Partial specialization for false.
  template&lt;typename _Iftrue, typename _Iffalse&gt;		//特化模板
    struct conditional&lt;false, _Iftrue, _Iffalse&gt;
    &#123; typedef _Iffalse type; &#125;;
</code></pre>
<h2 id="type-identity"><a href="#type-identity" class="headerlink" title="__type_identity"></a>__type_identity</h2><p>关于个元函数，没有明确的规定，可以教type_is,或者其他的东西。每个标准库的实现都有所不同。作用就是给定一个T类型，返回一个T类型，用于被其他元函数继承。</p>
<pre><code class="C++">  template &lt;typename _Type&gt;
    struct __type_identity
    &#123; using type = _Type; &#125;;

  template&lt;typename _Tp&gt;
    using __type_identity_t = typename __type_identity&lt;_Tp&gt;::type;
</code></pre>
<h2 id="logic-traits"><a href="#logic-traits" class="headerlink" title="logic traits"></a>logic traits</h2><p>合取，析取，否定 traits。其中<code>conjunction</code>、<code>disjunction</code>、<code>negation</code>在定义了宏<code>__cpp_lib_logical_traits 201510</code>才启用</p>
<h3 id="or"><a href="#or" class="headerlink" title="__or_"></a><strong>__or_</strong></h3><p>类似or关键字，__or_元函数接受一个参数包，对这些类型的返回值求析取</p>
<pre><code class="C++">template&lt;typename...&gt;
    struct __or_; //主模板永远不能被匹配匹配到，所以不用定义

  template&lt;&gt;
    struct __or_&lt;&gt;	//如果没有类型，继承true_type
    : public false_type
    &#123; &#125;;

  template&lt;typename _B1&gt;
    struct __or_&lt;_B1&gt; //有一个类型继承哪个类型
    : public _B1
    &#123; &#125;;

  template&lt;typename _B1, typename _B2&gt; //如果时两个类型，递归的继承
    struct __or_&lt;_B1, _B2&gt;
    : public conditional&lt;_B1::value, _B1, _B2&gt;::type 
    //if _B1::value==true，那么不再判断，继承_B1即可，我们关心的是::value的这个返回值。
    //if _B1::value==false, 则继承_B2，此时_B2匹配到接受一个参数的特例化
    &#123; &#125;;

  template&lt;typename _B1, typename _B2, typename _B3, typename... _Bn&gt; //接受多个类型
    struct __or_&lt;_B1, _B2, _B3, _Bn...&gt;
    : public conditional&lt;_B1::value, _B1, __or_&lt;_B2, _B3, _Bn...&gt;&gt;::type
    //if _B1::value==true同理
    //if _B1::value==false, 递归的继承__or_&lt;_B2, _B3, _Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">//这种语法是C++17添加进来的，也很有效的简化了模板元编程的复杂性
template&lt;typename... _Bn&gt;
    inline constexpr bool __or_v = __or_&lt;_Bn...&gt;::value; //__or_v即是类型用用于__or_v后的返回
//__and_v同
</code></pre>
<h3 id="and"><a href="#and" class="headerlink" title="__and_"></a><strong>__and_</strong></h3><p>__and_的功能和实现与__or_的功能和实现大同小异</p>
<pre><code class="C++">  template&lt;typename...&gt;
    struct __and_;

  template&lt;&gt;
    struct __and_&lt;&gt;
    : public true_type //这里继承true_type
    &#123; &#125;;

  template&lt;typename _B1&gt;
    struct __and_&lt;_B1&gt;
    : public _B1
    &#123; &#125;;

  template&lt;typename _B1, typename _B2&gt;
    struct __and_&lt;_B1, _B2&gt;
    : public conditional&lt;_B1::value, _B2, _B1&gt;::type //这里的类型排列相较于__or_是反的
    &#123; &#125;;

  template&lt;typename _B1, typename _B2, typename _B3, typename... _Bn&gt;
    struct __and_&lt;_B1, _B2, _B3, _Bn...&gt;
    : public conditional&lt;_B1::value, __and_&lt;_B2, _B3, _Bn...&gt;, _B1&gt;::type //类型排列同上
    &#123; &#125;;
</code></pre>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    inline constexpr bool __and_v = __and_&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="not"><a href="#not" class="headerlink" title="__not_"></a><strong>__not_</strong></h3><p>__not_对给定类型的::value返回值取反,实现非常的简单</p>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    struct __not_
    : public __bool_constant&lt;!bool(_Pp::value)&gt; //这里有一个强转
    &#123; &#125;;
</code></pre>
<h3 id="conjunction"><a href="#conjunction" class="headerlink" title="conjunction"></a><strong>conjunction</strong></h3><p>合取，功能和__or_一样，通过继承其实现。</p>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    struct conjunction
    : __and_&lt;_Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">template&lt;typename... _Bn&gt;
    inline constexpr bool conjunction_v = conjunction&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="disjunction"><a href="#disjunction" class="headerlink" title="disjunction"></a><strong>disjunction</strong></h3><p>析取，同上</p>
<pre><code class="C++">  template&lt;typename... _Bn&gt;
    struct disjunction
    : __or_&lt;_Bn...&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">   template&lt;typename... _Bn&gt;
    inline constexpr bool disjunction_v = disjunction&lt;_Bn...&gt;::value;
</code></pre>
<h3 id="negation"><a href="#negation" class="headerlink" title="negation"></a><strong>negation</strong></h3><p>否定，同上</p>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    struct negation
    : __not_&lt;_Pp&gt;
    &#123; &#125;;
</code></pre>
<pre><code class="C++">  template&lt;typename _Pp&gt;
    inline constexpr bool negation_v = negation&lt;_Pp&gt;::value;
</code></pre>
<h2 id="is-l-x2F-r-reference"><a href="#is-l-x2F-r-reference" class="headerlink" title="is_l&#x2F;r reference"></a>is_l&#x2F;r reference</h2><p>传入一个类型，返回其是不是一个左值&#x2F;右值引用类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type</p>
<pre><code class="C++">  /// is_lvalue_reference
  template&lt;typename&gt;		//主模板继承false_type
    struct is_lvalue_reference
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_lvalue_reference&lt;_Tp&amp;&gt; //对于左值引用的特例化，继承true_type
    : public true_type &#123; &#125;;

  /// is_rvalue_reference
  template&lt;typename&gt;			//同上
    struct is_rvalue_reference
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;		//同上
    struct is_rvalue_reference&lt;_Tp&amp;&amp;&gt;
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-reference"><a href="#is-reference" class="headerlink" title="is_reference"></a>is_reference</h2><p>传入一个类型，返回其是不是一个引用类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type</p>
<pre><code class="C++">template&lt;typename&gt;
struct is_reference; //声明

template&lt;typename _Tp&gt;
struct is_reference 		//左值引用/右值引用
    : public __or_&lt;is_lvalue_reference&lt;_Tp&gt;, 这里用__or_来实现
                   is_rvalue_reference&lt;_Tp&gt;&gt;::type
&#123; &#125;;
</code></pre>
<h2 id="is-const"><a href="#is-const" class="headerlink" title="is_const"></a>is_const</h2><p>传入一个类型，返回其是否具有const性质，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>通过普通的模板特化就可以实现</p>
<pre><code class="C++">  /// is_const
  template&lt;typename&gt;
    struct is_const
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_const&lt;_Tp const&gt; //对于const的特化
    : public true_type &#123; &#125;;
</code></pre>
<p>注意，对于&amp;&#x2F;&amp;&amp;is_const的返回类型是一个::false_type,就是所<code>std::is_const&lt;const int &amp;&gt;::value==false</code></p>
<p>类似的，还有<code>const int *</code>也是一样。因为这样的语义表示的指向的对象是常量性质的，而不是引用&#x2F;指针本身是常量性质的。</p>
<h2 id="is-volatile"><a href="#is-volatile" class="headerlink" title="is_volatile"></a>is_volatile</h2><p>传入一个类型，返回其是否具有volatile性质，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>实现方式和is_const大同小异。注意的事项也和is_const是一样的。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct is_volatile
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_volatile&lt;_Tp volatile&gt;
    : public true_type &#123; &#125;;
</code></pre>
<h2 id="is-function"><a href="#is-function" class="headerlink" title="is_function"></a>is_function</h2><p>传入一个类型，返回其是不是一个函数类型，如果具有，返回值&#x2F;类型为 true&#x2F;true_type, 否则返回false&#x2F;false_type。</p>
<p>C++还有这样的功能！这是黑魔法吗？</p>
<p>这不是什么黑魔法，但确实够酷。在你惊叹他的时候，应当了解一下原理。</p>
<p>对于一个T类型，如果其是一个函数&#x2F;&amp;，对其添加const不会发成任何类型上的变化。例如</p>
<pre><code class="C++">void fun() &#123; &#125;
template &lt;typename T&gt;
struct add_const &#123;
  using type = const T;
&#125;;
int main() &#123;
    typename add_const&lt;decltype(fun)&gt;::type c;
  return 0;
&#125;
</code></pre>
<p>编译器会生成这样的代码</p>
<pre><code class="C++">void fun()
&#123;
&#125;

template&lt;typename T&gt;
struct add_const
&#123;
  using type = const T;
&#125;;

/* First instantiated from: insights.cpp:10 */
#ifdef INSIGHTS_USE_TEMPLATE
template&lt;&gt;
struct add_const&lt;void ()&gt; 
&#123;
  using type = void (); //类型上没有发生任何变化
&#125;;

#endif

int main()
&#123;
  void c();
  return 0;
&#125;
</code></pre>
<p>基于这个原理，我们可以轻松实现这个元函数。考虑到对于<code>const T &amp;</code>,<code>const T &amp;&amp;</code>(T不是一个函数类型) 应用is_const:value&#x3D;&#x3D;false &amp;&#x2F;&amp;&amp;继承false_type,主模板添加const性质之后判断得到的类型是不是具有const性质。</p>
<pre><code class="C++">  template&lt;typename&gt;
    struct is_function;
  /// is_function
  template&lt;typename _Tp&gt;
    struct is_function
    : public __bool_constant&lt;!is_const&lt;const _Tp&gt;::value&gt; &#123; &#125;;
    
//对引用考虑即可，对指针添加const变为*const
  template&lt;typename _Tp&gt;
    struct is_function&lt;_Tp&amp;&gt; 
    : public false_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_function&lt;_Tp&amp;&amp;&gt;
    : public false_type &#123; &#125;;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00bcd4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #03a9f4">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/type-traits源码分析-一-/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/22/unique-ptr源码解析/">
        <h2 class="post-title">Unique_ptr源码解析</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/22
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客是对unique_ptr源代码的分析，本文使用的编译器是MinGW</p>
<p>本篇文章不保证能够说明清楚unique_ptr实现的所有细节以及原因，但会尽可能的做到这样</p>
<p>需要读者有TMP的基础，例如熟悉std::enable_if, std::remove_referene等等的元函数</p>
<p>本篇文章不是一个unique_ptr的使用教程，但是会提及到一些使用中的细节</p>
<h2 id="术语约定"><a href="#术语约定" class="headerlink" title="术语约定"></a>术语约定</h2><ul>
<li>对内置指针有时候称其为raw-pointer&#x2F;裸指针</li>
<li>对于unique_ptr的指向堆区对象的指针，有时候称其为内部指针，有时候称其为指向堆区的指针，或者其他称呼。请联系上下文判别于内置指针的区别。</li>
<li>对于类型需要满足的条件，我们称其为约束条件</li>
</ul>
<h2 id="描述约定"><a href="#描述约定" class="headerlink" title="描述约定"></a>描述约定</h2><ul>
<li>对于大部分的篇幅，都会使用源代码+注释的方式来描述。如果一个问题使用注释描述篇幅过大，会单独拿出来说明</li>
<li>对于所有的源码注释，均保留</li>
</ul>
<h1 id="unique-ptr概述"><a href="#unique-ptr概述" class="headerlink" title="unique_ptr概述"></a>unique_ptr概述</h1><p>unique_ptr是比rew-pointer更为好的选择，标准库实现unique_ptr使接口尽可能的接近原生指针。不同的编译器对其实现有所不同。</p>
<p>gcc编译器对 unique_ptr的实现，大概分为以下几部分</p>
<ul>
<li>defaule_delete 定义的默认删除器，其中没有任何数据成员，是unique_ptr的默认删除器</li>
<li>__uniq_ptr_impl unique_ptr的核心部分</li>
<li>__uniq_ptr_data unique_ptr 和 __uniq_ptr_impl的中间层，unique_ptr内含一个__uniq_ptr_data</li>
<li>unique_ptr<T>     非数组版本，也是最常用的版本</li>
<li>unique_ptr&lt;T[]&gt;   数组版本，一般情况下有更好的替代(vector,array等) </li>
<li>std::make_unique，unique_ptr的配套函数，用于创建unique_ptr</li>
</ul>
<h1 id="需要了解的前置知识"><a href="#需要了解的前置知识" class="headerlink" title="需要了解的前置知识"></a>需要了解的前置知识</h1><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>C++支持OOP,这就涉及到的多态，本章的主题是指针，如果想放心的对于unique_ptr的使用就像使用内置指针一样(某些部分)，需要做类型安全的约束。包括但不限于</p>
<ul>
<li>基类和派生类的指针转换</li>
<li>数组和指针的转换</li>
<li>删除器的转换(读者看到删除器的实现就会知道了)</li>
</ul>
<p>为什么需要额外的类型安全，而不是靠编译器的检擦？</p>
<p>因为C++是一个弱类型语言，就是说在不同的类型之间可以实现隐式的类型转换——这种转换有时候很便利。但有更多的时候会产生副作用。例如精度丢失，数据溢出，甚至是内存泄漏和未定义行为。</p>
<h2 id="区别T-和T"><a href="#区别T-和T" class="headerlink" title="区别T[]和T*"></a>区别T[]和T*</h2><p>在C中<code>T[]</code>和<code>T*</code>可以看作是等价的类型，但是在C++的模板中，请将<code>T[]</code>和<code>T*</code>看作不同类型<br>例如std::is_array的实现</p>
<pre><code class="C++">template&lt;typename&gt;
    struct is_array
    : public false_type &#123; &#125;;

  template&lt;typename _Tp, std::size_t _Size&gt;
    struct is_array&lt;_Tp[_Size]&gt;
    : public true_type &#123; &#125;;

  template&lt;typename _Tp&gt;
    struct is_array&lt;_Tp[]&gt;
    : public true_type &#123; &#125;;
</code></pre>
<p>类似的如果想用unique_ptr存放数组<code>unique_ptr&lt;T[]&gt;</code>是正确的,而<code>unique_ptr&lt;T*&gt;</code>是不正确的</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>gcc对于unique_ptr的实现放在了unique_ptr.h中</p>
<p>本篇文章将按照源文件从上至下的顺序来剖析unique_ptr的实现</p>
<h2 id="unique-ptr定义的默认删除器"><a href="#unique-ptr定义的默认删除器" class="headerlink" title="unique_ptr定义的默认删除器"></a>unique_ptr定义的默认删除器</h2><pre><code class="c++">//基本的默认删除器实现
/// Primary template of default_delete, used by unique_ptr for single objects
  template &lt;typename _Tp&gt; struct default_delete &#123;
    /// Default constructor
    constexpr default_delete() noexcept = default;

    /** @brief Converting constructor.
     *
     * Allows conversion from a deleter for objects of another type, `_Up`,
     * only if `_Up*` is convertible to `_Tp*`.
     */
     // 正如注释所说，如果底层指针允许准换，则允许删除器转换
     // 空实现目的是做类型约束
     // 使用_Requires检查_Up * 能否转换为_TP *
     // 例如能用基类指针来析构一个派生类对像，却不能用派生类指针析构基类对象(先通过语法再说)
    template &lt;typename _Up, typename = _Require&lt;is_convertible&lt;_Up *, _Tp *&gt;&gt;&gt;
    default_delete(const default_delete&lt;_Up&gt; &amp;) noexcept &#123;&#125;

    //重载的调用运算符，接受一个_Tp指针，对其进行delete
    /// Calls `delete __ptr`
    void operator()(_Tp *__ptr) const &#123;
        //如果是一个非完整类型，例如只声明没有定义，会断言失败
      static_assert(!is_void&lt;_Tp&gt;::value,
                    &quot;can&#39;t delete pointer to incomplete type&quot;);
      static_assert(sizeof(_Tp) &gt; 0, &quot;can&#39;t delete pointer to incomplete type&quot;);
      delete __ptr;
    &#125;
  &#125;;
// _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 740 - omit specialization for array objects with a compile time length

  /// Specialization of default_delete for arrays, used by `unique_ptr&lt;T[]&gt;`
  template &lt;typename _Tp&gt; struct default_delete&lt;_Tp[]&gt; &#123;
  public:
    /// Default constructor
    constexpr default_delete() noexcept = default;

    /** @brief Converting constructor.
     *
     * Allows conversion from a deleter for arrays of another type, such as
     * a const-qualified version of `_Tp`.
     *
     * Conversions from types derived from `_Tp` are not allowed because
     * it is undefined to `delete[]` an array of derived types through a
     * pointer to the base type.
     */
     //允许删除其转换为另一种类型的数组，例如转换为_TP的const限定版本
     //但是不允许从子类转换为父类，不要用多态的方式处理数组，通过基类指针删除由派生类的数组是未定义的
     //所以禁止这种转换
     //具体的信息请参考《More Effective C++》条款5
    template &lt;typename _Up,
              typename = _Require&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;&gt;&gt;
    default_delete(const default_delete&lt;_Up[]&gt; &amp;) noexcept &#123;&#125;

    /// Calls `delete[] __ptr`
    template &lt;typename _Up&gt;
    typename enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type //注意这里的类型是数组的指针
                                    //虽然允许派生类指针隐式的转换为基类指针，为了检查这种转换，我们要写成这样
                                    //例如可以从non-const 转换为const，但不能从derived ** 转换为 base **
    operator()(_Up *__ptr) const &#123;
      static_assert(sizeof(_Tp) &gt; 0, &quot;can&#39;t delete pointer to incomplete type&quot;);
      //调用delete[]
      delete[] __ptr;
    &#125;
  &#125;;
</code></pre>
<p>__uniq_ptr_impl是实现部分，把这个类读懂，就读懂了unique_ptr的一半。unique_ptr的核心实现，全部在这个类中。没有复杂的逻辑，但是做到类型安全的实现方法，还是比较难的部分。__uniq_ptr_impl中没有复杂的关于类型安全的约束。比较复杂的约束在<code>uniqe_ptr&lt;T&gt;</code>和<code>unique_ptr&lt;T[]&gt;</code>中</p>
<pre><code class="C++">// Manages the pointer and deleter of a unique_ptr
//_TP是指向的类型， _DP是删除器的类型
  template &lt;typename _Tp, typename _Dp&gt; class __uniq_ptr_impl &#123;
    
    //这里做了一个type_traits
    //_Up实际上是_Tp, _Ep实际上是_Dp
    //指向堆区对象指针的的类型为_Up *
    template &lt;typename _Up, typename _Ep, typename = void&gt; struct _Ptr &#123;
      using type = _Up *;
    &#125;;

    //如果删除器中声明了删除的指针类型，有优先考虑这个指针类型
    //如果没有，类型替换失败，转而匹配上面的_Ptr
    //这样做的原因，想想一种情况
    //class B; class D : public B;
    //删除器中接受B*而实际存储的对象为D类型对象，在删除器中定义了pointer为B*
    template &lt;typename _Up, typename _Ep&gt;
    struct _Ptr&lt;_Up, _Ep,
                __void_t&lt;typename remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt; &#123;
      //这里假定了给定的_Ep有type类型，并且type下有pointer类型
      using type = typename remove_reference&lt;_Ep&gt;::type::pointer;
    &#125;;

  public:
    //这里做了一个约束条件
    //只是简单的别名定义，std::enable_if::没有取type
    //用到的地方再unique_ptr中
    //这个模板别名目的是为了约束_Dp也就是删除器，不能是一个指针，并且要求具有默认构造函数
    using _DeleterConstraint = enable_if&lt;
        __and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;

    //pointer为_Tp, _Ep经过 _Ptr类型萃取后的的别名
    //::type萃取出来一个指针类型
    //我们把pointer 这个类型直接当作raw-pointer类型
    using pointer = typename _Ptr&lt;_Tp, _Dp&gt;::type;

    //正如断言所言，unique_ptr的删除其必须是一个函数对象或者一个左值引用
    //如果是一个右值引用, !value == false,断言失败
    static_assert(!is_rvalue_reference&lt;_Dp&gt;::value,
                  &quot;unique_ptr&#39;s deleter type must be a function object type&quot;
                  &quot; or an lvalue reference type&quot;);

    __uniq_ptr_impl() = default; // =defalut是调用tuple的默认构造，tuple中的默认构造会为每个对象给定一个初值
                                 //例如int等类型会被初始化为0，而指针类型会被初始化为nullptr
    __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;

    //通过裸指针+删除器的方式构造
    //删除器使用万能引用+转发的形式传递
    template &lt;typename _Del&gt;
    __uniq_ptr_impl(pointer __p, _Del &amp;&amp;__d)
        : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123;&#125;

    //移动构造
    //注意如果类型没有移动构造函数情况就是拷贝构造
    __uniq_ptr_impl(__uniq_ptr_impl &amp;&amp;__u) noexcept
    //将u下的_M_t直接移动给自己
        : _M_t(std::move(__u._M_t)) &#123;
      __u._M_ptr() = nullptr; //滞空u下的_M_ptr
    &#125;

    //移动赋值运算符
    __uniq_ptr_impl &amp;operator=(__uniq_ptr_impl &amp;&amp;__u) noexcept &#123;
      reset(__u.release());
      _M_deleter() = std::forward&lt;_Dp&gt;(__u._M_deleter()); //将删除器转发过去 为什么用转发??
      return *this;
    &#125;

    //_M_ptr获得指向堆区内存的指针
    pointer &amp;_M_ptr() &#123; return std::get&lt;0&gt;(_M_t); &#125;
    //对于const的版本，我们按值返回即可，因为按值返回pointer的耗费较小
    pointer _M_ptr() const &#123; return std::get&lt;0&gt;(_M_t); &#125;
    //_M_ptr获得删除器
    _Dp &amp;_M_deleter() &#123; return std::get&lt;1&gt;(_M_t); &#125;
    //对于删除其，使用const &amp;方式返回，因为删除器是可能是函数对象——这种情值返回可能耗费较大
    //并且删除器有可能不支持拷贝操作
    const _Dp &amp;_M_deleter() const &#123; return std::get&lt;1&gt;(_M_t); &#125;

    //reset调用删除器析构raw-pointer指向的空间，并重新赋值为__p
    //假定不会抛出异常 使用noexcept
    void reset(pointer __p) noexcept &#123;
      const pointer __old_p = _M_ptr();
      _M_ptr() = __p;
      //不为nullptr, 进行析构操作
      if (__old_p)
        _M_deleter()(__old_p);
    &#125;

    //并不析构指针指向的内存，而是返回指针
    //并且将指向堆区部分的指针赋值为nullptr
    pointer release() noexcept &#123;
      pointer __p = _M_ptr();
      _M_ptr() = nullptr;
      return __p;
    &#125;

    //对于两个unique_ptr的swap，只需要交换其指针部分和删除器部分即可
    void swap(__uniq_ptr_impl &amp;__rhs) noexcept &#123;
      //这里的using std::swap请参考《Effective C++》条款25
      using std::swap;
      swap(this-&gt;_M_ptr(), __rhs._M_ptr());
      swap(this-&gt;_M_deleter(), __rhs._M_deleter());
    &#125;

  private:
    //使用一个tuple来存储具体指向对象的指针和删除器,便于实现，上面默认构造函数中有解释
    //并且，tuple具有空间压缩的功能(模板递归继承)
    //这种方式为什么能够压缩空间,是另一个问题了,参考《深度探索C++对象模型》
    tuple&lt;pointer, _Dp&gt; _M_t;
  &#125;;
</code></pre>
<h3 id="关于删除器的约束"><a href="#关于删除器的约束" class="headerlink" title="关于删除器的约束"></a>关于删除器的约束</h3><p>我们可以测试一下。正如我们所说在默认构造一个智能指针的情况下，不允许是一个函数指针，</p>
<p>这是由于内置指针在初始化的时候，也就是删除器初始化的时候，是一个nullptr。所以，在默认构造的情况下，不允许删除器是一个指针类型</p>
<p>如果把指针类型的删除器（函数指针）当作类型参数，编译器会说我找不到默认的构造函数，这是因为unique_ptr的默认构造函数进行了如此的约束，类型替换失败，于是找不到默认构造函数。如果析构器是函数对象或者lambda，就不会有这样的情况</p>
<pre><code class="C++">namespace jan &#123;
    template&lt;typename _Dp&gt;
    using _DeleterConstraint = enable_if&lt;
            __and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;
&#125;
void fun() &#123; &#125;
struct Foo &#123;
    Foo() = delete;
&#125;;
int main() &#123;
    typename jan::_DeleterConstraint&lt;decltype(fun)&gt;::type; //error
    typename jan::_DeleterConstraint&lt;int&gt;::type;    //ok
    typename jan::_DeleterConstraint&lt;Foo&gt;::type;    //error
    return 0;
&#125;
</code></pre>
<h3 id="关于-Ptr萃取指针的说明"><a href="#关于-Ptr萃取指针的说明" class="headerlink" title="关于_Ptr萃取指针的说明"></a>关于_Ptr萃取指针的说明</h3><p>从源代码中可以看出,如果删除器中定义了一个pointer型别，_Ptr会有限萃取出删除器::pointer作为unique_ptr的raw-pointer类型。我们想象这样一种情况。</p>
<pre><code class="C++">class A &#123; &#125;;
class B : public A &#123; &#125;;
class C : public B &#123; &#125;;

struct BDel &#123;
    using pointer = B*;
    void operator()(pointer p) &#123;
        delete p;
    &#125;
&#125;;
struct ADel&#123;
//    using pointer = B*;
    void operator()(A* p) &#123;
        //do something
        //但是和BDel做的事情不一样
        delete p;
    &#125;
&#125;;

int main() &#123;
    unique_ptr&lt;C,BDel&gt; p (new C, BDel&#123;&#125;);
    return 0;
&#125;
</code></pre>
<p>指定Bel为删除器类型，就表明，我们要处理的类型&#x2F;要删除的类型，是B类型或者B的派生类。记者OOP中的一条规则吗?面向接口编程，而不是面向实例编程。这这个情况中，尽管是个C对象，但是仍当作B类型处理。如果没有_Ptr萃取，unique_ptr::pointer就是C*，无法应用于B对象。</p>
<p>就是说尽管我们这样写<code>unique_ptr&lt;C,BDel&gt; p (new C, BDel&#123;&#125;);</code>,仍是可以应用于B对象，就像这样<code>unique_ptr&lt;C,BDel&gt; p (new B, BDel&#123;&#125;)</code></p>
<p>是有一些莫名其妙！！！</p>
<h2 id="uniq-ptr-data"><a href="#uniq-ptr-data" class="headerlink" title="__uniq_ptr_data"></a>__uniq_ptr_data</h2><p>在__uniq_ptr_impl和unique_ptr，又加上了一个中间层，目的是根据删除器是否有移动构造或者移动赋值属性，<br>部分特例化，来匹配不同的情况</p>
<pre><code class="C++">// Defines move construction + assignment as either defaulted or deleted.
  template &lt;typename _Tp, typename _Dp,
            bool = is_move_constructible&lt;_Dp&gt;::value,
            bool = is_move_assignable&lt;_Dp&gt;::value&gt;
  struct __uniq_ptr_data : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    //uisng 使用__uniq_ptr_impl的构造函数，下同
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = default;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = default;
  &#125;;

  template &lt;typename _Tp, typename _Dp&gt;
  struct __uniq_ptr_data&lt;_Tp, _Dp, true, false&gt; : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = default;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = delete;
  &#125;;

  template &lt;typename _Tp, typename _Dp&gt;
  struct __uniq_ptr_data&lt;_Tp, _Dp, false, true&gt; : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = delete;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = default;
  &#125;;

  template &lt;typename _Tp, typename _Dp&gt;
  struct __uniq_ptr_data&lt;_Tp, _Dp, false, false&gt; : __uniq_ptr_impl&lt;_Tp, _Dp&gt; &#123;
    using __uniq_ptr_impl&lt;_Tp, _Dp&gt;::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &amp;&amp;) = delete;
    __uniq_ptr_data &amp;operator=(__uniq_ptr_data &amp;&amp;) = delete;
  &#125;;
</code></pre>
<h2 id="千呼万唤始出来，犹抱琵琶半遮面"><a href="#千呼万唤始出来，犹抱琵琶半遮面" class="headerlink" title="千呼万唤始出来，犹抱琵琶半遮面"></a>千呼万唤始出来，犹抱琵琶半遮面</h2><pre><code class="C++">/// 20.7.1.2 unique_ptr for single objects.
  template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt; class unique_ptr &#123;
    template &lt;typename _Up&gt;
    //如果不符合 __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint中的约束条件
    //enable_if&lt;false&gt;不会取到type这个类型，类型替换失败
    using _DeleterConstraint =
        typename __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;

    //内涵一个_uniq_ptr_data来实现unique_ptr
    __uniq_ptr_data&lt;_Tp, _Dp&gt; _M_t;

  public:
    //简单的型别别名
    using pointer = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;
    using element_type = _Tp;   //被指向元素类型
    using deleter_type = _Dp;   //删除器类型

  private:
    // helper template for detecting a safe conversion from another unique_ptr
    //帮助模板推到是否是安全的转换从另一个unique_ptr
    template &lt;typename _Up, typename _Ep&gt;
    using __safe_conversion_up =
        //先推导两个unique_ptr的内部指针转换是否安全，再看_Up是否是一个数组(数组可以退化为指针,这样的转换是不安全的)
        //约束_Up不能是一个数组
        __and_&lt;is_convertible&lt;typename unique_ptr&lt;_Up, _Ep&gt;::pointer, pointer&gt;,
               __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;

  public:
    //关于unique_ptr的方法功能，可以看见已经有很好的说明了，所以这里我不再说明
    // Constructors.

    /// Default constructor, creates a unique_ptr that owns nothing.
    //模板约束再这里使用，因为这里的删除器约束条件是impl中的约束条件::type
    //相当于对std::enable_if取type
    //如果删除器是一个指针类型，或者没有默认构造函数，会编译失败
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr() noexcept : _M_t() &#123;&#125;


    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an object of @c element_type
     *
     * The deleter will be value-initialized.
     */
     //同上
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    explicit unique_ptr(pointer __p) noexcept : _M_t(__p) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an object of @c element_type
     * @param __d  A reference to a deleter.
     *
     * The deleter will be initialized with @p __d
     */
     //这里做的删除器类型约束为：需要能拷贝构造
    template &lt;typename _Del = deleter_type,
              typename = _Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(pointer __p, const deleter_type &amp;__d) noexcept
        : _M_t(__p, __d) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an object of @c element_type
     * @param __d  An rvalue reference to a (non-reference) deleter.
     *
     * The deleter will be initialized with @p std::move(__d)
     */
     //这里做的删除器类型约束为：需要能拷贝构造
    template &lt;typename _Del = deleter_type,
              typename = _Require&lt;is_move_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(
        pointer __p,
        //约束为不能是一个左值引用
        __enable_if_t&lt;!is_lvalue_reference&lt;_Del&gt;::value, _Del &amp;&amp;&gt; __d) noexcept
        : _M_t(__p, std::move(__d)) &#123;&#125;

    //删除器类型是左值引用，并且对于传入的删除器是一个右值，是不允许的所以  =delete
    template &lt;typename _Del = deleter_type,
              typename _DelUnref = typename remove_reference&lt;_Del&gt;::type&gt;
    unique_ptr(pointer,
               __enable_if_t&lt;is_lvalue_reference&lt;_Del&gt;::value, _DelUnref &amp;&amp;&gt;) =
        delete;

    //对于nullptr,也就是std::nullptr_t类型的构造函数例如unique_ptr&lt;Foo&gt; p(nullptr);
    /// Creates a unique_ptr that owns nothing.
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr(nullptr_t) noexcept : _M_t() &#123;&#125;


    /// Move constructor.
    //仅仅是=default
    unique_ptr(unique_ptr &amp;&amp;) = default;

    /** @brief Converting constructor from another type
     *
     * Requires that the pointer owned by @p __u is convertible to the
     * type of pointer owned by this object, @p __u does not own an array,
     * and @p __u has a compatible deleter type.
     */
     //正如注释所言，从一个unique_ptr构造一个unique_ptr,要求拥有的指针能够转换并且不是数组类型
     //并且要求__u的删除器能够兼容this的删除器
    template &lt;
        typename _Up, typename _Ep,
        typename = _Require&lt;
            __safe_conversion_up&lt;_Up, _Ep&gt;, //看看内部指针能不能安全转换
            typename conditional&lt;is_reference&lt;_Dp&gt;::value, 
                                 is_same&lt;_Ep, _Dp&gt;, //看看删除器是不是一个引用类型，是，需要相同类型
                                 is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt; //不是需要_Ep(__u的删除器类型)能够转换为_Dp
    unique_ptr(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept
        : _M_t(__u.release(), std::forward&lt;_Ep&gt;(__u.get_deleter())) &#123;&#125;

#if _GLIBCXX_USE_DEPRECATED
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;
    /// Converting constructor from @c auto_ptr
    //因为auto_ptr是废弃的特性，所以这个函数不说明了，有兴趣的话读者可以自己分析一下
    template &lt;typename _Up,
              typename = _Require&lt;is_convertible&lt;_Up *, _Tp *&gt;,
                                  is_same&lt;_Dp, default_delete&lt;_Tp&gt;&gt;&gt;&gt;
    unique_ptr(auto_ptr&lt;_Up&gt; &amp;&amp;__u) noexcept;
#pragma GCC diagnostic pop
#endif

    /// Destructor, invokes the deleter if the stored pointer is not null.
    ~unique_ptr() noexcept &#123;
      //如果删除器不是可调用的，会断言失败
      //__is_invocable具体的实现，这里不说明
      static_assert(__is_invocable&lt;deleter_type &amp;, pointer&gt;::value,
                    &quot;unique_ptr&#39;s deleter must be invocable with a pointer&quot;);
      auto &amp;__ptr = _M_t._M_ptr(); //先缓存指针
      if (__ptr != nullptr)        //如果不是空，使用删除器删除
        get_deleter()(std::move(__ptr)); 
      __ptr = pointer();   
    &#125;

    // Assignment.

    /** @brief Move assignment operator.
     *
     * Invokes the deleter if this object owns a pointer.
     */
     //同样的，简单是使用default
    unique_ptr &amp;operator=(unique_ptr &amp;&amp;) = default;

    /** @brief Assignment from another type.
     *
     * @param __u  The object to transfer ownership from, which owns a
     *             convertible pointer to a non-array object.
     *
     * Invokes the deleter if this object owns a pointer.
     */
     //涉及到类型的转换，这个问题上面已经看到过了
     //可以类似的如法炮制
    template &lt;typename _Up, typename _Ep&gt;
    typename enable_if&lt;__and_&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,
                              is_assignable&lt;deleter_type &amp;, _Ep &amp;&amp;&gt;&gt;::value,
                       unique_ptr &amp;&gt;::type
    operator=(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept &#123;
      reset(__u.release());
      get_deleter() = std::forward&lt;_Ep&gt;(__u.get_deleter());
      return *this;
    &#125;

    /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
    //对于nullptr_t的赋值操作
    unique_ptr &amp;operator=(nullptr_t) noexcept &#123;
      reset();
      return *this;
    &#125;

    // Observers.

    /// Dereference the stored pointer.
    //对element_type添加一个左值引用
    //在type_traits中定义的add_lvalue_reference的实现细节，在这里并不想多说
    //我可以负责任的告诉你,add_lvalue_reference会对T, T&amp;&amp;变为T &amp;,对T &amp; 不变
    typename add_lvalue_reference&lt;element_type&gt;::type operator*() const &#123;
      __glibcxx_assert(get() != pointer());
      return *get();
    &#125;

    /// Return the stored pointer.
    //-&gt;运算符，不用多说，看一下就懂
    pointer operator-&gt;() const noexcept &#123;
      _GLIBCXX_DEBUG_PEDASSERT(get() != pointer());
      return get();
    &#125;

    /// Return the stored pointer.
    pointer get() const noexcept &#123; return _M_t._M_ptr(); &#125;

    /// Return a reference to the stored deleter.
    deleter_type &amp;get_deleter() noexcept &#123; return _M_t._M_deleter(); &#125;

    /// Return a reference to the stored deleter.
    const deleter_type &amp;get_deleter() const noexcept &#123;
      return _M_t._M_deleter();
    &#125;

    //隐式转换为bool，可以用在这种场景，例如
    //unique_ptr&lt;Foo&gt; a;
    //if(a) &#123;...&#125;
    /// Return @c true if the stored pointer is not null.
    explicit operator bool() const noexcept &#123;
      return get() == pointer() ? false : true;
    &#125;

    // Modifiers.

    /// Release ownership of any stored pointer.
    pointer release() noexcept &#123; return _M_t.release(); &#125;

    /** @brief Replace the stored pointer.
     *
     * @param __p  The new pointer to store.
     *
     * The deleter will be invoked if a pointer is already owned.
     */
    void reset(pointer __p = pointer()) noexcept &#123;
      static_assert(__is_invocable&lt;deleter_type &amp;, pointer&gt;::value,
                    &quot;unique_ptr&#39;s deleter must be invocable with a pointer&quot;);
      _M_t.reset(std::move(__p));
    &#125;

    /// Exchange the pointer and deleter with another object.
    void swap(unique_ptr &amp;__u) noexcept &#123;
        //断言检查删除器是否右可交换的能力
      static_assert(__is_swappable&lt;_Dp&gt;::value, &quot;deleter must be swappable&quot;);
      //调用_M_t的swap，实际上是__uniq_ptr_impl中的swap
      _M_t.swap(__u._M_t);
    &#125;

    // Disable copy from lvalue.
    //拷贝构造和赋值运算符是删除的
    unique_ptr(const unique_ptr &amp;) = delete;
    unique_ptr &amp;operator=(const unique_ptr &amp;) = delete;
  &#125;;
</code></pre>
<p>对于非数组版本的unique_ptr我们已经分析完成了，下面是对于数组版本的特例化</p>
<p>相对于非数组版本，数组版本主要修改了</p>
<ul>
<li>默认删除器做delete[]动作</li>
<li>重载[]</li>
</ul>
<pre><code class="C++">  /// 20.7.1.3 unique_ptr for array objects with a runtime length
  // [unique.ptr.runtime]
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 740 - omit specialization for array objects with a compile time length
  // 对编译时期能确定长度的数组特例化
  // 对于已经说过的问题，就不再写注释了，请读者自己注意
  template &lt;typename _Tp, typename _Dp&gt; class unique_ptr&lt;_Tp[], _Dp&gt; &#123;
    template &lt;typename _Up&gt;
    using _DeleterConstraint =
        typename __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;

    __uniq_ptr_data&lt;_Tp, _Dp&gt; _M_t;

    //就像remove_cv_t
    template &lt;typename _Up&gt; using __remove_cv = typename remove_cv&lt;_Up&gt;::type;

    // like is_base_of&lt;_Tp, _Up&gt; but false if unqualified types are the same
    // 从实现中和注释中就可以看出，需要判断Up是否是Tp的派生类
    template &lt;typename _Up&gt;
    using __is_derived_Tp =
        __and_&lt;is_base_of&lt;_Tp, _Up&gt;,
               __not_&lt;is_same&lt;__remove_cv&lt;_Tp&gt;, __remove_cv&lt;_Up&gt;&gt;&gt;&gt;;

  public:
    using pointer = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;
    using element_type = _Tp;
    using deleter_type = _Dp;

    // helper template for detecting a safe conversion from another
    // unique_ptr
    //辅助模板来帮助实现从另一个unique_ptr转换是否安全
    //安全转换的条件是：
    //是一个数组
    //poniter和element_type*是同一类型
    //另一个unique_ptr::pointer和::element_type*是同一个类型
    //另一个unique_ptr::element_type(*)[]可以转换为当前的unique_ptr::element_type(*)[]
    //至于为什么要这样设计，还是和用多态方式处理数组有关，下面会说到
    template &lt;typename _Up, typename _Ep, typename _UPtr = unique_ptr&lt;_Up, _Ep&gt;,
              typename _UP_pointer = typename _UPtr::pointer,
              typename _UP_element_type = typename _UPtr::element_type&gt;
    using __safe_conversion_up =
        __and_&lt;is_array&lt;_Up&gt;, is_same&lt;pointer, element_type *&gt;,
               is_same&lt;_UP_pointer, _UP_element_type *&gt;,
               is_convertible&lt;_UP_element_type (*)[], element_type (*)[]&gt;&gt;;

    // helper template for detecting a safe conversion from a raw pointer
    // 辅助模板从裸指针转换为当前的unique_ptr::pointer
    //这段代码实在是太难以阅读了，为了方便，我们进行一些格式上的改变
    // template &lt;typename _Up&gt;
    // using __safe_conversion_raw = __and_&lt;
    //     __or_&lt;__or_&lt;is_same&lt;_Up, pointer&gt;, is_same&lt;_Up, nullptr_t&gt;&gt;,
    //           __and_&lt;is_pointer&lt;_Up&gt;, is_same&lt;pointer, element_type *&gt;,
    //                  is_convertible&lt;typename remove_pointer&lt;_Up&gt;::type (*)[],
    //                                 element_type (*)[]&gt;&gt;&gt;&gt;;
    //满足转换规则只需要满足其中以下条件之一(Up是一个raw-pointer)
    //- Up和pointer是同类型或者Up和nullptr_t是同类型
    //- Up是一个指针并且pointer和element_type*是同一类型并且Up移除指针后的类型的数组指针可以转换为element_type的数组指针
    template&lt;typename Up&gt;

    using _safe_conversion_raw = __and_&lt;
            __or_&lt;
                    __or_&lt;is_same&lt;Up, pointer&gt;, is_same&lt;Up, nullptr_t&gt; &gt;,
                    __and_&lt;
                            is_pointer&lt;Up&gt;, is_same&lt;pointer, element_type *&gt;,
                            is_convertible&lt;typename remove_pointer&lt;Up&gt;::type (*)[], element_type (*)[]&gt;
                          &gt;
                 &gt;
    &gt;;
    // Constructors.

    /// Default constructor, creates a unique_ptr that owns nothing.
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr() noexcept : _M_t() &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an array of a type safely convertible
     * to an array of @c element_type
     *
     * The deleter will be value-initialized.
     */
    template &lt;
        typename _Up, typename _Vp = _Dp, typename = _DeleterConstraint&lt;_Vp&gt;,
        typename =
            typename enable_if&lt;__safe_conversion_raw&lt;_Up&gt;::value, bool&gt;::type&gt; //做了一个类型约束
    explicit unique_ptr(_Up __p) noexcept : _M_t(__p) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an array of a type safely convertible
     * to an array of @c element_type
     * @param __d  A reference to a deleter.
     *
     * The deleter will be initialized with @p __d
     */
     //从一个raw-pointer和一个删除器构造一个uniuqe_ptr
     //很明显的需要raw-pointer可以安全的转换为unique_ptr并且删除器是可以拷贝狗仔的
    template &lt;typename _Up, typename _Del = deleter_type,
              typename = _Require&lt;__safe_conversion_raw&lt;_Up&gt;, //只是类型约束和非数组版的不一样
                                  is_copy_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(_Up __p, const deleter_type &amp;__d) noexcept : _M_t(__p, __d) &#123;&#125;

    /** Takes ownership of a pointer.
     *
     * @param __p  A pointer to an array of a type safely convertible
     * to an array of @c element_type
     * @param __d  A reference to a deleter.
     *
     * The deleter will be initialized with @p std::move(__d)
     */
    template &lt;typename _Up, typename _Del = deleter_type,
              typename = _Require&lt;__safe_conversion_raw&lt;_Up&gt;,
                                  is_move_constructible&lt;_Del&gt;&gt;&gt;
    unique_ptr(
        _Up __p,
        __enable_if_t&lt;!is_lvalue_reference&lt;_Del&gt;::value, _Del &amp;&amp;&gt; __d) noexcept
        : _M_t(std::move(__p), std::move(__d)) &#123;&#125;

    template &lt;typename _Up, typename _Del = deleter_type,
              typename _DelUnref = typename remove_reference&lt;_Del&gt;::type,
              typename = _Require&lt;__safe_conversion_raw&lt;_Up&gt;&gt;&gt;
    unique_ptr(_Up,
               __enable_if_t&lt;is_lvalue_reference&lt;_Del&gt;::value, _DelUnref &amp;&amp;&gt;) =
        delete;

    /// Move constructor.
    unique_ptr(unique_ptr &amp;&amp;) = default;

    /// Creates a unique_ptr that owns nothing.
    template &lt;typename _Del = _Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt;
    constexpr unique_ptr(nullptr_t) noexcept : _M_t() &#123;&#125;

    template &lt;
        typename _Up, typename _Ep,
        typename = _Require&lt;
            __safe_conversion_up&lt;_Up, _Ep&gt;,
            typename conditional&lt;is_reference&lt;_Dp&gt;::value, is_same&lt;_Ep, _Dp&gt;,
                                 is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;
    unique_ptr(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept
        : _M_t(__u.release(), std::forward&lt;_Ep&gt;(__u.get_deleter())) &#123;&#125;

    /// Destructor, invokes the deleter if the stored pointer is not null.
    ~unique_ptr() &#123;
      auto &amp;__ptr = _M_t._M_ptr();
      if (__ptr != nullptr)
        get_deleter()(__ptr);
      __ptr = pointer();
    &#125;

    // Assignment.

    /** @brief Move assignment operator.
     *
     * Invokes the deleter if this object owns a pointer.
     */
    unique_ptr &amp;operator=(unique_ptr &amp;&amp;) = default;

    /** @brief Assignment from another type.
     *
     * @param __u  The object to transfer ownership from, which owns a
     *             convertible pointer to an array object.
     *
     * Invokes the deleter if this object owns a pointer.
     */
    template &lt;typename _Up, typename _Ep&gt;
    typename enable_if&lt;__and_&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,
                              is_assignable&lt;deleter_type &amp;, _Ep &amp;&amp;&gt;&gt;::value,
                       unique_ptr &amp;&gt;::type
    operator=(unique_ptr&lt;_Up, _Ep&gt; &amp;&amp;__u) noexcept &#123;
      reset(__u.release());
      get_deleter() = std::forward&lt;_Ep&gt;(__u.get_deleter());
      return *this;
    &#125;

    /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
    unique_ptr &amp;operator=(nullptr_t) noexcept &#123;
      reset();
      return *this;
    &#125;

    // Observers.
    // 重载的[]，实现也是非常简单
    /// Access an element of owned array.
    typename std::add_lvalue_reference&lt;element_type&gt;::type
    operator[](size_t __i) const &#123;
      __glibcxx_assert(get() != pointer());
      return get()[__i];
    &#125;

    /// Return the stored pointer.
    pointer get() const noexcept &#123; return _M_t._M_ptr(); &#125;

    /// Return a reference to the stored deleter.
    deleter_type &amp;get_deleter() noexcept &#123; return _M_t._M_deleter(); &#125;

    /// Return a reference to the stored deleter.
    const deleter_type &amp;get_deleter() const noexcept &#123;
      return _M_t._M_deleter();
    &#125;

    /// Return @c true if the stored pointer is not null.
    explicit operator bool() const noexcept &#123;
      return get() == pointer() ? false : true;
    &#125;

    // Modifiers.

    /// Release ownership of any stored pointer.
    pointer release() noexcept &#123; return _M_t.release(); &#125;

    /** @brief Replace the stored pointer.
     *
     * @param __p  The new pointer to store.
     *
     * The deleter will be invoked if a pointer is already owned.
     */
    template &lt;
        typename _Up,
        typename = _Require&lt;__or_&lt;
            is_same&lt;_Up, pointer&gt;,
            __and_&lt;is_same&lt;pointer, element_type *&gt;, is_pointer&lt;_Up&gt;,
                   is_convertible&lt;typename remove_pointer&lt;_Up&gt;::type (*)[],
                                  element_type (*)[]&gt;&gt;&gt;&gt;&gt;
    void reset(_Up __p) noexcept &#123;
      _M_t.reset(std::move(__p));
    &#125;

    void reset(nullptr_t = nullptr) noexcept &#123; reset(pointer()); &#125;

    /// Exchange the pointer and deleter with another object.
    void swap(unique_ptr &amp;__u) noexcept &#123;
      static_assert(__is_swappable&lt;_Dp&gt;::value, &quot;deleter must be swappable&quot;);
      _M_t.swap(__u._M_t);
    &#125;

    // Disable copy from lvalue.
    unique_ptr(const unique_ptr &amp;) = delete;
    unique_ptr &amp;operator=(const unique_ptr &amp;) = delete;
  &#125;;
</code></pre>
<h2 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h2><p>令人头大的部分终于过去了，占据了本文章绝大篇幅的那些部分。接下来放松一下，看一看<code>std::make_unique</code>的实现吧</p>
<pre><code>在这里仅仅分析14的部分(make_unique是14增添的)，对于14以上的代码，读者有兴趣可以自行了解
</code></pre>
<h3 id="MakeUniq"><a href="#MakeUniq" class="headerlink" title="_MakeUniq"></a>_MakeUniq</h3><p>做的功能就是类型萃取，用作于make_unique的返回值，这样做的目的也是为了实现类型安全</p>
<p>类型参数应为T的地方写成T[]会导致类型替换失败，反之亦然</p>
<pre><code class="C++">  template&lt;typename _Tp&gt;
    struct _MakeUniq
    &#123; typedef unique_ptr&lt;_Tp&gt; __single_object; &#125;;

  template&lt;typename _Tp&gt;
    struct _MakeUniq&lt;_Tp[]&gt;
    &#123; typedef unique_ptr&lt;_Tp[]&gt; __array; &#125;;

  template&lt;typename _Tp, size_t _Bound&gt;
    struct _MakeUniq&lt;_Tp[_Bound]&gt;
    &#123; struct __invalid_type &#123; &#125;; &#125;;
</code></pre>
<p>make_unique的实现部分</p>
<pre><code class="C++">  /// std::make_unique for single objects
  // 非数组版本
  template&lt;typename _Tp, typename... _Args&gt;
    inline typename _MakeUniq&lt;_Tp&gt;::__single_object
    make_unique(_Args&amp;&amp;... __args) //&amp;&amp; ... +forward 的形式转发参数
    &#123; return unique_ptr&lt;_Tp&gt;(new _Tp(std::forward&lt;_Args&gt;(__args)...)); &#125;

  /// std::make_unique for arrays of unknown bound
  //返回一个unique_ptr指向一个长度为__num的数组
  //关于remove_extent_t,请参考https://www.apiref.com/cpp-zh/cpp/types/remove_extent.html
  template&lt;typename _Tp&gt;
    inline typename _MakeUniq&lt;_Tp&gt;::__array
    make_unique(size_t __num)
    &#123; return unique_ptr&lt;_Tp&gt;(new remove_extent_t&lt;_Tp&gt;[__num]()); &#125;
  
  //不能从一个已知界限的数组返回一个unique_ptr
  /// Disable std::make_unique for arrays of known bound
  template&lt;typename _Tp, typename... _Args&gt;
    typename _MakeUniq&lt;_Tp&gt;::__invalid_type
    make_unique(_Args&amp;&amp;...) = delete;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>unique_ptr的源码分析，就告一段落了。还有很多很多细节和实现手法没有剖析，剖析了的细节和实现手法，一些也没有说明为什么要这样做。</p>
<p>如果日后发现的错误，会在这里更新勘误表。</p>
<p>如果你有任何的问题，可以通过邮箱，QQ来联系到我。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00a596">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C-Library/" style="color: #00bcd4">
                C++ Library
            </a>
        </span>
        
    </div>
    <a href="/2022/09/22/unique-ptr源码解析/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/万能引用和重载中的问题以及解决方案/">
        <h2 class="post-title">万能引用和重载中的问题以及解决方案</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="使用万能引用来通用式的处理左值右值排列组合的情况"><a href="#使用万能引用来通用式的处理左值右值排列组合的情况" class="headerlink" title="使用万能引用来通用式的处理左值右值排列组合的情况"></a>使用万能引用来通用式的处理左值右值排列组合的情况</h1><p>我曾经在一次开发中遇到过这样的问题，我有一个User class，他里面有string：id, name, passward，以及其他内置类型.如果是在C++11之前，写出一个好的构造函数应当是很容易的，但是C++11之后，有了移动语义，写出一个完美的构造函数确实不容易。</p>
<p>这样想，我想尽可能的利用好移动语义，假设我们的name等等成员不是一个短字符串，这时候移动语义对性能会有优化。现在又3个string类型的成员，考虑到每个成员的左值和右值，有8种构造函数的写法(不算默认构造)。要是这种可以进行移动的成员再多几个呢——这是一个指数级增长的趋势。这种写法显然是不行的。那就用模板——还要是万能模板。可以初步设计出这样的构造函数。</p>
<pre><code class="C++">class User &#123;
public:
    template &lt;typename T&gt;
    User(T &amp;&amp; _name, T &amp;&amp; _id, T &amp;&amp; _password) :
        name(forward&lt;T&gt;(_name), forward&lt;T&gt;(_id),forward&lt;T&gt;(_password)) &#123; &#125;
&#125;
</code></pre>
<p>这样哪个无论什么样的组合，我们均可用一个函数来完成。而且对于其他有移动语义的类型来书，再加上一个F &amp;&amp;即可，这是线性增加的，还算不错。</p>
<h1 id="万能引用和重载会互相冲突"><a href="#万能引用和重载会互相冲突" class="headerlink" title="万能引用和重载会互相冲突"></a>万能引用和重载会互相冲突</h1><p>当形参只有一个的时候，会有些微妙的变化。</p>
<p>现在假设User中只有一个string类型的name，如果你依旧考虑像上面一样实现构造函数，会有一些隐晦的错误。</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    User(T &amp;&amp; _name): name(std::forward&lt;T&gt;(_name)) &#123; &#125;
private:
    string name;
&#125;;


int main()
&#123;
    User user(&quot;hello&quot;); //很好，这个甚至是直接再类中用const char * 直接构造了一个字符串
    User user1(user);       // error
    return 0;
&#125;
</code></pre>
<p>编译器会给出我们这样的一个错误</p>
<blockquote>
<p>No matching constructor for initialization of ‘std::string’ (aka ‘basic_string<char>‘)</p>
</blockquote>
<p>编译器说无法匹配string的构造函数，莫名奇妙有些。<br>实际上，编译器给出的错误一点问题也没有。</p>
<p>我们先来回复一个拷贝构造的函数原型 <code>User(const User &amp; user)</code><br>我们传递的user不具有const性质，而模板会生成一个non-const的形参，看起来像这样<code>User(User &amp; _name): name(_name)</code>(此处省略forward,下同)，编译器觉得这个non-const的版本更加匹配，随后使用一个User对象来构造string，那肯定是不行的。<br>如果我们的user具有const性质，编译器就不会报错。</p>
<pre><code class="C++">int main()
&#123;
    const User user(&quot;hello&quot;); 
    User user1(user);       // 工作的很好
    return 0;
&#125;
</code></pre>
<p>这种和直觉上不服的行为肯定不是我们想要的，如果你留意编译器的警告，或者说是clang-tidy的静态分析，你会看见这样的警告</p>
<blockquote>
<p>Clang-Tidy: Constructor accepting a forwarding reference can hide the copy and move constructors</p>
<p>Clang-Tidy：接受转发引用的构造函数可以隐藏复制和移动构造函数</p>
</blockquote>
<p>还有这样的情况，假设我们只需要构造一个int类型的数据成员，其他的数据成员都调用默认构造。</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(T &amp;&amp; _name): name(std::forward&lt;T&gt;(_name)) &#123;
        cout &lt;&lt; &quot;T&amp;&amp;&quot; &lt;&lt; endl;
    &#125;
    explicit User(int _age): age(_age), name() &#123; &#125;
private:
    string name;
    int age;
&#125;;
int main()
&#123;
    User user(25);
    //...假设这里经过算法的计算，得出的一个double类型来当作age， 我们也期望这种隐式转换double -&gt; int(即向下取整)
    double ans = 18.63;
    User user1(ans)
    return 0;
&#125;
</code></pre>
<p>不好了，编译器又给出了错误！</p>
<p>原因是万能引用为我们实例化了一个<code>User (double &amp; _name): name(_name)</code>,精确度高于手写的int版本的构造函数——用一个double构造一个string，当然是不行的了。</p>
<p>类似的成员函数应用万能模板也有这样的重载问题。</p>
<h2 id="在继承体系中，这个问题也会出现，甚至更加错综复杂"><a href="#在继承体系中，这个问题也会出现，甚至更加错综复杂" class="headerlink" title="在继承体系中，这个问题也会出现，甚至更加错综复杂"></a>在继承体系中，这个问题也会出现，甚至更加错综复杂</h2><p>现在Reader继承User</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(T &amp;&amp; _name): name(std::forward&lt;T&gt;(_name)) &#123;
        cout &lt;&lt; &quot;T&amp;&amp;&quot; &lt;&lt; endl;
    &#125;
    explicit User(int _age): age(_age), name() &#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age;
&#125;;

class Reader : public User &#123;
public:
    Reader(const Reader &amp; reader) :
            User(reader), phone_number(reader.phone_number) &#123; &#125;
private:
    string phone_number;
&#125;;
</code></pre>
<p>编译器依旧还是这个错误</p>
<blockquote>
<p>No matching constructor for initialization of ‘std::string’ (aka ‘basic_string<char>‘)</p>
</blockquote>
<p>原因是Reader &amp; cast -&gt; User &amp; 是一种隐式转换。</p>
<p>万能引用又出来作怪，生成这样的版本<code>User(Reader &amp; _name): name(_name))</code></p>
<p>显然，这个版本更加精确，使用Reader &amp; 构造 string当然不行。</p>
<p>《Modern Effective C++》,对些情况是这样总结的</p>
<ul>
<li>把万能引用作为候选重载型别，几乎总会让该重载版本在始料未及的情况下被调用</li>
<li>完美转发构造函数的问题尤为严重，因为对于非常量的左值型别而言，他们一般都会形成相对于复制构造函数的更加匹配，并且还会劫持派生类中对基类的复制和构造函数的调用。</li>
</ul>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决这个问题的方法还是有很多的，我们可以权衡利弊的来考虑。</p>
<h2 id="退而求其次"><a href="#退而求其次" class="headerlink" title="退而求其次"></a>退而求其次</h2><p>不是谁都有精力去学习复杂的Modern C++(这里大部分的意思是关于TMP)，使用一些简单的新特性也是不错的。我们可以完全不用万能引用，因为相比代码可读性极具下降而带来不稳定的性能提升，如果你不是一个完美主义者，代码可读性应当是应该的选择。</p>
<h3 id="舍弃重载"><a href="#舍弃重载" class="headerlink" title="舍弃重载"></a><strong>舍弃重载</strong></h3><p>大可像Rust那样，舍弃重载，也是解决办法之一，但是由于语法问题，构造函数时语言固有的，或许你也可以麻烦一点，用static函数实现？就使用默认构造，然后一一修改值——这样效率反而低了，舍本逐末不可取。总之，舍弃重载可以暂时的解决问题，但不是一个长久之计。</p>
<h3 id="传递const-T-amp"><a href="#传递const-T-amp" class="headerlink" title="传递const T &amp;"></a>传递const T &amp;</h3><p>这就是98时候的写法了，经典永不过时，这种写法简洁又不失高性能，并且不会又其他的问题出现，这种方式大家应当都很熟悉，还是很值得考虑的。</p>
<h2 id="使用现代方法"><a href="#使用现代方法" class="headerlink" title="使用现代方法"></a><strong>使用现代方法</strong></h2><p>如果你选择了使用现代方法解决此问题，就代表了你踏进了Modern C++的大门，不仅仅是关于&amp;&amp;和&amp;的语法游戏，你必须具有TMP(模板元编程的基础),才可以游刃有余的写出奇妙的Modern C++代码，如果你还不具备这项技能，又想使用高级手法来解决问题，那你应当做好准备迎接一轮又一轮的新特性学习。</p>
<blockquote>
<p>题外话：我把Modern C++代码说做是“奇妙的”，而不是“精美的”、“简洁的”这类词是有原因的，一个基本的事实，Modern C++代码并不简洁，甚至是丑陋和复杂，但这些复杂的代码背后的工作原理，了解之后没有人不会惊叹，不会大呼奇妙。</p>
</blockquote>
<h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a><strong>传值</strong></h3><p>可以使用值传递+移动构造的方式来代替万能引用和转发。如果对象的移动语义有较低的成本使用 pass by value and use std::move也是一个比较好的选择。</p>
<p>比如说像这样</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(string _name): name(std::move(_name)) &#123;
    &#125;
    explicit User(int _age): age(_age), name() &#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>但是这个选择不够通用，如果对象没有移动语义，或者是POD类型，这样做性能反而会下降。你可以阅读这个文章<a target="_blank" rel="noopener" href="https://jan6055.github.io/2022/09/17/pass-by-value-and-use-std-move/">https://jan6055.github.io/2022/09/17/pass-by-value-and-use-std-move/</a> 来了解相关信息。</p>
<h3 id="标签分派"><a href="#标签分派" class="headerlink" title="标签分派"></a><strong>标签分派</strong></h3><p>如果你看过一些STL的源代码，可能会熟悉这种方式，大致的思路是这样的，我们把构造函数委派给其他函数，这些函数做具体的实现，并且他们有不同的重载版本，分别接受构造所需要的参数和一个名为true_type&#x2F;false_type类型的对象</p>
<blockquote>
<p>true_type和false_type由标准库提供，仅仅是定义，并未添加任何数据和行为， 实现标签的效果。</p>
</blockquote>
<p>判断T是不是整形，我们可以使用<code>std::is_integral</code>，但是考虑左值的情况，T被推断为int &amp;，我们应当先把引用性质给移除，可以使用<code>std::remove_reference</code>得出的代码就是这样<code>std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;()</code>, 我们使用的_t后缀的模板（TMP中叫做元函数）来直接获得类型——这是C++14支持的，但是，别忘了使用<code>()</code>来生成一个对象，才可用于重载。</p>
<p>具体的实现如下</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T&gt;
    explicit User(T &amp;&amp; arg) &#123;
        init(std::forward&lt;T&gt;(arg),
        typename std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;()
        );
    &#125;

    template&lt;typename T&gt;
    void init(T &amp;&amp; _name, false_type) &#123;
        name = std::forward&lt;T&gt;(_name);  //这里是赋值操作，如果使用这样的手法对于构造函数而言，就只能这样
        age = 0;
    &#125;
    void init(int _age, true_type) &#123;
        //name会隐式的初始化
        age = _age;
    &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>这确实够复杂，先别放松，更复杂的还在后面！</p>
<h3 id="使用TMP对万能模板做出限制"><a href="#使用TMP对万能模板做出限制" class="headerlink" title="使用TMP对万能模板做出限制"></a><strong>使用TMP对万能模板做出限制</strong></h3><p>先说明一点，你应当了解TMP并且熟悉其最基本构成，还应当知道SFINAE，如果你不知道，快去找相关书籍看吧，如果我把这里展开说明，并且把用到的TMP技巧细节全部说一遍，那就偏离主题了。并且，我也没有足够的能力讲清TMP中的所有细节和问题，这件事情你应当请教C++标准委员会(bushi</p>
<p>我们可以让万能引用拒绝User类的对象，也拒绝int类的对象。在现代C++中，这是可以实现的——你甚至能在98里实现，但是需要点技巧。</p>
<p>使用enable_if来让编译器类型替换失败，也就是SFINAE, 但是我们应当考虑到左值的情况T , T&amp;并不是一种类型，比如int, int&amp;, 还有<code>const T, volatile T, const volatileT</code> 这些和T均不是一种类型。可以使std::decay来去掉cvr性质。</p>
<p>具体的实现是这样</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T,
             typename = typename std::enable_if&lt;!std::is_same&lt;User,std::decay_t&lt;T&gt;&gt;::value &amp;&amp;
                                                !std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;::value
                                               &gt;::type&gt;
    explicit User(T &amp;&amp; _name) : name(std::forward&lt;T&gt;(_name)) &#123; &#125;
    explicit User(int _age) : age(_age), name()&#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>这样实现还真是复杂，如果没有C++14<code>_t</code>的元函数，那么将会更加复杂，感谢C++14!<br>大功告成了吗，并没有。对于继承关系来说，还是存在问题。如果子类中调用基类的构造函数，就是我们讨论过的哪个问题。在实例化的时候，在经过类型退化后，T被推断为Reader，这就又回到了我们之前所说的问题。</p>
<p>好在STL中提供了<code>is_base_of</code>这个元函数，能够判断一个类型是否是另一个类型的基类,<code>is_base_of&lt;T,T&gt;::value = ture</code></p>
<p>于是我们可以简单的修改一下代码。</p>
<pre><code class="C++">class User &#123;
public:
    template&lt;typename T,
             typename = typename std::enable_if&lt;!std::is_base_of&lt;User,std::decay_t&lt;T&gt;&gt;::value &amp;&amp;
                                                !std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;::value
                                               &gt;::type&gt;
    explicit User(T &amp;&amp; _name) : name(std::forward&lt;T&gt;(_name)) &#123; &#125;
    explicit User(int _age) : age(_age), name()&#123; &#125;
    User(const User &amp; user) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;

class Reader : public User &#123;
public:
    Reader(const Reader &amp; reader) :
            User(reader), phone_number(reader.phone_number) &#123; &#125;
private:
    string phone_number;
&#125;;
</code></pre>
<p>问题迎刃而解！你现在是否感叹Modern C++的巧妙了呢？</p>
<h1 id="万能模板的不足"><a href="#万能模板的不足" class="headerlink" title="万能模板的不足"></a>万能模板的不足</h1><p>你会说，能有什么不足呢？这么高级的技巧，多么的神奇。实际上，万能引用的强大如此，不足也是如此。回头看看经典版本</p>
<pre><code class="C++">class User &#123;
public:
    explicit User(const string &amp; _name): name(_name) &#123; &#125;
    explicit User(int _age) : age(_age), name() &#123; &#125;
    User(const User &amp;) = default;
private:
    string name;
    int age&#123;&#125;;
&#125;;
</code></pre>
<p>正所谓洗去铅华只剩金，实现了同样的功能，难道我们要为性能舍弃掉如此的可读性和简洁性吗。同样的，如果是团队合作，小伙伴们可都不一定会这样的高级技巧。到头来还要你自己维护。如果没有注释，等个几天——你就不知道自己写的是什么啦，真是太棒了！</p>
<p>使用模板的一个不可避免的问题就是当错误发生时，不好定位。你应该有没有按照规范使用过STL容器的经历，看见了编译器给你报告的错误。很吓人，如果没有经验的人看到这些错误（可能有几百行甚至几千行）。该怎么定位问题。虽然我们可以使用<code>statci_assert</code>来未雨绸缪。但也不是所有的时候情况都很客观。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，要不要使用如此晦涩复杂的特性，还是取决于程序员本身，你也可以使用const &amp;快快乐乐的写代码，正因为</p>
<blockquote>
<p>你没有用到的东西，不应当给你增添任何负担，你用到的东西，没有什么比C++提供的更好了</p>
</blockquote>
<p>使用Modern C++也是你自己的选择，除非写库，很少有人能用到模板开发，真正把这些Modern C++特性用到生产环境的，并且用好的，我想都是在C++领域发光发热的大牛们吧。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00bcd4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/TMP/" style="color: #03a9f4">
                TMP
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/万能引用和重载中的问题以及解决方案/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/17/ROV/">
        <h2 class="post-title">ROV</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h1><p>我们有这样的一段代码</p>
<pre><code class="C++">X getX() &#123;
    X x;
    //...
    return x;
&#125;
</code></pre>
<p>你可能会说，w在返回的时候需要进行拷贝一次。如果你还抱有这种想法，你应该拥向现代C++的怀抱了，现在的标准规定，针对这种情况以及类似的情况，编译器应当做返回值优化(return value optimmization)。使得调用getWidget就像直接在调用处构造了一个对象，而不用经过一次复制。</p>
<h1 id="C-标准对于返回值的优化"><a href="#C-标准对于返回值的优化" class="headerlink" title="C++标准对于返回值的优化"></a>C++标准对于返回值的优化</h1><blockquote>
<p>此处参考C++标准库中文第二版 P22-P23</p>
</blockquote>
<p>C++标准指出，对于以上的代码，有着这样的保证。</p>
<ul>
<li>如果X有一个可取的copy&#x2F;move构造函数，编译器可以选择忽略其中的copy版本。</li>
<li>否则，如果X有一个move构造函数，X就被moved</li>
<li>否则，如果X有一个copy构造函数，X就被copied</li>
<li>否则，报告出一个编译器错误</li>
</ul>
<p>我们需要对上述的规则一一解释<br>按照惯例，我们依旧需要准备一个测试所用的类</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
struct Foo &#123;
    int a = 0;
    double b = 0;
    string c;
    Foo() = default;
    Foo(int _a, double _b, const string &amp; _c) : a(_a), b(_b), c(_c) &#123; &#125;
    Foo(const Foo &amp; foo) : a(foo.a), b(foo.b), c(foo.c) &#123;
        cout &lt;&lt;  &quot;call &amp;&quot; &lt;&lt; endl;
    &#125;
    Foo(Foo &amp;&amp; foo)  noexcept : a(foo.a), b(foo.b), c(std::move(foo.c))  &#123;
        cout &lt;&lt; &quot;call &amp;&amp;&quot; &lt;&lt; endl;
    &#125;

&#125;;

Foo getFoo_1(int a = 0, double b = 0, const string &amp; c = &#123; &#125;) &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret(a,b,c);
    return ret;
&#125;
Foo getFoo_2(int a = 0, double b = 0, const string &amp; c = &#123; &#125;) &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret(a,b,c);
    return std::move(ret);
&#125;
Foo getFoo_3() &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret;
    ret.a = 10;
    ret.a *= 20;
    return ret;
&#125;
Foo getFoo_4() &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo ret;
    Foo &amp; r_ret = ret;
    return r_ret;
&#125;

Foo getFoo_5() &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    static Foo ret;
    return ret;
&#125;
void work(const Foo &amp; foo) &#123;
&#125;
int main()
&#123;
    work(getFoo_1(0,0,&quot;hello&quot;));
    work(getFoo_2());
    work(getFoo_3());
    work(getFoo_4());
    work(getFoo_5());
    return 0;
&#125;
</code></pre>
<p>测试的结果如下</p>
<pre><code>+++++   //RVO
+++++   
call &amp;&amp; //我们的自作聪明，组织了编译器的优化，因为move将对象变为&amp;&amp;，则moved
+++++   //RVO
+++++   
call &amp;  //这里我们返回了一个引用，编译器不再进行RVO而是copide
+++++   
call &amp;  //返回了一个static变量，move是不可行的，因此copide
</code></pre>
<h1 id="测试结果的思考"><a href="#测试结果的思考" class="headerlink" title="测试结果的思考"></a>测试结果的思考</h1><p>不难看出，编译器在很多的情况下都会为我们做返回值优化，即使我们在工厂函数中进行了一些额外的操作。</p>
<p>我们自作聪明的move操作，反而会阻止编译器的RVO，如果对象的移动语义成本不低，我们会聪明反被聪明误。</p>
<p>对于那些不可避免的copy，是没有办法规避的。</p>
<h1 id="不要自作聪明"><a href="#不要自作聪明" class="headerlink" title="不要自作聪明"></a>不要自作聪明</h1><p>你也许会绞尽脑汁的想象出这样的代码，甚至还会很得意的以为自己解决的返回值优化的问题</p>
<pre><code class="C++">X &amp;&amp; getX() &#123;
    X x;
    return x;
&#125;
</code></pre>
<p>实际上这样的行为不可取，因为右值引用也是一个引用，返回局部对象的引用—-你是嫌弃debug时候消耗的精力还不够多吗。</p>
<p>你可能又会反驳说，那我可以这样</p>
<pre><code class="C++">X &amp;&amp; getX() &#123;
    X x;
    return std::move(x);
&#125;
</code></pre>
<p>很遗憾，还是不可以，你大可可以自己试试，你一旦访问这样返回的对象，程序就会马上崩溃！！！同理的，你也不应当对要返回的局部对象实施forward.</p>
<p>所以，不要自己耍小聪明了，该怎么写就怎么写，编译器会为优化做操劳。</p>
<h1 id="对于参数包的优化"><a href="#对于参数包的优化" class="headerlink" title="对于参数包的优化"></a>对于参数包的优化</h1><p>对于参数的参数包的优化，也是一样的，你就把他当作和上面的情况一样就可以。</p>
<pre><code class="C++">template&lt;typename ... Args&gt;
Foo getFoo_6(Args &amp;&amp; ... args) &#123;
    cout &lt;&lt; &quot;+++++&quot; &lt;&lt; endl;
    Foo foo(std::forward&lt;Args&gt;(args)...);
    return foo;
&#125;

...

work(getFoo_6(10,10.3,&quot;hello&quot;));
</code></pre>
<p>你可以自己运行一下试试看。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #00bcd4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ffa2c4">
                C++
            </a>
        </span>
        
    </div>
    <a href="/2022/09/17/ROV/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/17/template/">
        <h2 class="post-title">C++模板详解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>模板是一个非常强大的C++功能，STL的各种组件也是基于模板的。所以，无论是写程序了，还是读程序，都有必要了解一下C++的模板。</p>
<p>关于什么是模板或者模板的基本定义，这里就不讲述了，本篇文章主要罗列出在使用模板过程中的一些问题和模板一些令人头疼的语法，并配合简单的demo，如果你只是希望查阅语法或者了解一些知识点，这篇文章可能会帮到你。</p>
<p>声明：使用了using namespace std。对于应该包含进来的头文件，不再显示的声明。文中所有demo均经过测试。本文章基于《C++ Primer Plus》和《C++ Prime》。</p>
<hr>
<h2 id="模板的基本声明和定义"><a href="#模板的基本声明和定义" class="headerlink" title="模板的基本声明和定义"></a>模板的基本声明和定义</h2><h3 id="模板的声明"><a href="#模板的声明" class="headerlink" title="模板的声明"></a>模板的声明</h3><pre><code>template &lt;typename T&gt;  int compare (T t1, T t2);
template &lt;typename T&gt; class compare;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="定义一个模板函数"><a href="#定义一个模板函数" class="headerlink" title="定义一个模板函数"></a>定义一个模板函数</h3><pre><code class="cpp">template &lt;typename T&gt;
int compare(T &amp; t1, T &amp; t2)
&#123;
    if(t1 &gt; t2) 
        return 1;
    if(t1 == t2)
        return 0;
    if(t1 &lt; t2)
        return -1;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="定义一个模板类"><a href="#定义一个模板类" class="headerlink" title="定义一个模板类"></a>定义一个模板类</h3><pre><code class="cpp">template &lt;typename T&gt;
class compare
&#123;
private:
    T _val;
public:
    explicit compare(T &amp; val) : _val(val) &#123; &#125;
    explicit compare(T &amp;&amp; val) : _val(val) &#123; &#125;
    bool operator==(T &amp; t)
    &#123;
        return _val == t;
    &#125;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="模板参数作用域"><a href="#模板参数作用域" class="headerlink" title="模板参数作用域"></a>模板参数作用域</h3><p>就如同其他的函数参数一样，或者是变量一样，就是普通的作用域规则。</p>
<pre><code class="cpp">using T = int;
T a = 10;
template &lt;typename T&gt; class A;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 模板声明里的T不是上面的int而是模板参数。</p>
<pre><code class="cpp">template &lt;typename T&gt; class A
&#123;
    U val; //error
    template&lt;typename U&gt; class B;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="关于模板工作原理"><a href="#关于模板工作原理" class="headerlink" title="关于模板工作原理"></a>关于模板工作原理</h3><blockquote>
<p>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。</p>
<p>模板类在没有调用之前是不会生成代码的。</p>
<p>由于编译器并不会直接编译模板本身，所以模板的定义通常放在头文件中。</p>
</blockquote>
<h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>顾名思义，模板参数不是一个类型而是一个具体的值——这个值是常量表达式。</p>
<p>当一个模板被实例化时，，非类型参数被一个<strong>用户提供</strong>的或者<strong>编译器推断</strong>出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。</p>
<p>有一句话说：C++的强大在于他的编译器强大，下面这个例子就是很好的说明。</p>
<pre><code class="cpp">template &lt;size_t N, size_t M&gt;
int str_compare(const char (&amp;str1)[N], const char (&amp;str2)[M])
&#123;
    return strcmp(str1,str2);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 使用方法</p>
<pre><code class="cpp">str_compare(&quot;hello&quot;,&quot;nihao&quot;)
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>为什么？？？我们甚至没有用&lt;&gt;来传递模板参数。这是因为编译器在编译阶段已经帮助我们计算好了应该开辟多大空间的数组。我们也可以指定长度。N，M只是隐式的传入进去。</p>
<p>编译器也可以自动帮助我们推断参数时什么类型，从而不用显示的调用模板函数，对于上面的compare函数，我们可以这样调用，前提时保证参数类型相同。</p>
<pre><code class="cpp">compare(10,20);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>非类型模板参数的范围</p>
<p>整形，指针或者左值引用都是一个非类型模板参数。</p>
<p>我们可以想到，对于指针或者引用，应当保证实参必须具有静态的生存期，保证其不会被释放。</p>
<h3 id="inline和constexp"><a href="#inline和constexp" class="headerlink" title="inline和constexp"></a>inline和constexp</h3><p>放在模板之后，函数之前即可</p>
<pre><code class="cpp">template &lt;typename T&gt;
inline int compare(T t1, T  t2);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="在模板类中使用模板类"><a href="#在模板类中使用模板类" class="headerlink" title="在模板类中使用模板类"></a>在模板类中使用模板类</h3><p>这个应该很好理解，根据自己的需求，我们可以这样定义</p>
<pre><code class="cpp">template &lt;typename T&gt;
class A
&#123;
private:
    vector&lt;T&gt; vec;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 也可以这样定义</p>
<pre><code class="cpp">template &lt;typename T&gt;
class B
&#123;
private:
    vector&lt;int&gt; vec;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="友元与模板类"><a href="#友元与模板类" class="headerlink" title="友元与模板类"></a>友元与模板类</h3><p>通过上面编译器为模板生成具体代码的原理可以看出这样有什么不同</p>
<pre><code class="cpp">template &lt;typename N&gt;  
class C
  friend A&lt;N&gt;;
  friend B&lt;int&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 由于具体的原理类似宏替换，每个对应的C<N>都有友元A<N>和B<int>、</p>
<p>即有这样友元关系C<int> A<int> B<int>, C<string> A<string> B<string>以此类推。</p>
<p>还有这样的模板友元——所有的实例化都是其友元</p>
<pre><code class="cpp">template &lt;typename N&gt;
class C
    template &lt;typename T&gt; friend class D;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 但是没有这样的写法</p>
<pre><code class="cpp">template &lt;typename T&gt; friend class D&lt;T&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>或者这样的写法</p>
<pre><code class="cpp">template &lt;typename T&gt; friend D&lt;T&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>模板允许模板参数为自己的友元</p>
<p>首先说明，模板允许内置类型为自己的友元。</p>
<pre><code class="cpp">friend int;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样写是完全正确的，但是实际上有什么意义呢？</p>
<p>还是有意义的，我们可以这样写</p>
<pre><code class="cpp">template &lt;typename T&gt;
class People
&#123;
    friend T;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样就保证了在传入内置类型的时候不会有错误。</p>
<h3 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h3><p>用法和函数的默认参数基本相同</p>
<pre><code class="cpp">template &lt;typename T = int&gt; class A;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>默认的情况下T就是int</p>
<pre><code class="cpp">A&lt;&gt; a; // T is int
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="二义性的解决"><a href="#二义性的解决" class="headerlink" title=": : 二义性的解决"></a>: : 二义性的解决</h3><p>对于普通类的:: ，我们可以知道它究竟是一个类还是一个静态成员，就像下面这样。</p>
<pre><code class="cpp">string::size_type a;
string::npos;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>对于模板类来说，我们还是知道表达的是什么，但是已经说过了，模板类在没有 调用之前不会生成代码，这可坏了。对于T::mem，究竟是什么呢？是静态成员？还是一个类型的typedef？</p>
<p>对于这个问题，使用typename修饰。</p>
<p>当我们希望通知编译器一个名字表示一个类型时，使用且必须使用关键字typename，来表示其是一个类型。</p>
<p>于是，我们可以写出这样的代码。</p>
<pre><code class="cpp">template &lt;typename T&gt;
typename T::val_typefunc ();
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>表的不是一个静态数据成员而是一个类型。</p>
<p>或者这样的代码</p>
<pre><code class="cpp">typedef typename T::mem s_type;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>表示s_type是一个类型的别名而不是数据成员的别名。</p>
<p>如果转到string::size_type的定义，可以看见他是一个typename 的 typedef。</p>
<h3 id="类模板成员函数"><a href="#类模板成员函数" class="headerlink" title="类模板成员函数"></a>类模板成员函数</h3><p>本质上就是个函数，只要掌握了模板的工作原理，我们我们就可以轻松的写出类模板成员函数。</p>
<pre><code class="cpp">class Math
&#123;
public:
    template &lt;typename N&gt; inline static  N sqrt(N);
&#125;;

template&lt;typename N&gt;
N Math::sqrt(N val)
&#123;
    return val * val;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>首先来一点一点解析</p>
<p>这是一个模板函数，返回值为N类型，所以，模板语法写在前面，让编译器知道应该返回类型，紧接着就是返回类型，返回类型同上都是写在比较靠前的位置。接着就是函数的标签。</p>
<p>对于定义来说，应该知道是哪个类下的函数，所以和普通的方法一样加上一个作用域即可。</p>
<p>假如把类写成这样呢？</p>
<pre><code class="cpp">template &lt;typename N&gt;
class Math
&#123;
public:
    inline static  N sqrt(N);
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>那方法的定义应该是写成这样的。</p>
<pre><code class="cpp">template&lt;typename N&gt;
N Math&lt;N&gt;::sqrt(N val) 
&#123;
    return val * val;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这里就可以看出</p>
<blockquote>
<p>前面说到的，模板不是一个具体的类，而是根据这个模板编译器生成对应的版本。</p>
<p>对于每一个版本，都是不同的类。就像重载函数一样，即便参数个数和函数的具体算法完全一样，但类型不同他们也是不同的函数，只不过函数名相同而已。</p>
<p>那么就应该可以得到每个版本的类都对应的一个相应版本的静态成员。所以Math<N>::这样写也就很好理解了。</p>
</blockquote>
<h3 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h3><p>我已经不知道用什么语言来下面的代码了。但是我们知道了一些事情。</p>
<p>无论是定义还是声明，模板语法的优先级是最高的，不同模板的优先级又根据其声明顺序来判断，其次是函数修饰，然后是返回值。根据这个原则我们可以轻松的解析这个函数。 </p>
<pre><code class="cpp">template &lt;typename T&gt; class A
&#123;
public:
    template &lt;typename It&gt;  A&lt;T&gt; sum(It _begin, It _end);
&#125;;

template &lt;typename T&gt;        //最外层模板
template &lt;typename It&gt;       //内层模板
A&lt;T&gt;                         //返回值
A&lt;T&gt;::sum(It _begin, It _end)//函数标签 
&#123;&#125;                           //算法实现

//不妨写的更美观一点
template &lt;typename T&gt;
  template &lt;typename It&gt;
  A&lt;T&gt; A&lt;T&gt;::sum(It _begin, It _end)&#123;
      
  &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>注意：上面的代码和下面的代码写的足够复杂，下面的代码对其进行一些小小的修改。 </p>
<p>具体的用法，虽然下面的例子看起来有些造作，但是还是能说明一些问题的</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;
template &lt;typename T&gt; class A
&#123;
private:
    vector&lt;T&gt; vec;
public:
    template &lt;typename It&gt;  T sum(It _begin, It _end);
    A(initializer_list&lt;T&gt; initlist)    
    &#123;
        for(auto it = initlist.begin();it != initlist.end();++it)
        &#123;
            vec.push_back(*it);
        &#125;
    &#125;
    typename vector&lt;T&gt;::iterator begin()
    &#123;
        return vec.begin();
    &#125;
    typename vector&lt;T&gt;::iterator end()
    &#123;
        return vec.end();
    &#125;
&#125;;

template &lt;typename T&gt;
  template &lt;typename It&gt;
  T A&lt;T&gt;::sum(It _begin, It _end)
  &#123;
    T tot ;
    memset(&amp;tot,0,sizeof (T));
    while(_begin != _end)
    &#123;
        tot += *_begin++;
    &#125;
    return tot;
  &#125;


int main()
&#123;
    A&lt;int&gt; a &#123;1,2,3,4&#125;;
    cout &lt;&lt; a.sum(a.begin(),a.end());
    return 0;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 虽然这样的语法很是令人头疼，但是多用即可熟练，或者说使用类型别名来避免这样的问题，并且最好不要把学习精力放在语法上——在没有熟悉语法之前。</p>
<h3 id="实例化优化"><a href="#实例化优化" class="headerlink" title="实例化优化"></a>实例化优化</h3><p>当模板被调用时才会被编译，那么就会存在这样一种情况——<strong>相同地实例化可能出现在多个文件对象中</strong>。当两个或多个独立编译地源文件适用了相同地模板，并提供了相同地模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>为了解决这种问题，我们可以控制显示实例化。具体的做法如下</p>
<p>用关键字extern显示的实例化声明</p>
<pre><code class="cpp">extern template class A&lt;string&gt;;                   //声明
template int compare(const int &amp;, const int &amp;);    //定义
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<blockquote>
<p>将一个实例化声明为extern就表示承诺在程序的其他位置有该实例化的一个非extern声明（定义）。</p>
<p>由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何用此实例化版本的代码之前。 </p>
</blockquote>
<p>解释的来说：因为文件其他处已将有一个实例化——编译器生成好的或者是自己定义的，由于编译单元为.cpp文件，所以在一个文件中实例号的代码并不能用于另一个文件，这就显着很捞。而extern正是解决这个问题的。 </p>
<h2 id="类型转换和参数推断"><a href="#类型转换和参数推断" class="headerlink" title="类型转换和参数推断"></a>类型转换和参数推断</h2><p>与非普通地类型转换一样，模板类在传递模板参数的时候也会进行相应的转换，只不过这种转换增添了更多的规则，参数推断和类型转换的关系是非常紧密的。</p>
<p>类型转换这里的问题如果想要清楚的了解，那恐怕是非常可怕的，我有时候在想，通过这么多的转换规则 ，我们就可见一斑的看出C++的设计是多么的巧妙。虽然这的知识点很乱，但其实只要抓住隐藏在这背后的观念就能清晰的对付各种转换了。</p>
<p>其中一个规则是：如果能够进行安全转换，那么编译器可以隐式转换</p>
<p>最经典的一个例子就是non-const 到const的转换。</p>
<p>为了展示的方便，会忽略掉一些代码</p>
<pre><code class="cpp">template&lt;typename T&gt;
bool func(const T t1, const T t2)
&#123;
    return less&lt;T&gt;()(t1,t2);
&#125;

...

    int a = 10;
    const int b = 20;
    func&lt;int&gt;(a,b);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这里的int转为const int是允许的，因为这是按值传递，并且non-const 转为 const也不会带来什么坏处。因此，编译器会执行这样的转换。</p>
<p>我们不妨修改一下这个函数</p>
<pre><code class="cpp">bool func(const T &amp; t1, const T &amp; t2);
bool func(T &amp; t1, T &amp; t2);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上述第一个声明会正常调用——虽然是引用，和上面的是同样的道理。</p>
<p>而第二个却不会正常调用——因为b是一个const 将要转换为non-const，我中转换是不安全的，所以编译不允许这样的转换。</p>
<p>假设我们这样调用两个函数</p>
<pre><code class="cpp">func&lt;int&gt;(10,20);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>同样的，对于第一个是允许的——虽然将右值绑定到左值引用上，但是我们用const修饰形参，保证其不会改变，所以编译器同意这样的转换。</p>
<p>而对于第二个，编译器则不允许这样的转换，因为我们的形参是non-const的，不能保证不修改形参的值，形参正好又是一个引用，这样可以修改实参的值——恰好实参是一个右值——是不允许被修改的，所以编译器不允许这样的转换。</p>
<p>基于上面的转换规则，我们可以知道，如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换。</p>
<p>先来看一下代码</p>
<pre><code class="cpp">template &lt;typename T&gt; bool func(const T &amp; t1, const T &amp; t2);
...
int a[10];
int b[10];
func(a,b);
</code></pre>
<p>其实我们到目前为止的讨论，都适用于普通函数，模板的本质其实也是模板为我们生成对应的版本，为了解开上面的疑惑，我们可以先来复习以下引用的知识。</p>
<pre><code class="cpp">    int *&amp; ref_apple_point = &amp;apple; //error
    int * const &amp; ref_apple_point_const = &amp;apple; //ok
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>根据这两行代码我们可以得到一些启示。</p>
<p>因为数组名是一个常量，const T &amp; t1这样的形参是可以接受的。但对于返回值来说，可就麻烦了。返回值为内置数据类型的模板函数，对于这个问题，这没有什么好说的。返回类型为T的模板函数，他返回的是一个什么具体类型呢？首先T被u推断为* const，那么返回类型也应该是 *const</p>
<p> 在这里我们先留下一个悬念，当我们理解和编译器是如何推断T是何种类型的时候，这个问题可能就会迎刃而解。</p>
<h3 id="返回值类型推断"><a href="#返回值类型推断" class="headerlink" title="返回值类型推断"></a>返回值类型推断</h3><p>在编译器遇见函数列表之前，所有的形参都是不存在的，那么我们需要使用这样的尾置返回类型。</p>
<pre><code class="cpp">auto func(It &amp; _beg, It &amp; _end) -&gt; decltype(*_beg)
&#123;
    //...
    auto sum = *_beg;
    sum = 0;
    for_each(_beg,_end,[&amp;sum](const int &amp; val)&#123; sum+= val;&#125;);
    //...
    return sum;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样的代码还是有一些问题的，如果我们要返回一个拷贝而不是引用呢？要用到一个类型转换模板工具。</p>
<p>remove_reference&lt;&gt;    移除引用——关于其他的类型转换，不再本文章讨论范围内读者可自行查阅。</p>
<p>这个模板类有一个名为type的public成员，能够获得相应的类型。所以我们可以这样写</p>
<pre><code class="cpp">template &lt;typename It&gt;
auto func(It &amp; _beg, It &amp; _end) -&gt; typename remove_reference&lt;decltype(*_beg)&gt;::type //don&#39;t forget typename
&#123;
    //...
    auto sum = *_beg;
    sum = 0;
    for_each(_beg,_end,[&amp;sum](const int &amp; val)&#123; sum+= val;&#125;);
    //...
    return sum;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>在某些情况下我们可以指定返回u类型，例如</p>
<pre><code class="cpp">template&lt;typename T1, typename T2, typename T3&gt;
T1 sum(T2 t2, T3 t3)
&#123;
    return t2 + t3;
&#125;

sum&lt;long long&gt;(10,200); //or sum&lt;long long, int, int&gt;();
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>显示模板参数按从左到右的顺序一次匹配。</p>
<h3 id="兼容类型的模板问题"><a href="#兼容类型的模板问题" class="headerlink" title="兼容类型的模板问题"></a>兼容类型的模板问题</h3><p>有这样的代码</p>
<pre><code class="cpp">template&lt;typename T&gt;
T sum(T t1, T t2)
&#123;
    return t1 + t2;
&#125;

sum(10,3.14);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>虽然int和double兼容，但是只有一个类型参数，编译器傻了，T为int？精度会丢失，肯定是不可行的，T为double?貌似也不行，这样会导致数据溢出。无奈我们只好这样了。</p>
<pre><code class="cpp">template&lt;typename T1， typename T2&gt;
??? sum(T1 t1, T2 t2)
&#123;
    return t1 + t2;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>至于返回类型，全交给程序员来规定，或者用尾部返回类型。</p>
<h3 id="函数指针实参推断"><a href="#函数指针实参推断" class="headerlink" title="函数指针实参推断"></a>函数指针实参推断</h3><p>有趣的是，虽然在未实例化之前，编译器没有生成具体的代码，但我们仍然可以进行函数指针绑定的操作。</p>
<pre><code class="cpp">template &lt;typename T&gt; int compare(const T &amp; t1, const T &amp; t2) &#123; &#125;

int (*pf_int)(const int &amp;,const int &amp;) = compare;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>同样的我们也可以将模板函数作为回调函数进行传参，但此时可能会产生二义性，所以注意显示的写出模板参数。</p>
<blockquote>
<p>当参数是一个函数模板实例的地址时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型的值。</p>
</blockquote>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>这里是重中之重！！！重中之重！！！</p>
<p>很多的模板问题都与此有关。</p>
<p>关于const和&amp;的问题，我们上面已经讲过了。这里再进行进一步的说明。</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><pre><code class="cpp">template &lt;typename T&gt; void func1(T &amp;) &#123; &#125;
template &lt;typename T&gt; void func2(const T &amp;) &#123; &#125;
void aa()
&#123;
    int a = 10;
    const int b = 20;
    func1(a);   //T is int 
    func1(b);      //T is const int
    func2(a);      //T is int
    func2(b);      //T is int
    func2(10);     //T is int 
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>还是比较有意思的，看func2(b)的调用，虽然我们将const int类型传入进去，但是编译器为我们推导的还是int，原因应该和参数类型有关，如果编译器为我们推导的是const int ，那么const const int是不合法的，所以只好为我们推倒为int，即使我们调用时候的类型是const int。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><pre><code class="cpp">template &lt;typename T&gt; void func(T &amp;&amp;);
func(10);         //T is int
func(b);          //b is a left_val T is ???
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>我们可以根据引用折叠可以推断出类型。</p>
<h3 id="引用折叠和万能引用"><a href="#引用折叠和万能引用" class="headerlink" title="引用折叠和万能引用"></a><strong>引用折叠和万能引用</strong></h3><p>众所周知在非模板函数中可以使用const &amp; 来接受任意类型参数，在模板中，也有类似这样的万能引用，就是&amp;&amp;。知道了这样的原因是有着引用折叠得的存在。</p>
<p>先说结论：在传递参数的过程中，无论多么复杂的引用传参，最后都会被折叠为&amp; 或者 &amp;&amp;.</p>
<blockquote>
<p>如果我们间接创建了一个引用的引用，则这些引用形成折叠。除了右值引用的右值引用会被折叠为一个右值引用，剩下全部折叠为一个左值引用。即</p>
<p>T&amp; &amp;, T&amp; &amp;&amp;， T&amp;&amp; &amp;都会折叠为T&amp;</p>
<p>T&amp;&amp; &amp;&amp;会被折叠为&amp;&amp;</p>
</blockquote>
<p>这就意味着我们 可以解释上面的问题。</p>
<p>当我们将一个左值传递给一个右值引时候，编译器推断T的类型为&amp;。注意是T的类型为左值引用，不是整个形参是T &amp;。</p>
<p>所以</p>
<pre><code class="cpp">func(b);          //b is a left_val T is int&amp;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上述的两个规则导致了</p>
<blockquote>
<p>如果一个函数参数是一个指向模板类型参数的右值引用，则他可以被绑定到一个左值。</p>
<p>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数将被参数将被实例化为一个普通左值引用参数。</p>
</blockquote>
<p> 这两个规则又暗示了我们——我们可以将任意类型的实参传递给参数为右值引用的函数。</p>
<p>当代码中涉及的类型可能是非引用类型，也可能是引用类型的时候，编写正确的代码就变得异常困难（虽然remove_reference这样的转换类型对我们可能有所帮助）。</p>
<blockquote>
<p>PS：由于这里的知识是在是很乱，笔者在写这里的时候也实在无能为力，所以大量了引用C++ Primer的原文。但是有一点可以保证——笔者在这里写的demo虽然没有什么实际意义仅用于演示——但是也能说明一些问题。</p>
<p>如果读者对模板的细节想以探究经，可以翻越C++ Primer——中文第五版P508-P610。</p>
<p>如果想巩固这里的语法，可以作相应的配套习题。</p>
</blockquote>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>折磨的篇章终于过去了，让我们用好奇心来看一看std::move这个工具。</p>
<h3 id="短小精悍的std-move定义"><a href="#短小精悍的std-move定义" class="headerlink" title="短小精悍的std::move定义"></a>短小精悍的std::move定义</h3><p>如下</p>
<pre><code class="cpp">template &lt;typename T&gt;
typename remove_reference&lt;T&gt;::type &amp;&amp; move(T &amp;&amp; t)
&#123;
    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); 
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="std-move的解析"><a href="#std-move的解析" class="headerlink" title="std::move的解析"></a>std::move的解析</h3><p>因为move可以接受任意对象，所以应当是一个模板类。</p>
<p>既然我们要保证返回一个右值，那我们应当明确的得到一个非左右值引用类型——即普通类型。</p>
<p>那么就可以先移除引用再加上右值引用——这样保证了返回一个右值引用对应了</p>
<pre><code class="cpp">typename remove_reference&lt;T&gt;::type &amp;&amp;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>既然接受任意一个对象，那美可以用&amp;&amp;来接受实参，对应</p>
<pre><code class="cpp">move(T &amp;&amp; t)
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>我们只需要返回一个右值即可，所以只有一个return语句。</p>
<p>我们回想以下为什么要使用std::move——获得一个右值进行移动构造？又或者是仅仅需要一个右值？不管出于什么原因，最终的目的就是为了优化程序，所以通过形参创建一个额外的右值并返回这样是不可取的，是脱裤子放屁，所以我们要使用这条语句</p>
<pre><code class="cpp">static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>通常情况下，static——cast用于合法的类型转换，但是又一种情况例外，虽然一个左值不能隐式转换为右值，但是可以使用static_cat将其显示的转换为右值——前提我们先移除对象身上的引用效果。</p>
<p>模板和重载</p>
<p>模板也是可以被重载的，只要没有二义性。像在C++库中，存在着大量的模板重载技术，或者是可变模板参数中，也存在着模板的重载。</p>
<p>对于实例化的选择，遵循以下的规则。</p>
<blockquote>
<p>1.对于一个调用，其候选函数是所有可行的实例化</p>
<p>2.可行函数按类型转换来排序。当然，可用于函数模板调用和的类型转换是非常有限的。</p>
<p>3.和普通函数一样，如果恰又一个函数比任何其他函数都更好的匹配，则选择此函数。</p>
<p>4.如果多个函数提供了同样好的匹配</p>
<p>​    1）优先选择非模板函数</p>
<p>​    2）没有非模板函数我选择更加特例化的模板</p>
<p>​    3）否则有二意性</p>
<p>正确的定义一组重载的函数模板需要对类型键的关系以及模板幻术允许的优先的实参类型转换有着深刻的理解。</p>
<p>注意：虽然非模板函数的优先级很高——但那也是没有对应模板匹配的情况下，所以，在重载模板的时候仔细观察和思考。</p>
</blockquote>
<p>所以我们为了适配字符串的比较，可以写出这样的代码</p>
<pre><code class="cpp">template&lt;size_t N, size_t M&gt;
int compare(const char str1[N], const char str2[M])
&#123;
    return strcmp(str1,str2);
&#125;
//或者
int compare(const char * const str1, const char * const str2)
&#123;
    return strcmp(str1,str2);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 根据上面的匹配规则，我们还可以递归的调用模板类自己实现某些功能</p>
<pre><code class="cpp">template&lt;typename T&gt; string debug_rep(const T &amp; t)
&#123;
    ostringstream ret;
    ret &lt;&lt; t ;
    return ret.str();
&#125;

template&lt;typename T&gt; string debug_rep(const T * p)
&#123;
    ostringstream ret;
    ret &lt;&lt; &quot;pointer :&quot; &lt;&lt; p;
    if(p != nullptr)
        ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);
    else
        ret &lt;&lt; &quot; nullptr&quot;;
    return ret.str();
&#125;

//适配C风格字符串
string debug_reo(char * p)
&#123;
    return debug_rep(string(p));    //这是一个右值，不能获取其地址
&#125;

string debug_rep(const char * p)
&#123;
    return debug_rep(string(p));
&#125;

int main()
&#123;
    string s(&quot;hello&quot;);
    string* ps = &amp;s;
    cout &lt;&lt; debug_rep(ps) &lt;&lt; endl &lt;&lt; debug_rep(s);
    return 0;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>运行结果</p>
<p><img src="https://img-blog.csdnimg.cn/d552c7ad9be5484282089868bd42fd4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX19KQU5fXw==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<h3 id="模板函数匹配的特殊性"><a href="#模板函数匹配的特殊性" class="headerlink" title="模板函数匹配的特殊性"></a>模板函数匹配的特殊性</h3><p>难道没有发现一个异常的地方吗？对于指针版本的调用，可以这样实例化两个函数</p>
<pre><code class="cpp">string debug_rep(const string* &amp; t);
string debug_rep(string * p);
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 对于普通函数，这是无疑的二义性，但是模板会选择特例化高的，原因是const T&amp;可以实例化任何类型，而const T * p只能实例化指针类型——特例化程度更高。所以会调用后者。</p>
<p>这就说明了：不要将普通函数的匹配机制应用于模板函数匹配机制——虽然两者很像，但是还是有某些地方是不一样的。</p>
<h3 id="注意重载模板声明顺序"><a href="#注意重载模板声明顺序" class="headerlink" title="注意重载模板声明顺序"></a>注意重载模板声明顺序</h3><p>由于模板的特性，使得其可以递归的调用自己的不同版本，但是注意要调用的版本一定要事先声明或者定义，否则可能出现函数不匹配的情况</p>
<p>我们把适配char * 接口的字符串的函数放到最前面，我们发现编译器会右值河阳的错误。</p>
<blockquote>
<p>No matching function for call to ‘debug_rep’</p>
<p>调用“debug_rep”没有匹配的函数 </p>
</blockquote>
<p>或者我们将两个debug_rep的模板版本调换以下顺序。 </p>
<blockquote>
<p>Call to function ‘debug_rep’ that is neither visible in the template definition nor found by argument-dependent lookup</p>
<p>调用函数“debug_rep”，该函数在模板定义中既不可见，也不通过参数相关查找找到</p>
</blockquote>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><p>我们编写的模板，不可能保证对于所有的类型都能适用——compare函数就是很经典的例子，对于两个指针类型，仅仅是毫无意义的比较。这时候我们用到模板特例化的技术可以很好的解决这样的问题。</p>
<p>由于less的底层是使用&lt;来比较的，所以less并没有适配字符指针。那么，我们可以编写这样的模板特例化。</p>
<pre><code class="cpp">template &lt;&gt;        //表示一个模板特例化——语法规定
int compare(const char * const &amp; str1, const char * const &amp; str2) //具体的类型
&#123;
    return strcmp(str1,str2);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>可以看出，模板特例化的尖括号中没有任何说明，所以模板特例化要对所有模板那参数都进行特例化。 </p>
<p>注意，上面的特例化只能处理字符指针，不能处理数组或者字符串面量——这和函数匹配机制有关。这个特例化仅仅接受char*以及其const版本，虽然字符数组的名字就是他的地址，但是在模板中会被解释为一个字符数组的引用，更加的精准匹配。如果想要支持字符面量（本质上是字符数组）和字符数组，请写一个重载的模板函数——见模板重载。</p>
<p>我们可以使用调试观察是如何推断实参类型的</p>
<p><img src="https://img-blog.csdnimg.cn/cac84050194042999a46dff60b811f6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX19KQU5fXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<p>推断为一个数组的引用——这显然比将数组转换为指针再进行匹配更加精确。</p>
<h3 id="特例化和重载-的区别"><a href="#特例化和重载-的区别" class="headerlink" title="特例化和重载 的区别"></a>特例化和重载 的区别</h3><p>特例化就是一个特殊的实例化——模板的实例化，所以，特例化仅仅是模板的一个实例化，不会影响函数匹配。 </p>
<p>并且，模板特例化一定要保证模板的之前的声明或者定义。如果不这样做——编译器不会报错，但是会有一些令人匪夷所思的地方。模板会由编译器实例化，而不是调用自己特例化版本——这种错误往往很难查找。所以，记住一个规则：特例化一个模板，一定要保证其在原模板的定义域中。</p>
<h3 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h3><p> 这里引用《C++ Primer》的例子——对其做一些解析。</p>
<p>hash容器是能够进行十分快速的查找容器，像hash_map, hash_set等。他们的底层使用什么来映射哈希值呢? hash模板类。<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/functional/hash/?kw=hash">hash - C++ Reference (cplusplus.com)</a></p>
<p>那么对于我们自定义的类型来说，没有其对应算法，为了能够使用我们的自定义类型，我们可以定义一个其特例化版本。</p>
<p> 一个hash的特例化必须包括</p>
<blockquote>
<p>一个重载的调用运算符，接受一个容器关键字类型的对象，返回一个size_t——用于映射对象的哈希值。</p>
<p>两个类型成员，result_type, argument_type，分别调用运算符返回类型和参数类型。</p>
<p>默认构造函数和拷贝赋值运算符。</p>
</blockquote>
<p>于是我们可以写出如下的代码。</p>
<pre><code class="cpp">class Book
&#123;
    friend class std::hash&lt;Book&gt;;    //hash使用了私有成员，所以将其声明为友元
private:
    int book_id;
    string book_name;
public:
    Book() = default;
    Book(const int a, const string &amp; _name) : book_id(a), book_name(_name) &#123; &#125;
    bool operator==(const Book &amp; b) const
    &#123;
        return book_id == b.book_id;
    &#125;
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 我们首先定义一个Book类，然后提供其&#x3D;&#x3D;运算符确保hash模板能够自持我们的自定义类型。</p>
<p>随后我们在std命名空间中特例化一个和hash，</p>
<pre><code class="cpp">namespace std
&#123;
    template &lt;&gt;
    struct hash&lt;Book&gt;
    &#123;
        //必须提供的成员
        typedef size_t result_type;
        typedef Book argument_type;
        size_t operator()(const Book &amp; b) const;
    &#125;;
    size_t
    hash&lt;Book&gt;::operator()(const Book &amp;b) const &#123;
        //自定义如何组织hash_val
        return hash&lt;string&gt;()(b.book_name) ^ hash&lt;int&gt;()(b.book_id);
    &#125;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>之后，我们就可以使用unordered_set&#x2F;map，来操纵我们的自定义类型了。 </p>
<p>为了能够让自定义数据类型的特例化能够被正常使用，应该将其放在类声明对应的头文件中，或者用别的头文件将其包含进来。</p>
<h3 id="部分模板特例化"><a href="#部分模板特例化" class="headerlink" title="部分模板特例化"></a>部分模板特例化</h3><p>我们可以指定<strong>一部分而非所有的模板参数，或者是参数的一部分而非全部特性</strong>。一个模板的部分特例化本身是一个模板，使用它时用户还必须为哪些在特例化版本呢中未指定的模板参数提供实参。</p>
<p>部分特例化一部分模板参数特例化，没有特例化的部分额外的提供实参。</p>
<p>标准库的remove_reference 就是使用一系列的特例化完成其功能的，我们将其转到定义。</p>
<p>这里部分特例化的时参数的引用性质。</p>
<pre><code class="cpp">  template&lt;typename _Tp&gt;
    struct remove_reference
    &#123; typedef _Tp   type; &#125;;

  template&lt;typename _Tp&gt;
    struct remove_reference&lt;_Tp&amp;&gt;
    &#123; typedef _Tp   type; &#125;;

  template&lt;typename _Tp&gt;
    struct remove_reference&lt;_Tp&amp;&amp;&gt;
    &#123; typedef _Tp   type; &#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 具体的语法：</p>
<p>在正常的模板声明之后，在类的后面使用尖括号&lt;&gt;放入要特例化的实参，这些实参于原始模板中的参数按照位置对应。也就是对应着上面源码中的</p>
<pre><code class="cpp">struct remove_reference&lt;_Tp&amp;&amp;&gt;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<blockquote>
<p>注意：模板部分特例化并不是对于某个单单的模板参数特例化，也可能是模板参数属性的特例化，这点对于理解类模板部分特例化十分重要</p>
<p>注意：我们只能部分特例化类模板，而不能部分特例化模板函数。 </p>
</blockquote>
<p>例如我们定义一个泛用的模板类和实例化一个其专门用来处理指针的类</p>
<pre><code class="cpp">template &lt;typename T&gt;
class A;

template &lt;typename T&gt;
class A&lt;T *&gt;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="特例化成员"><a href="#特例化成员" class="headerlink" title="特例化成员"></a>特例化成员</h3><p>我们可以只特例化特定的成员函数而不是特例化整个模板类。</p>
<pre><code class="cpp">template &lt;typename T&gt;
class A
&#123;
private:
    T val;
public:
    A(const T &amp; t) : val(t) &#123; &#125;
    void func();
&#125;;

template&lt;&gt;
void A&lt;int&gt;::func()
&#123; &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 那我们这样得到的就是对于A<int>的实例化下的一个特例化func——这个func只在int的实例化版本生效。也就是说，实例化int版本的A其对应的func是我们特例化的这个版本，而其他成员还是正常的实例化。</p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>声明：关于模板的递归调用，都有一个基线函数，只不过是没有写出。</p>
<p>关于可变参数模板，一部分引用我之前的文章，再在这里做一些补充</p>
<blockquote>
<p><strong>可变模板参数</strong> <em>variadic template</em></p>
<p><strong>包</strong>          <em>packet</em></p>
<p><strong>模板参数包</strong>   <em>template parameter packet</em></p>
<p><strong>函数参数包</strong>   <em>function paremeter packet</em> </p>
</blockquote>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/JAN6055/article/details/122818685?spm=1001.2014.3001.5501">C++——C++11的标准（下）___JAN__的博客-CSDN博客<img src="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" alt=" ">https://blog.csdn.net/JAN6055/article/details/122818685?spm=1001.2014.3001.5501</a></p>
<p>详情见这篇文章的可变模板参数。 </p>
<p><strong>补充：</strong></p>
<p><strong>sizeof…运算符</strong></p>
<p>能够获得包中参数的个数</p>
<pre><code class="cpp">template&lt;typename T, typename... Args&gt;
void var_fun(const T &amp; t, const Args&amp;... args)
&#123;
    //cout &lt;&lt; t;
    cout &lt;&lt; &quot;element numbers of packs is &quot; &lt;&lt; sizeof...(Args);
    //var_fun(args...);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>包拓展</strong></p>
<blockquote>
<p><strong>拓展</strong>    <em>packs expand</em></p>
<p>包拓展简单的来说将他分解为其构成的元素，如果说将参数变为包的过成类比为压缩未见，那么包拓展就是解压文件，但包拓展不仅仅是包展开。</p>
</blockquote>
<p>当拓展一个包时，我们还要提供用于，每个拓展元素的<strong>模式</strong>。拓展一个包就是将它费解为构成的原书，对每个元素应用模式，获得拓展后的列表。我们通过在模式右边防一个省略号…来触发拓展操作 。</p>
<blockquote>
<p>什么是模式？</p>
<p>在实际生活中，当我们说以一种模式打开某个东西，或者是什么模式打开时。指定的是固有的模式，比如说性能模式，均衡模式等。而抱拓展的模式更像是对于每个元素都调用一次相应的函数，包拓展需要我们自定义模式——其实就是一个函数，返回值为包中的一个元素应用模式后的结果，所有这样的结果组合在一起，也就是包以这个模式（函数）展开。</p>
</blockquote>
<p>看一下标准库的配置器中是如何使用的展开</p>
<pre><code class="cpp">noexcept(noexcept(::new((void *)__p)
                _Up(std::forward&lt;_Args&gt;(__args)...)))
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这是一个函数异常声明的部分，当用一个包构造一个元素的时候不会抛出异常，仅当，使用转发模式对参数包进行展开的时候不抛出异常。</p>
<pre><code class="cpp">    var_func(args...);      //默认的包展开
    //注释部分的...不为关键字，和C++语法没有任何关系
    //相当于这样&#123;ele1, ele2, ele3, ... ,elen&#125;
    var_fun(mul(2,args)...);    //带有模式的包展开
    //第二种展开模式相当于这样
    //&#123; mul(2,ele0),mul(2,ele1),mul(2,ele2), ... mul(2,elen) &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>具体实验</p>
<pre><code class="cpp">template &lt;typename T&gt;
void print(const T &amp; t)
&#123;
  cout &lt;&lt; t &lt;&lt; endl;
&#125;
template &lt;typename T, typename... Args&gt;
void print(const T &amp;t ,const Args... args)
&#123;
  cout &lt;&lt; t &lt;&lt; endl;
  print(args...);
&#125;

template &lt;typename T&gt;
int up(T &amp; t)
&#123;
  t *= 2;
  return t;
&#125;
template &lt;typename... Args&gt;
void func(Args&amp;&amp;... args)
&#123;
  print(up(args)...);
&#125;

int main()
&#123;
  func(1,2,3,4,5);
  return 0;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 运行结果</p>
<p><img src="https://img-blog.csdnimg.cn/07fd5425aa89414d88e86c521823742e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<h3 id="可变模板参数的具体作用"><a href="#可变模板参数的具体作用" class="headerlink" title="可变模板参数的具体作用"></a>可变模板参数的具体作用</h3><p>可变模板参数可以说是一个核弹，比如tuple就是使用其实现的，模板类tuple以私有继承的方式继承它自己并结合模板部分特例化。如下</p>
<pre><code class="cpp">template&lt;typename T, typename ... Args&gt;
class tuple&lt;T,Args...&gt; : private tuple&lt;Args...&gt;
&#123;
    //something
&#125;;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 还是很奇妙的，具体详情请观看侯捷老师的视频——bilibili ： <img src="https://img-blog.csdnimg.cn/d4465dc3a3e84b0ba1857922cf22379d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAX19KQU5fXw==,size_13,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<h2 id="模板技巧"><a href="#模板技巧" class="headerlink" title="模板技巧"></a>模板技巧</h2><p>模板的功能还是很强大的，我们有必要学习一些模板技巧。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><blockquote>
<p> 什么是转发？</p>
<p>某些函数需要将其一个或多个实参连<strong>同类型不变的****传递</strong>给其他函数。这个过程就叫<strong>转发。</strong></p>
<p>很形象，一个函数把数据原封不动的传递给另一个函数，就是转发。</p>
</blockquote>
<p>什么时候会用到转发呢？比如说我们有这样的一个函数，在容器尾部直接使用我们穿进来的参数构造一个元素，这个时候使用转发就是很有必要的。如果我们不适用转发技术，可能会造成变量的复制，也许有的时候这个函数能正常使用，但是有的时候我们就需要引用来做事，所以这样做留下的错误的隐患。 </p>
<p>假设有func1(int &amp;，args) fun2 work(args，int&amp;);</p>
<p>我们需要传进func1一个整形，经过func2的中间媒介，传入work，并在work中改变那个变量。</p>
<p>读者可以试一下func2中使用什么样的参数，经过怎样的变换可以对原来的参数的性质原封不动的传递给work。这是比较简单的情况了。STL的部分函数实现会有恐怖的调用层次，如果不使用转发技术后果可想而知。</p>
<h3 id="使用std-forward"><a href="#使用std-forward" class="headerlink" title="使用std::forward"></a>使用std::forward</h3><p>要说转发一定离不开std::forward</p>
<p>forward返回实参类型的右值引用。它和move很像，但前者是返回给定类型的右值引用，如果给定的类型是左值引用也返回其右值引用——左值引用，并且其必须显式的指定模板参数；而move无论模板参数类型是什么都返回一个右值引用（只能是右值引用），因为前面已经看到了move的实现方法。</p>
<p>于是我们可以定义下面的转发函数    </p>
<pre><code class="cpp">template &lt;typename F, typename T1, typename T2&gt;
void fun(F f, T1 &amp;&amp; t1, T2 &amp;&amp; t2)
&#123;
    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>使用右值引用作为模板参数——确保接受任意对象，并保证其能保持原来的性质不变（见引用折叠）。在发送参数的过程中获得对应类型的右值——确保其传递给函数的参数的性质不变（见引用折叠）。</p>
<p>更简单的来说，上述的写法是对于所有类型的对象，无论进行何种参数传递，其参数的性质都不会改变的通用情况。</p>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><p>根据上面转发的关键字，我们可以知道，在进行转发的时候应该以何种模式进行包展开。</p>
<pre><code>(Args&amp;&amp; ... args) //以右值引用展开参数包
std::forward&lt;Args&gt;(args)... //将包中的每一个元素应用于forward
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 所以我们可以这样做</p>
<pre><code class="cpp">template&lt;typename ... Args&gt;
void buffer_fun(Args &amp;&amp;... args)
&#123;
    work(std::forward&lt;Args&gt;(args)...);
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="make-shared的工作原理"><a href="#make-shared的工作原理" class="headerlink" title="make_shared的工作原理"></a>make_shared的工作原理</h3><p>std::make_shred就是基于转发参数包实现的。</p>
<p>让我们先来回忆make_shared的其中一个使用方法。</p>
<p>make_shared<T> name (args);</p>
<p>很明显的可以推断其应该使用用可变模板参数，我们转到其定义</p>
<pre><code class="cpp">  template&lt;typename _Tp, typename... _Args&gt;
    inline shared_ptr&lt;_Tp&gt;
    make_shared(_Args&amp;&amp;... __args)
    &#123;
      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;
      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),
                       std::forward&lt;_Args&gt;(__args)...);
    &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>可以看见，其使用部分特例化和可变参数模板，将包转发给了std::allocate_shared进行空间分配，我们进一步的转到std::allocate_shared中可以看见其有进一步的将其转发给了其他的模板</p>
<pre><code class="cpp">  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;
    inline shared_ptr&lt;_Tp&gt;
    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)
    &#123;
      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);

      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;&#123;__a&#125;,
                 std::forward&lt;_Args&gt;(__args)...);
    &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<hr>
<p>至此，C++的模板的基础知识点大抵应该是都讲完了，如果日后有一些杂项补充的话会更在下面。</p>
<blockquote>
<p>后来的话: 这篇文章有一些地方讲的还是比较不清晰的，现在已经修正了一部分，并且增添了对一部分知识点的代码，日后也会慢慢修改。如果你发现本篇文章的错误或者对本篇文章有什么建议可以评论区留言或者私信笔者。</p>
<p>​                                                            ——2022.6.1</p>
</blockquote>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">
                C++
            </a>
        </span>
        
    </div>
    <a href="/2022/09/17/template/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/17/const-container-s-iterator-is-const-iterator/">
        <h2 class="post-title">Const Container&#39;s Iterator Is Const_iterator</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>就拿vector举例子</p>
<p>我们转到其代码</p>
<pre><code class="C++">  template&lt;typename _Container&gt;
    inline _GLIBCXX17_CONSTEXPR auto
    begin(_Container&amp; __cont) -&gt; decltype(__cont.begin())
    &#123; return __cont.begin(); &#125;

  /**
   *  @brief  Return an iterator pointing to the first element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template&lt;typename _Container&gt;
    inline _GLIBCXX17_CONSTEXPR auto
    begin(const _Container&amp; __cont) -&gt; decltype(__cont.begin())
    &#123; return __cont.begin(); &#125;

  /**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the container.
   *  @param  __cont  Container.
   */
  template&lt;typename _Container&gt;
    inline _GLIBCXX17_CONSTEXPR auto
    end(_Container&amp; __cont) -&gt; decltype(__cont.end())
    &#123; return __cont.end(); &#125;

  /**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template&lt;typename _Container&gt;
    inline _GLIBCXX17_CONSTEXPR auto
    end(const _Container&amp; __cont) -&gt; decltype(__cont.end())
    &#123; return __cont.end(); &#125;

  /**
   *  @brief  Return an iterator pointing to the first element of the array.
   *  @param  __arr  Array.
   */
  template&lt;typename _Tp, size_t _Nm&gt;
    inline _GLIBCXX14_CONSTEXPR _Tp*
    begin(_Tp (&amp;__arr)[_Nm]) noexcept
    &#123; return __arr; &#125;

  /**
   *  @brief  Return an iterator pointing to one past the last element
   *          of the array.
   *  @param  __arr  Array.
   */
  template&lt;typename _Tp, size_t _Nm&gt;
    inline _GLIBCXX14_CONSTEXPR _Tp*
    end(_Tp (&amp;__arr)[_Nm]) noexcept
    &#123; return __arr + _Nm; &#125;
</code></pre>
<p>可以看见对于const的重载版本，返回的为const_iterator.</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在Modern Effective C++中说到，在通用的代码中，优先选用非成员版的begin()&#x2F;end(),也正是因为如此。</p>
<p>书中给出了cbegin()的一种实现方式。</p>
<pre><code class="C++">template &lt;typename C&gt;
auto cbegin(const C &amp; c)-&gt; decltype(c.begin()) &#123;
    return c.begin();
&#125;
</code></pre>
<p>因为对于具有const性质的容器（在标准库中的是这样，如果是其他库提供的容器，可能不会提供这样的行为），返回的迭代器是const_iterator,所以，这样做是正确的。</p>
<p>对于数组来说，也是一样的。begin对于数组有特例化。 上面的代码已经看到了。</p>
<p>当数组具有const性质的时候，例如const int nums[10], _Tp会被推导为const int, 返回类型就是const int *, 就是数组的const_iterator</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ffa2c4">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
    </div>
    <a href="/2022/09/17/const-container-s-iterator-is-const-iterator/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/17/pass-by-value-and-use-std-move/">
        <h2 class="post-title">Pass by Value and Use Std::move</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="一个警告引发的思考"><a href="#一个警告引发的思考" class="headerlink" title="一个警告引发的思考"></a>一个警告引发的思考</h1><p>在c++11之前，无论是effective系列还是c++教程，都会告诉我们在一定情况下使用const &amp;来节省性能。但是在c++11之后，有了移动语义，使一些不可能的行为变成了可能。我们先来看一段简单的代码。</p>
<pre><code class="cpp">class Person &#123;
private:
    unsigned m_age = 0;
    string m_name;
    Person(const string &amp; name) : m_name(name) &#123; &#125;
&#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>clang-tidy会给出这样的一个警告。</p>
<blockquote>
<p>Clang-Tidy: Pass by value and use std::move</p>
</blockquote>
<p>为什么会这样呢，这无疑是一个正确的构造函数，但是为什么还要给我们这样的警告呢？</p>
<h1 id="使用值传递加移动语义避免不必要的消耗"><a href="#使用值传递加移动语义避免不必要的消耗" class="headerlink" title="使用值传递加移动语义避免不必要的消耗"></a>使用值传递加移动语义避免不必要的消耗</h1><p>我们按照警告更改成后是这样</p>
<pre><code class="cpp">Person(string  name) : m_name(std::move(name)) &#123; &#125;
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>你可能会感到疑惑？为什么使用了值传递还会有更高的性能呢？这似乎和直觉不符。</p>
<p>慢慢来，我们一点点分析。</p>
<p>为了测试，我们准备一个类Foo，和一个代理的测试类Test。</p>
<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
struct Foo &#123;
    Foo() &#123;
//        cout &lt;&lt; &quot;default&quot; &lt;&lt; endl;
    &#125;
    Foo(Foo &amp;&amp;)  noexcept &#123;
        cout &lt;&lt; &quot;&amp;&amp;&quot; &lt;&lt; endl;
    &#125;
    Foo(const Foo &amp; ) &#123;
        cout &lt;&lt; &quot;&amp;&quot; &lt;&lt; endl;
    &#125;
    Foo &amp; operator=(const Foo &amp;) &#123;
        cout &lt;&lt; &quot;operator=(&amp;)&quot;  &lt;&lt; endl;
        return *this;
    &#125;
    Foo &amp; operator=(Foo &amp;&amp; ) noexcept &#123;
        cout &lt;&lt; &quot;operator=(&amp;&amp;)&quot;  &lt;&lt; endl;
        return *this;
    &#125;
    Foo operator+(const Foo &amp;) &#123;
//        cout &lt;&lt; &quot;operator+(&amp;)&quot; &lt;&lt; endl;
        return *this;
    &#125;
&#125;;

struct Test1 &#123;
    Foo m_foo;
    void setFoo(Foo foo) &#123;
        m_foo = std::move(foo);
    &#125;
&#125;;

struct Test2 &#123;
    Foo m_foo;
    void setFoo(const Foo &amp; foo) &#123;
        m_foo = foo;
    &#125;
&#125;;
int main()
&#123;
    Test1 test1;
    Foo foo;
    Foo foo1;
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(foo);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(foo + foo1);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(Foo&#123;&#125;);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(std::move(foo));
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test1.setFoo(std::move(Foo&#123;&#125;));
    cout &lt;&lt; &quot;-----\n&quot; &lt;&lt; endl;

    Test2 test2;
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;

    test2.setFoo(foo);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test2.setFoo(foo + foo1);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test2.setFoo(Foo&#123;&#125;);
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    test2.setFoo(std::move(foo));
    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>对于不同的情况，或由不同的结果，C++的特性和复杂性在这里体现的淋漓尽致。</p>
<blockquote>
<p>首先我们应当知道现代C++规定了编译器应当对于返回值进行优化。对于这样的一个函数</p>
<p>X foo() { X x; return x; }</p>
<p>现在的编译器在调用x的时候，就像直接调用构造X::X()一样，不必经过额外的拷贝。对于返回值优化问题，还有一些规则，我打算放在另一篇博客里面说。</p>
<p>详情请见C++标准库(中文第二版)P19,P20,P21</p>
</blockquote>
<p>所以，甚至对于返回值优化的情况，我们也应当考虑进去。比如说对于</p>
<p><code>setFoo(Foo&#123;&#125;)和setFoo(std::move(foo))</code>可能会有和我们预期不符合的结果。</p>
<p>运行结果</p>
<pre><code>-----
&amp;			 //copy ctor
operator=(&amp;&amp;) //move
-----
&amp;			 //这里的copy，是+运算符返回的时候产生的
operator=(&amp;&amp;) //move
-----
operator=(&amp;&amp;) //这里只有一个move而Foo&#123;&#125;没有copy到形参，是编译器优化后的结构
-----
&amp;&amp;		     //使用std::move所以移动构造
operator=(&amp;&amp;) //move
-----
&amp;&amp;            //使用std::move编译器不再优化Foo&#123;&#125;，转而和上种情况一样
operator=(&amp;&amp;) //move
-----

-----
operator=(&amp;)  //按引用传参，ctor
-----
&amp;			 //这里的copy，是+运算符返回的时候产生的
operator=(&amp;)  //ctor
-----
operator=(&amp;)  //编译器优化，只有一个ctor
-----
operator=(&amp;)  //Clang-Tidy：将 std::move() 的结果作为 const 引用参数传递； 实际上不会发生任何动作,所以同上
-----
operator=(&amp;)  //Clang-Tidy：将 std::move() 的结果作为 const 引用参数传递； 实际上不会发生任何动作。同上
-----
</code></pre>
<blockquote>
<p>关于这个问题，Modern Effective C++也有探讨。见条款41。</p>
</blockquote>
<p>这够令人头大了，实际情况可能比我们想象的还要复杂。</p>
<p>但是综上来看，我们不难得出一个结论。如果类型的移动语义具有较低的成本，可以使用pass by value and use std move的这种方式来进行性能优化。</p>
<p>但是，如果类型的移动语义具有一定的消耗，不推荐这样做。就像如果我们处理的是一些短字符串，那么引用方式的传递肯定比值传递+移动这种方式要高效。如果是较长的字符串，使用值传递+引用的方式比较高效。</p>
<p>并且，如果对象支持移动操作，那么他就会移动，如果对象不支持移动操作，那么值传递+引用的方式会copy两次，这是需要注意的。</p>
<p>这些复杂的请况都要”归功“编译器的优化，如果实在搞不明白，那就任他去吧！说实话，作者在这里对于所有的细节也不是全部清晰。那就记住我们上面得出的的结论即可。我们不是编译器的实现者，这些问题无关大雅。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Modern-C/" style="color: #ff7d73">
                Modern C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">
                C++
            </a>
        </span>
        
    </div>
    <a href="/2022/09/17/pass-by-value-and-use-std-move/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
    </div>
    <div class="next">
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://avatars.githubusercontent.com/u/94843786?s=400&u=3e0bac8cdc09c80d159d076c0503db566f8f0579&v=4 " alt="avatar">
        </div>
        <div class="name">
            Jan6055
        </div>
        <div class="descriptions">
            
            <div class="description">
                兴趣：
            </div>
            
            <div class="description">
                C++
            </div>
            
            <div class="description">
                Rust
            </div>
            
            <div class="description">
                Haskell
            </div>
            
            <div class="description">
                这是我的个人博客，用于记录学习到的技能
            </div>
            
            <div class="description">
                我希望我的博客会帮到你
            </div>
            
            <div class="description">
                如果你对博客中的内容有疑问，请联系
            </div>
            
            <div class="description">
                QQ: 1796728809
            </div>
            
            <div class="description">
                email: 1796728809@qq.com
            </div>
            
            <div class="description">
                wangq6055@outlook.com
            </div>
            
            <div class="description">
                目前:
            </div>
            
            <div class="description">
                在校大二学生
            </div>
            
            <div class="description">
                在学习Modern C++ &amp;&amp; 各种计算机基础
            </div>
            
            <div class="description">
                时不时摆烂，很爽
            </div>
            
            <div class="description">
                But I love coding!
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/jan6055">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hello @you
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Jan6055
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>